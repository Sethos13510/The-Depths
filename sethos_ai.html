<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TikTok Horror Experience - Saison 1: Les Profondeurs</title>
    <!-- Scripts de correctifs unifiés -->
    <script src="js-unified/unified_fixes.js"></script>
    <!-- Styles unifiés -->
    <link rel="stylesheet" href="css-unified/unified_styles.css">
    <!-- Socket.IO Version 4.5.4 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.4/socket.io.min.js"></script>
    <!-- Module Socket.IO unifié -->
    <script src="js-unified/unified_socket.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
        
        #loading { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: #000; 
            color: #fff; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            z-index: 1000;
        }
        
        #debug {
            position: fixed; 
            top: 10px; 
            left: 10px; 
            z-index: 10;
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px;
            border-radius: 5px;
        }
        
        #donation-panel {
            position: fixed;
            right: 10px;
            top: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 180px;
            font-size: 11px;
            display: none; /* Hide donation panel as requested */
        }
        
        #donation-panel h3 {
            margin-top: 0;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 40px; /* Déplacé plus bas pour éviter le chevauchement */
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            max-width: 400px;
            z-index: 900;
        }
        
        .progress-bar {
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            margin-bottom: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9900);
            width: 0%;
            transition: width 1s ease-in-out;
        }
        
        #story-milestone {
            position: fixed;
            top: 80px; /* Déplacé encore plus bas */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 12px;
            z-index: 900;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
            padding: 5px 10px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            width: 40%;
            max-width: 400px;
            line-height: 1.3;
            display: none; /* Caché par défaut, sera affiché dans le journal uniquement */
        }
        
        #donor-wall {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Aligné avec le journal d'exploration */
            max-height: 130px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Caché car remplacé par top100 */
        }
        
        #top100-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* En bas de l'écran, directement sous le journal */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px;
            max-height: 150px;
            overflow: hidden;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Caché car remplacé par leaderboard-panel */
        }
        
        #top100-panel h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 13px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .top100-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
            position: relative;
        }
        
        .top100-rank {
            width: 20px;
            text-align: center;
            color: #aaa;
        }
        
        .top100-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .top100-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #narrative-display {
            position: fixed;
            top: 50%; /* Centré verticalement */
            left: 50%;
            transform: translate(-50%, -50%); /* Centrage parfait */
            z-index: 950;
            color: white;
            text-align: center;
            width: 70%;
            max-width: 600px;
            text-shadow: 0 0 3px black, 0 0 5px black;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Fond plus opaque pour meilleure lisibilité */
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none; /* Pour éviter d'interférer avec les clics */
        }
        
        #narrative-display.visible {
            opacity: 0.95;
        }
        
        #clue-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 950;
            color: #ffcc00;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 3px solid #ffcc00;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease-out;
        }
        
        #clue-notification.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #event-counter {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            color: white;
            font-size: 120px;
            text-shadow: 0 0 20px red;
            opacity: 0;
            transition: all 0.3s ease-in-out;
            pointer-events: none;
        }
        
        #event-counter.visible {
            opacity: 1;
        }
        
        button, input { 
            margin: 5px 0; 
            display: block;
            border: none;
            background: #444;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #666;
        }
        
        #sim-donation {
            margin-top: 15px;
            width: 100%;
        }
        
        #vote-panel {
            position: fixed;
            right: 10px;
            bottom: 10px; /* En bas à droite */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 160px;
            font-size: 10px;
            display: none;
        }
        
        .vote-option {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .vote-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .vote-bar {
            height: 5px;
            width: 100%;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .vote-fill {
            height: 100%;
            background: linear-gradient(90deg, #77ccff, #4488ff);
            width: 30%;
        }
        
        /* Animation pour les effects */
        @keyframes pulse {
            0% { opacity: 0.2; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.2; transform: scale(0.95); }
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        #leaderboard-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* Repositionné en bas sous le journal */
            top: auto; /* Annule la position top précédente */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 200px;
            max-height: 145px; /* Hauteur réduite pour éviter le chevauchement (était à 150px) */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #leaderboard-panel h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #aaa;
            width: 20px;
            text-align: center;
        }
        
        .leaderboard-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .leaderboard-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #story-history-panel {
            position: fixed;
            left: 10px;
            bottom: 175px; /* Remonté plus haut pour éviter le chevauchement (était à 70px) */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Élargi pour mieux afficher les messages */
            max-height: 180px; /* Légèrement plus grand */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #story-history-panel h3 {
            margin-top: 0;
            margin-bottom: 3px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .history-item {
            margin-bottom: 4px;
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .history-item-milestone {
            background-color: rgba(255, 204, 0, 0.2);
            border-left: 2px solid #ffcc00;
        }
        
        .history-item-discovery {
            background-color: rgba(119, 204, 255, 0.2);
            border-left: 2px solid #77ccff;
        }
        
        .history-item-event {
            background-color: rgba(255, 102, 102, 0.2);
            border-left: 2px solid #ff6666;
        }
        
        .history-timestamp {
            color: #aaa;
            font-size: 8px;
            margin-bottom: 2px;
            font-style: italic;
        }
        
        /* Style pour réserver l'espace pour la caméra */
        .camera-space {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 100px;
            z-index: 800;
            /* Background commenté - juste pour visualiser l'espace réservé 
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            */
        }
        
        /* Assurons-nous que tous les panneaux ont une apparence cohérente */
        #leaderboard-panel, #story-history-panel, #vote-panel, #donor-wall {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.85; /* Légèrement transparent pour voir le bateau derrière */
        }
        
        /* Animation de défilement automatique pour les panneaux */
        @keyframes autoscroll {
            0% { transform: translateY(0); }
            45% { transform: translateY(calc(-100% + 100px)); }
            55% { transform: translateY(calc(-100% + 100px)); } /* Pause au bas pendant 10% de l'animation */
            57% { transform: translateY(0); } /* Retour très rapide au début (2% de l'animation) */
            100% { transform: translateY(0); } /* Pause au début avant de recommencer */
        }
        
        .autoscroll-container {
            height: 100%;
            overflow: hidden;
            position: relative;
            max-height: inherit;
        }
        
        .autoscroll-content {
            animation: autoscroll 60s linear infinite; /* Remis à "infinite" pour boucler */
            animation-play-state: running;
            padding-bottom: 20px; /* Add space at the bottom before repeating */
        }
        
        .autoscroll-content:hover {
            animation-play-state: paused;
        }
        
        /* Objectifs sur la barre en haut */
        #objectives-panel {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            display: flex;
            gap: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .objective {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .objective-icon {
            color: #ffcc00;
            font-size: 14px;
        }
        
        .objective-text {
            white-space: nowrap;
        }
        
        /* 
        Organisation des panneaux :
        - Haut: Objectifs
        - Droite: Progression narrative 
        - À gauche milieu: Journal d'exploration
        - À gauche bas: Classement des explorateurs
        - En bas à droite: Panneau de vote
        - Centre haut (ajusté): Barre de progression
        - Centre bas: Affichage narratif
        */
        
        /* Hover effect pour rendre les panneaux plus lisibles au survol */
        #leaderboard-panel:hover, #story-history-panel:hover, #donation-panel:hover, #vote-panel:hover, #donor-wall:hover {
            opacity: 0.95;
            z-index: 950; /* Augmente le z-index au survol pour s'assurer qu'il est au-dessus des autres */
        }
        
        /* Style pour les titres des panneaux */
        #leaderboard-panel h3, #story-history-panel h3, #donor-wall h4 {
            color: #ffcc00;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        #details-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 950;
            background: rgba(0,0,0,0.7);
            color: #ffcc00;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid rgba(255, 204, 0, 0.3);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            display: none; /* Cacher le bouton des détails d'exploration */
        }
        
        #details-button:hover {
            background: rgba(50,50,0,0.7);
            border-color: rgba(255, 204, 0, 0.6);
        }
        
        /* Overlay d'authentification */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #33ff33;
            font-family: 'Courier New', monospace;
        }
        
        .auth-content {
            text-align: center;
            max-width: 500px;
            padding: 20px;
        }
        
        .auth-logo {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
        }
        
        .auth-message {
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        .auth-warning {
            color: #ff3333;
            margin-top: 20px;
            font-size: 12px;
            max-width: 80%;
            text-align: justify;
        }
        
        .donation-progress-container {
            width: 300px;
            margin: 0 auto;
        }
        
        .donation-label {
            color: #fff;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .donation-bar {
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #ff3366;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        #auth-donation-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff3366, #ff6699);
            transition: width 0.5s ease-in-out;
        }
        
        .auth-gauge {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .auth-gauge h3 {
            margin-top: 0;
            font-size: 14px;
            color: #ffcc00;
        }
        
        .tiktok-integration-notice {
            font-size: 12px;
            color: #ccc;
        }
        
        /* Notifications d'authentification */
        .auth-notification {
            position: fixed;
            right: -300px;
            top: 100px;
            background: linear-gradient(90deg, #330033, #5a0057);
            border-left: 3px solid #ff3366;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            padding: 15px;
            width: 250px;
            border-radius: 5px 0 0 5px;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .auth-notification.show {
            right: 0;
        }
        
        .auth-username {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .auth-amount {
            color: #ff3366;
            font-weight: bold;
            font-size: 18px;
        }
        
        /* Statut du système */
        .system-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #33ff33;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #ff3333;
        }
        
        .status-indicator.online {
            background-color: #33ff33;
        }
        
        /* Animation de pulsation pour la jauge */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .auth-gauge.pulse {
            animation: pulse 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
    <!-- Inclure les fichiers externes pour la gestion de l'authentification -->
    <script src="auth_gauge.js"></script>
    <script>
        // Utiliser la valeur de REQUIRED_AMOUNT définie dans auth_gauge.js
        // au lieu de redéclarer cette variable
        document.addEventListener('DOMContentLoaded', function() {
            // Vérifier la connexion aux événements story
            if (typeof setupStoryEventHandlers === 'function') {
                console.log('🟠 SETHOS - Initialisation des gestionnaires d\'événements story');
                setupStoryEventHandlers();
                
                // Vérifier immédiatement les mises à jour
                if (typeof checkServerUpdates === 'function') {
                    setTimeout(checkServerUpdates, 1000);
                }
            }
        });
    </script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TikTok Horror Experience - Saison 1: Les Profondeurs</title>
    <link rel="stylesheet" href="responsive.css">
    <link rel="stylesheet" href="auth_gauge.css">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
        
        #loading { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: #000; 
            color: #fff; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            z-index: 1000;
        }
        
        #debug {
            position: fixed; 
            top: 10px; 
            left: 10px; 
            z-index: 10;
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px;
            border-radius: 5px;
        }
        
        #donation-panel {
            position: fixed;
            right: 10px;
            top: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 180px;
            font-size: 11px;
            display: none; /* Hide donation panel as requested */
        }
        
        #donation-panel h3 {
            margin-top: 0;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 40px; /* Déplacé plus bas pour éviter le chevauchement */
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            max-width: 400px;
            z-index: 900;
        }
        
        .progress-bar {
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            margin-bottom: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9900);
            width: 0%;
            transition: width 1s ease-in-out;
        }
        
        #story-milestone {
            position: fixed;
            top: 80px; /* Déplacé encore plus bas */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 12px;
            z-index: 900;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
            padding: 5px 10px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            width: 40%;
            max-width: 400px;
            line-height: 1.3;
            display: none; /* Caché par défaut, sera affiché dans le journal uniquement */
        }
        
        #donor-wall {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Aligné avec le journal d'exploration */
            max-height: 130px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Caché car remplacé par top100 */
        }
        
        #top100-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* En bas de l'écran, directement sous le journal */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px;
            max-height: 150px;
            overflow: hidden;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Caché car remplacé par leaderboard-panel */
        }
        
        #top100-panel h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 13px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .top100-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
            position: relative;
        }
        
        .top100-rank {
            width: 20px;
            text-align: center;
            color: #aaa;
        }
        
        .top100-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .top100-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #narrative-display {
            position: fixed;
            top: 50%; /* Centré verticalement */
            left: 50%;
            transform: translate(-50%, -50%); /* Centrage parfait */
            z-index: 950;
            color: white;
            text-align: center;
            width: 70%;
            max-width: 600px;
            text-shadow: 0 0 3px black, 0 0 5px black;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Fond plus opaque pour meilleure lisibilité */
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none; /* Pour éviter d'interférer avec les clics */
        }
        
        #narrative-display.visible {
            opacity: 0.95;
        }
        
        #clue-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 950;
            color: #ffcc00;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 3px solid #ffcc00;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease-out;
        }
        
        #clue-notification.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #event-counter {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            color: white;
            font-size: 120px;
            text-shadow: 0 0 20px red;
            opacity: 0;
            transition: all 0.3s ease-in-out;
            pointer-events: none;
        }
        
        #event-counter.visible {
            opacity: 1;
        }
        
        button, input { 
            margin: 5px 0; 
            display: block;
            border: none;
            background: #444;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #666;
        }
        
        #sim-donation {
            margin-top: 15px;
            width: 100%;
        }
        
        #vote-panel {
            position: fixed;
            right: 10px;
            bottom: 10px; /* En bas à droite */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 160px;
            font-size: 10px;
            display: none;
        }
        
        .vote-option {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .vote-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .vote-bar {
            height: 5px;
            width: 100%;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .vote-fill {
            height: 100%;
            background: linear-gradient(90deg, #77ccff, #4488ff);
            width: 30%;
        }
        
        /* Animation pour les effects */
        @keyframes pulse {
            0% { opacity: 0.2; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.2; transform: scale(0.95); }
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        #leaderboard-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* Repositionné en bas sous le journal */
            top: auto; /* Annule la position top précédente */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 200px;
            max-height: 145px; /* Hauteur réduite pour éviter le chevauchement (était à 150px) */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #leaderboard-panel h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #aaa;
            width: 20px;
            text-align: center;
        }
        
        .leaderboard-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .leaderboard-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #story-history-panel {
            position: fixed;
            left: 10px;
            bottom: 175px; /* Remonté plus haut pour éviter le chevauchement (était à 70px) */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Élargi pour mieux afficher les messages */
            max-height: 180px; /* Légèrement plus grand */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #story-history-panel h3 {
            margin-top: 0;
            margin-bottom: 3px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .history-item {
            margin-bottom: 4px;
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .history-item-milestone {
            background-color: rgba(255, 204, 0, 0.2);
            border-left: 2px solid #ffcc00;
        }
        
        .history-item-discovery {
            background-color: rgba(119, 204, 255, 0.2);
            border-left: 2px solid #77ccff;
        }
        
        .history-item-event {
            background-color: rgba(255, 102, 102, 0.2);
            border-left: 2px solid #ff6666;
        }
        
        .history-timestamp {
            color: #aaa;
            font-size: 8px;
            margin-bottom: 2px;
            font-style: italic;
        }
        
        /* Style pour réserver l'espace pour la caméra */
        .camera-space {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 100px;
            z-index: 800;
            /* Background commenté - juste pour visualiser l'espace réservé 
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            */
        }
        
        /* Assurons-nous que tous les panneaux ont une apparence cohérente */
        #leaderboard-panel, #story-history-panel, #vote-panel, #donor-wall {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.85; /* Légèrement transparent pour voir le bateau derrière */
        }
        
        /* Animation de défilement automatique pour les panneaux */
        @keyframes autoscroll {
            0% { transform: translateY(0); }
            45% { transform: translateY(calc(-100% + 100px)); }
            55% { transform: translateY(calc(-100% + 100px)); } /* Pause au bas pendant 10% de l'animation */
            57% { transform: translateY(0); } /* Retour très rapide au début (2% de l'animation) */
            100% { transform: translateY(0); } /* Pause au début avant de recommencer */
        }
        
        .autoscroll-container {
            height: 100%;
            overflow: hidden;
            position: relative;
            max-height: inherit;
        }
        
        .autoscroll-content {
            animation: autoscroll 60s linear infinite; /* Remis à "infinite" pour boucler */
            animation-play-state: running;
            padding-bottom: 20px; /* Add space at the bottom before repeating */
        }
        
        .autoscroll-content:hover {
            animation-play-state: paused;
        }
        
        /* Objectifs sur la barre en haut */
        #objectives-panel {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            display: flex;
            gap: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .objective {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .objective-icon {
            color: #ffcc00;
            font-size: 14px;
        }
        
        .objective-text {
            white-space: nowrap;
        }
        
        /* 
        Organisation des panneaux :
        - Haut: Objectifs
        - Droite: Progression narrative 
        - À gauche milieu: Journal d'exploration
        - À gauche bas: Classement des explorateurs
        - En bas à droite: Panneau de vote
        - Centre haut (ajusté): Barre de progression
        - Centre bas: Affichage narratif
        */
        
        /* Hover effect pour rendre les panneaux plus lisibles au survol */
        #leaderboard-panel:hover, #story-history-panel:hover, #donation-panel:hover, #vote-panel:hover, #donor-wall:hover {
            opacity: 0.95;
            z-index: 950; /* Augmente le z-index au survol pour s'assurer qu'il est au-dessus des autres */
        }
        
        /* Style pour les titres des panneaux */
        #leaderboard-panel h3, #story-history-panel h3, #donor-wall h4 {
            color: #ffcc00;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        #details-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 950;
            background: rgba(0,0,0,0.7);
            color: #ffcc00;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid rgba(255, 204, 0, 0.3);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            display: none; /* Cacher le bouton des détails d'exploration */
        }
        
        #details-button:hover {
            background: rgba(50,50,0,0.7);
            border-color: rgba(255, 204, 0, 0.6);
        }
        
        /* Overlay d'authentification */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #33ff33;
            font-family: 'Courier New', monospace;
        }
        
        .auth-content {
            text-align: center;
            max-width: 500px;
            padding: 20px;
        }
        
        .auth-logo {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
        }
        
        .auth-message {
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        .auth-warning {
            color: #ff3333;
            margin-top: 20px;
            font-size: 12px;
            max-width: 80%;
            text-align: justify;
        }
        
        .donation-progress-container {
            width: 300px;
            margin: 0 auto;
        }
        
        .donation-label {
            color: #fff;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .donation-bar {
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #ff3366;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        #auth-donation-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff3366, #ff6699);
            transition: width 0.5s ease-in-out;
        }
        
        .auth-gauge {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .auth-gauge h3 {
            margin-top: 0;
            font-size: 14px;
            color: #ffcc00;
        }
        
        .tiktok-integration-notice {
            font-size: 12px;
            color: #ccc;
        }
        
        /* Notifications d'authentification */
        .auth-notification {
            position: fixed;
            right: -300px;
            top: 100px;
            background: linear-gradient(90deg, #330033, #5a0057);
            border-left: 3px solid #ff3366;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            padding: 15px;
            width: 250px;
            border-radius: 5px 0 0 5px;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .auth-notification.show {
            right: 0;
        }
        
        .auth-username {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .auth-amount {
            color: #ff3366;
            font-weight: bold;
            font-size: 18px;
        }
        
        /* Statut du système */
        .system-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #33ff33;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #ff3333;
        }
        
        .status-indicator.online {
            background-color: #33ff33;
        }
        
        /* Animation de pulsation pour la jauge */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .auth-gauge.pulse {
            animation: pulse 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
</head>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TikTok Horror Experience - Saison 1: Les Profondeurs</title>
    <link rel="stylesheet" href="responsive.css">
    <link rel="stylesheet" href="auth_gauge.css">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
        
        #loading { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: #000; 
            color: #fff; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            z-index: 1000;
        }
        
        #debug {
            position: fixed; 
            top: 10px; 
            left: 10px; 
            z-index: 10;
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px;
            border-radius: 5px;
        }
        
        #donation-panel {
            position: fixed;
            right: 10px;
            top: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 180px;
            font-size: 11px;
            display: none; /* Hide donation panel as requested */
        }
        
        #donation-panel h3 {
            margin-top: 0;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 40px; /* Déplacé plus bas pour éviter le chevauchement */
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            max-width: 400px;
            z-index: 900;
        }
        
        .progress-bar {
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            margin-bottom: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9900);
            width: 0%;
            transition: width 1s ease-in-out;
        }
        
        #story-milestone {
            position: fixed;
            top: 80px; /* Déplacé encore plus bas */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 12px;
            z-index: 900;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
            padding: 5px 10px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            width: 40%;
            max-width: 400px;
            line-height: 1.3;
            display: none; /* Caché par défaut, sera affiché dans le journal uniquement */
        }
        
        #donor-wall {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Aligné avec le journal d'exploration */
            max-height: 130px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Caché car remplacé par top100 */
        }
        
        #top100-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* En bas de l'écran, directement sous le journal */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px;
            max-height: 150px;
            overflow: hidden;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Caché car remplacé par leaderboard-panel */
        }
        
        #top100-panel h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 13px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .top100-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
            position: relative;
        }
        
        .top100-rank {
            width: 20px;
            text-align: center;
            color: #aaa;
        }
        
        .top100-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .top100-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #narrative-display {
            position: fixed;
            top: 50%; /* Centré verticalement */
            left: 50%;
            transform: translate(-50%, -50%); /* Centrage parfait */
            z-index: 950;
            color: white;
            text-align: center;
            width: 70%;
            max-width: 600px;
            text-shadow: 0 0 3px black, 0 0 5px black;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Fond plus opaque pour meilleure lisibilité */
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none; /* Pour éviter d'interférer avec les clics */
        }
        
        #narrative-display.visible {
            opacity: 0.95;
        }
        
        #clue-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 950;
            color: #ffcc00;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 3px solid #ffcc00;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease-out;
        }
        
        #clue-notification.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #event-counter {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            color: white;
            font-size: 120px;
            text-shadow: 0 0 20px red;
            opacity: 0;
            transition: all 0.3s ease-in-out;
            pointer-events: none;
        }
        
        #event-counter.visible {
            opacity: 1;
        }
        
        button, input { 
            margin: 5px 0; 
            display: block;
            border: none;
            background: #444;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #666;
        }
        
        #sim-donation {
            margin-top: 15px;
            width: 100%;
        }
        
        #vote-panel {
            position: fixed;
            right: 10px;
            bottom: 10px; /* En bas à droite */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 160px;
            font-size: 10px;
            display: none;
        }
        
        .vote-option {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .vote-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .vote-bar {
            height: 5px;
            width: 100%;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .vote-fill {
            height: 100%;
            background: linear-gradient(90deg, #77ccff, #4488ff);
            width: 30%;
        }
        
        /* Animation pour les effects */
        @keyframes pulse {
            0% { opacity: 0.2; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.2; transform: scale(0.95); }
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        #leaderboard-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* Repositionné en bas sous le journal */
            top: auto; /* Annule la position top précédente */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 200px;
            max-height: 145px; /* Hauteur réduite pour éviter le chevauchement (était à 150px) */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #leaderboard-panel h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #aaa;
            width: 20px;
            text-align: center;
        }
        
        .leaderboard-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .leaderboard-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #story-history-panel {
            position: fixed;
            left: 10px;
            bottom: 175px; /* Remonté plus haut pour éviter le chevauchement (était à 70px) */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Élargi pour mieux afficher les messages */
            max-height: 180px; /* Légèrement plus grand */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #story-history-panel h3 {
            margin-top: 0;
            margin-bottom: 3px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .history-item {
            margin-bottom: 4px;
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .history-item-milestone {
            background-color: rgba(255, 204, 0, 0.2);
            border-left: 2px solid #ffcc00;
        }
        
        .history-item-discovery {
            background-color: rgba(119, 204, 255, 0.2);
            border-left: 2px solid #77ccff;
        }
        
        .history-item-event {
            background-color: rgba(255, 102, 102, 0.2);
            border-left: 2px solid #ff6666;
        }
        
        .history-timestamp {
            color: #aaa;
            font-size: 8px;
            margin-bottom: 2px;
            font-style: italic;
        }
        
        /* Style pour réserver l'espace pour la caméra */
        .camera-space {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 100px;
            z-index: 800;
            /* Background commenté - juste pour visualiser l'espace réservé 
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            */
        }
        
        /* Assurons-nous que tous les panneaux ont une apparence cohérente */
        #leaderboard-panel, #story-history-panel, #vote-panel, #donor-wall {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.85; /* Légèrement transparent pour voir le bateau derrière */
        }
        
        /* Animation de défilement automatique pour les panneaux */
        @keyframes autoscroll {
            0% { transform: translateY(0); }
            45% { transform: translateY(calc(-100% + 100px)); }
            55% { transform: translateY(calc(-100% + 100px)); } /* Pause au bas pendant 10% de l'animation */
            57% { transform: translateY(0); } /* Retour très rapide au début (2% de l'animation) */
            100% { transform: translateY(0); } /* Pause au début avant de recommencer */
        }
        
        .autoscroll-container {
            height: 100%;
            overflow: hidden;
            position: relative;
            max-height: inherit;
        }
        
        .autoscroll-content {
            animation: autoscroll 60s linear infinite; /* Remis à "infinite" pour boucler */
            animation-play-state: running;
            padding-bottom: 20px; /* Add space at the bottom before repeating */
        }
        
        .autoscroll-content:hover {
            animation-play-state: paused;
        }
        
        /* Objectifs sur la barre en haut */
        #objectives-panel {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            display: flex;
            gap: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .objective {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .objective-icon {
            color: #ffcc00;
            font-size: 14px;
        }
        
        .objective-text {
            white-space: nowrap;
        }
        
        /* 
        Organisation des panneaux :
        - Haut: Objectifs
        - Droite: Progression narrative 
        - À gauche milieu: Journal d'exploration
        - À gauche bas: Classement des explorateurs
        - En bas à droite: Panneau de vote
        - Centre haut (ajusté): Barre de progression
        - Centre bas: Affichage narratif
        */
        
        /* Hover effect pour rendre les panneaux plus lisibles au survol */
        #leaderboard-panel:hover, #story-history-panel:hover, #donation-panel:hover, #vote-panel:hover, #donor-wall:hover {
            opacity: 0.95;
            z-index: 950; /* Augmente le z-index au survol pour s'assurer qu'il est au-dessus des autres */
        }
        
        /* Style pour les titres des panneaux */
        #leaderboard-panel h3, #story-history-panel h3, #donor-wall h4 {
            color: #ffcc00;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        #details-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 950;
            background: rgba(0,0,0,0.7);
            color: #ffcc00;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid rgba(255, 204, 0, 0.3);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            display: none; /* Cacher le bouton des détails d'exploration */
        }
        
        #details-button:hover {
            background: rgba(50,50,0,0.7);
            border-color: rgba(255, 204, 0, 0.6);
        }
        
        /* Overlay d'authentification */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #33ff33;
            font-family: 'Courier New', monospace;
        }
        
        .auth-content {
            text-align: center;
            max-width: 500px;
            padding: 20px;
        }
        
        .auth-logo {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
        }
        
        .auth-message {
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        .auth-warning {
            color: #ff3333;
            margin-top: 20px;
            font-size: 12px;
            max-width: 80%;
            text-align: justify;
        }
        
        .donation-progress-container {
            width: 300px;
            margin: 0 auto;
        }
        
        .donation-label {
            color: #fff;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .donation-bar {
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #ff3366;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        #auth-donation-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff3366, #ff6699);
            transition: width 0.5s ease-in-out;
        }
        
        .auth-gauge {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .auth-gauge h3 {
            margin-top: 0;
            font-size: 14px;
            color: #ffcc00;
        }
        
        .tiktok-integration-notice {
            font-size: 12px;
            color: #ccc;
        }
        
        /* Notifications d'authentification */
        .auth-notification {
            position: fixed;
            right: -300px;
            top: 100px;
            background: linear-gradient(90deg, #330033, #5a0057);
            border-left: 3px solid #ff3366;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            padding: 15px;
            width: 250px;
            border-radius: 5px 0 0 5px;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .auth-notification.show {
            right: 0;
        }
        
        .auth-username {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .auth-amount {
            color: #ff3366;
            font-weight: bold;
            font-size: 18px;
        }
        
        /* Statut du système */
        .system-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #33ff33;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #ff3333;
        }
        
        .status-indicator.online {
            background-color: #33ff33;
        }
        
        /* Animation de pulsation pour la jauge */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .auth-gauge.pulse {
            animation: pulse 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
</head>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TikTok Horror Experience - Saison 1: Les Profondeurs</title>
    <link rel="stylesheet" href="responsive.css">
    <link rel="stylesheet" href="auth_gauge.css">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
        
        #loading { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: #000; 
            color: #fff; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            z-index: 1000;
        }
        
        #debug {
            position: fixed; 
            top: 10px; 
            left: 10px; 
            z-index: 10;
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px;
            border-radius: 5px;
        }
        
        #donation-panel {
            position: fixed;
            right: 10px;
            top: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 180px;
            font-size: 11px;
            display: none; /* Hide donation panel as requested */
        }
        
        #donation-panel h3 {
            margin-top: 0;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 40px; /* Déplacé plus bas pour éviter le chevauchement */
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            max-width: 400px;
            z-index: 900;
        }
        
        .progress-bar {
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            margin-bottom: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9900);
            width: 0%;
            transition: width 1s ease-in-out;
        }
        
        #story-milestone {
            position: fixed;
            top: 80px; /* Déplacé encore plus bas */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 12px;
            z-index: 900;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
            padding: 5px 10px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            width: 40%;
            max-width: 400px;
            line-height: 1.3;
            display: none; /* Caché par défaut, sera affiché dans le journal uniquement */
        }
        
        #donor-wall {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Aligné avec le journal d'exploration */
            max-height: 130px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Caché car remplacé par top100 */
        }
        
        #top100-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* En bas de l'écran, directement sous le journal */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px;
            max-height: 150px;
            overflow: hidden;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Caché car remplacé par leaderboard-panel */
        }
        
        #top100-panel h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 13px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .top100-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
            position: relative;
        }
        
        .top100-rank {
            width: 20px;
            text-align: center;
            color: #aaa;
        }
        
        .top100-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .top100-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #narrative-display {
            position: fixed;
            top: 50%; /* Centré verticalement */
            left: 50%;
            transform: translate(-50%, -50%); /* Centrage parfait */
            z-index: 950;
            color: white;
            text-align: center;
            width: 70%;
            max-width: 600px;
            text-shadow: 0 0 3px black, 0 0 5px black;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Fond plus opaque pour meilleure lisibilité */
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none; /* Pour éviter d'interférer avec les clics */
        }
        
        #narrative-display.visible {
            opacity: 0.95;
        }
        
        #clue-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 950;
            color: #ffcc00;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 3px solid #ffcc00;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease-out;
        }
        
        #clue-notification.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #event-counter {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            color: white;
            font-size: 120px;
            text-shadow: 0 0 20px red;
            opacity: 0;
            transition: all 0.3s ease-in-out;
            pointer-events: none;
        }
        
        #event-counter.visible {
            opacity: 1;
        }
        
        button, input { 
            margin: 5px 0; 
            display: block;
            border: none;
            background: #444;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #666;
        }
        
        #sim-donation {
            margin-top: 15px;
            width: 100%;
        }
        
        #vote-panel {
            position: fixed;
            right: 10px;
            bottom: 10px; /* En bas à droite */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 160px;
            font-size: 10px;
            display: none;
        }
        
        .vote-option {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .vote-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .vote-bar {
            height: 5px;
            width: 100%;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .vote-fill {
            height: 100%;
            background: linear-gradient(90deg, #77ccff, #4488ff);
            width: 30%;
        }
        
        /* Animation pour les effects */
        @keyframes pulse {
            0% { opacity: 0.2; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.2; transform: scale(0.95); }
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        #leaderboard-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* Repositionné en bas sous le journal */
            top: auto; /* Annule la position top précédente */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 200px;
            max-height: 145px; /* Hauteur réduite pour éviter le chevauchement (était à 150px) */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #leaderboard-panel h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #aaa;
            width: 20px;
            text-align: center;
        }
        
        .leaderboard-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .leaderboard-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #story-history-panel {
            position: fixed;
            left: 10px;
            bottom: 175px; /* Remonté plus haut pour éviter le chevauchement (était à 70px) */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Élargi pour mieux afficher les messages */
            max-height: 180px; /* Légèrement plus grand */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #story-history-panel h3 {
            margin-top: 0;
            margin-bottom: 3px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .history-item {
            margin-bottom: 4px;
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .history-item-milestone {
            background-color: rgba(255, 204, 0, 0.2);
            border-left: 2px solid #ffcc00;
        }
        
        .history-item-discovery {
            background-color: rgba(119, 204, 255, 0.2);
            border-left: 2px solid #77ccff;
        }
        
        .history-item-event {
            background-color: rgba(255, 102, 102, 0.2);
            border-left: 2px solid #ff6666;
        }
        
        .history-timestamp {
            color: #aaa;
            font-size: 8px;
            margin-bottom: 2px;
            font-style: italic;
        }
        
        /* Style pour réserver l'espace pour la caméra */
        .camera-space {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 100px;
            z-index: 800;
            /* Background commenté - juste pour visualiser l'espace réservé 
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            */
        }
        
        /* Assurons-nous que tous les panneaux ont une apparence cohérente */
        #leaderboard-panel, #story-history-panel, #vote-panel, #donor-wall {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.85; /* Légèrement transparent pour voir le bateau derrière */
        }
        
        /* Animation de défilement automatique pour les panneaux */
        @keyframes autoscroll {
            0% { transform: translateY(0); }
            45% { transform: translateY(calc(-100% + 100px)); }
            55% { transform: translateY(calc(-100% + 100px)); } /* Pause au bas pendant 10% de l'animation */
            57% { transform: translateY(0); } /* Retour très rapide au début (2% de l'animation) */
            100% { transform: translateY(0); } /* Pause au début avant de recommencer */
        }
        
        .autoscroll-container {
            height: 100%;
            overflow: hidden;
            position: relative;
            max-height: inherit;
        }
        
        .autoscroll-content {
            animation: autoscroll 60s linear infinite; /* Remis à "infinite" pour boucler */
            animation-play-state: running;
            padding-bottom: 20px; /* Add space at the bottom before repeating */
        }
        
        .autoscroll-content:hover {
            animation-play-state: paused;
        }
        
        /* Objectifs sur la barre en haut */
        #objectives-panel {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            display: flex;
            gap: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .objective {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .objective-icon {
            color: #ffcc00;
            font-size: 14px;
        }
        
        .objective-text {
            white-space: nowrap;
        }
        
        /* 
        Organisation des panneaux :
        - Haut: Objectifs
        - Droite: Progression narrative 
        - À gauche milieu: Journal d'exploration
        - À gauche bas: Classement des explorateurs
        - En bas à droite: Panneau de vote
        - Centre haut (ajusté): Barre de progression
        - Centre bas: Affichage narratif
        */
        
        /* Hover effect pour rendre les panneaux plus lisibles au survol */
        #leaderboard-panel:hover, #story-history-panel:hover, #donation-panel:hover, #vote-panel:hover, #donor-wall:hover {
            opacity: 0.95;
            z-index: 950; /* Augmente le z-index au survol pour s'assurer qu'il est au-dessus des autres */
        }
        
        /* Style pour les titres des panneaux */
        #leaderboard-panel h3, #story-history-panel h3, #donor-wall h4 {
            color: #ffcc00;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        #details-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 950;
            background: rgba(0,0,0,0.7);
            color: #ffcc00;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid rgba(255, 204, 0, 0.3);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            display: none; /* Cacher le bouton des détails d'exploration */
        }
        
        #details-button:hover {
            background: rgba(50,50,0,0.7);
            border-color: rgba(255, 204, 0, 0.6);
        }
        
        /* Overlay d'authentification */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #33ff33;
            font-family: 'Courier New', monospace;
        }
        
        .auth-content {
            text-align: center;
            max-width: 500px;
            padding: 20px;
        }
        
        .auth-logo {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
        }
        
        .auth-message {
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        .auth-warning {
            color: #ff3333;
            margin-top: 20px;
            font-size: 12px;
            max-width: 80%;
            text-align: justify;
        }
        
        .donation-progress-container {
            width: 300px;
            margin: 0 auto;
        }
        
        .donation-label {
            color: #fff;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .donation-bar {
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #ff3366;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        #auth-donation-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff3366, #ff6699);
            transition: width 0.5s ease-in-out;
        }
        
        .auth-gauge {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .auth-gauge h3 {
            margin-top: 0;
            font-size: 14px;
            color: #ffcc00;
        }
        
        .tiktok-integration-notice {
            font-size: 12px;
            color: #ccc;
        }
        
        /* Notifications d'authentification */
        .auth-notification {
            position: fixed;
            right: -300px;
            top: 100px;
            background: linear-gradient(90deg, #330033, #5a0057);
            border-left: 3px solid #ff3366;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            padding: 15px;
            width: 250px;
            border-radius: 5px 0 0 5px;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .auth-notification.show {
            right: 0;
        }
        
        .auth-username {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .auth-amount {
            color: #ff3366;
            font-weight: bold;
            font-size: 18px;
        }
        
        /* Statut du système */
        .system-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #33ff33;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #ff3333;
        }
        
        .status-indicator.online {
            background-color: #33ff33;
        }
        
        /* Animation de pulsation pour la jauge */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .auth-gauge.pulse {
            animation: pulse 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TikTok Horror Experience - Saison 1: Les Profondeurs</title>
    <link rel="stylesheet" href="responsive.css">
    <link rel="stylesheet" href="auth_gauge.css">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
        
        #loading { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: #000; 
            color: #fff; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            z-index: 1000;
        }
        
        #debug {
            position: fixed; 
            top: 10px; 
            left: 10px; 
            z-index: 10;
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px;
            border-radius: 5px;
        }
        
        #donation-panel {
            position: fixed;
            right: 10px;
            top: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 180px;
            font-size: 11px;
            display: none; /* Hide donation panel as requested */
        }
        
        #donation-panel h3 {
            margin-top: 0;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 40px; /* Déplacé plus bas pour éviter le chevauchement */
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            max-width: 400px;
            z-index: 900;
        }
        
        .progress-bar {
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            margin-bottom: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9900);
            width: 0%;
            transition: width 1s ease-in-out;
        }
        
        #story-milestone {
            position: fixed;
            top: 80px; /* Déplacé encore plus bas */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 12px;
            z-index: 900;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
            padding: 5px 10px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            width: 40%;
            max-width: 400px;
            line-height: 1.3;
            display: none; /* Caché par défaut, sera affiché dans le journal uniquement */
        }
        
        #donor-wall {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Aligné avec le journal d'exploration */
            max-height: 130px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Caché car remplacé par top100 */
        }
        
        #top100-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* En bas de l'écran, directement sous le journal */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px;
            max-height: 150px;
            overflow: hidden;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Caché car remplacé par leaderboard-panel */
        }
        
        #top100-panel h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 13px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .top100-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
            position: relative;
        }
        
        .top100-rank {
            width: 20px;
            text-align: center;
            color: #aaa;
        }
        
        .top100-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .top100-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #narrative-display {
            position: fixed;
            top: 50%; /* Centré verticalement */
            left: 50%;
            transform: translate(-50%, -50%); /* Centrage parfait */
            z-index: 950;
            color: white;
            text-align: center;
            width: 70%;
            max-width: 600px;
            text-shadow: 0 0 3px black, 0 0 5px black;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Fond plus opaque pour meilleure lisibilité */
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none; /* Pour éviter d'interférer avec les clics */
        }
        
        #narrative-display.visible {
            opacity: 0.95;
        }
        
        #clue-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 950;
            color: #ffcc00;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 3px solid #ffcc00;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease-out;
        }
        
        #clue-notification.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #event-counter {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            color: white;
            font-size: 120px;
            text-shadow: 0 0 20px red;
            opacity: 0;
            transition: all 0.3s ease-in-out;
            pointer-events: none;
        }
        
        #event-counter.visible {
            opacity: 1;
        }
        
        button, input { 
            margin: 5px 0; 
            display: block;
            border: none;
            background: #444;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #666;
        }
        
        #sim-donation {
            margin-top: 15px;
            width: 100%;
        }
        
        #vote-panel {
            position: fixed;
            right: 10px;
            bottom: 10px; /* En bas à droite */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 160px;
            font-size: 10px;
            display: none;
        }
        
        .vote-option {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .vote-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .vote-bar {
            height: 5px;
            width: 100%;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .vote-fill {
            height: 100%;
            background: linear-gradient(90deg, #77ccff, #4488ff);
            width: 30%;
        }
        
        /* Animation pour les effects */
        @keyframes pulse {
            0% { opacity: 0.2; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.2; transform: scale(0.95); }
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        #leaderboard-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* Repositionné en bas sous le journal */
            top: auto; /* Annule la position top précédente */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 200px;
            max-height: 145px; /* Hauteur réduite pour éviter le chevauchement (était à 150px) */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #leaderboard-panel h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #aaa;
            width: 20px;
            text-align: center;
        }
        
        .leaderboard-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .leaderboard-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #story-history-panel {
            position: fixed;
            left: 10px;
            bottom: 175px; /* Remonté plus haut pour éviter le chevauchement (était à 70px) */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Élargi pour mieux afficher les messages */
            max-height: 180px; /* Légèrement plus grand */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #story-history-panel h3 {
            margin-top: 0;
            margin-bottom: 3px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .history-item {
            margin-bottom: 4px;
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .history-item-milestone {
            background-color: rgba(255, 204, 0, 0.2);
            border-left: 2px solid #ffcc00;
        }
        
        .history-item-discovery {
            background-color: rgba(119, 204, 255, 0.2);
            border-left: 2px solid #77ccff;
        }
        
        .history-item-event {
            background-color: rgba(255, 102, 102, 0.2);
            border-left: 2px solid #ff6666;
        }
        
        .history-timestamp {
            color: #aaa;
            font-size: 8px;
            margin-bottom: 2px;
            font-style: italic;
        }
        
        /* Style pour réserver l'espace pour la caméra */
        .camera-space {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 100px;
            z-index: 800;
            /* Background commenté - juste pour visualiser l'espace réservé 
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            */
        }
        
        /* Assurons-nous que tous les panneaux ont une apparence cohérente */
        #leaderboard-panel, #story-history-panel, #vote-panel, #donor-wall {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.85; /* Légèrement transparent pour voir le bateau derrière */
        }
        
        /* Animation de défilement automatique pour les panneaux */
        @keyframes autoscroll {
            0% { transform: translateY(0); }
            45% { transform: translateY(calc(-100% + 100px)); }
            55% { transform: translateY(calc(-100% + 100px)); } /* Pause au bas pendant 10% de l'animation */
            57% { transform: translateY(0); } /* Retour très rapide au début (2% de l'animation) */
            100% { transform: translateY(0); } /* Pause au début avant de recommencer */
        }
        
        .autoscroll-container {
            height: 100%;
            overflow: hidden;
            position: relative;
            max-height: inherit;
        }
        
        .autoscroll-content {
            animation: autoscroll 60s linear infinite; /* Remis à "infinite" pour boucler */
            animation-play-state: running;
            padding-bottom: 20px; /* Add space at the bottom before repeating */
        }
        
        .autoscroll-content:hover {
            animation-play-state: paused;
        }
        
        /* Objectifs sur la barre en haut */
        #objectives-panel {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            display: flex;
            gap: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .objective {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .objective-icon {
            color: #ffcc00;
            font-size: 14px;
        }
        
        .objective-text {
            white-space: nowrap;
        }
        
        /* 
        Organisation des panneaux :
        - Haut: Objectifs
        - Droite: Progression narrative 
        - À gauche milieu: Journal d'exploration
        - À gauche bas: Classement des explorateurs
        - En bas à droite: Panneau de vote
        - Centre haut (ajusté): Barre de progression
        - Centre bas: Affichage narratif
        */
        
        /* Hover effect pour rendre les panneaux plus lisibles au survol */
        #leaderboard-panel:hover, #story-history-panel:hover, #donation-panel:hover, #vote-panel:hover, #donor-wall:hover {
            opacity: 0.95;
            z-index: 950; /* Augmente le z-index au survol pour s'assurer qu'il est au-dessus des autres */
        }
        
        /* Style pour les titres des panneaux */
        #leaderboard-panel h3, #story-history-panel h3, #donor-wall h4 {
            color: #ffcc00;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        #details-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 950;
            background: rgba(0,0,0,0.7);
            color: #ffcc00;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid rgba(255, 204, 0, 0.3);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            display: none; /* Cacher le bouton des détails d'exploration */
        }
        
        #details-button:hover {
            background: rgba(50,50,0,0.7);
            border-color: rgba(255, 204, 0, 0.6);
        }
        
        /* Overlay d'authentification */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #33ff33;
            font-family: 'Courier New', monospace;
        }
        
        .auth-content {
            text-align: center;
            max-width: 500px;
            padding: 20px;
        }
        
        .auth-logo {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
        }
        
        .auth-message {
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        .auth-warning {
            color: #ff3333;
            margin-top: 20px;
            font-size: 12px;
            max-width: 80%;
            text-align: justify;
        }
        
        .donation-progress-container {
            width: 300px;
            margin: 0 auto;
        }
        
        .donation-label {
            color: #fff;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .donation-bar {
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #ff3366;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        #auth-donation-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff3366, #ff6699);
            transition: width 0.5s ease-in-out;
        }
        
        .auth-gauge {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .auth-gauge h3 {
            margin-top: 0;
            font-size: 14px;
            color: #ffcc00;
        }
        
        .tiktok-integration-notice {
            font-size: 12px;
            color: #ccc;
        }
        
        /* Notifications d'authentification */
        .auth-notification {
            position: fixed;
            right: -300px;
            top: 100px;
            background: linear-gradient(90deg, #330033, #5a0057);
            border-left: 3px solid #ff3366;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            padding: 15px;
            width: 250px;
            border-radius: 5px 0 0 5px;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .auth-notification.show {
            right: 0;
        }
        
        .auth-username {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .auth-amount {
            color: #ff3366;
            font-weight: bold;
            font-size: 18px;
        }
        
        /* Statut du système */
        .system-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #33ff33;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #ff3333;
        }
        
        .status-indicator.online {
            background-color: #33ff33;
        }
        
        /* Animation de pulsation pour la jauge */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .auth-gauge.pulse {
            animation: pulse 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
    <!-- Inclure les fichiers externes pour la gestion de l'authentification -->
    <script src="auth_gauge.js"></script>
    <script>
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TikTok Horror Experience - Saison 1: Les Profondeurs</title>
    <link rel="stylesheet" href="responsive.css">
    <link rel="stylesheet" href="auth_gauge.css">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
        
        #loading { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: #000; 
            color: #fff; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            z-index: 1000;
        }
        
        #debug {
            position: fixed; 
            top: 10px; 
            left: 10px; 
            z-index: 10;
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px;
            border-radius: 5px;
        }
        
        #donation-panel {
            position: fixed;
            right: 10px;
            top: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 180px;
            font-size: 11px;
            display: none; /* Hide donation panel as requested */
        }
        
        #donation-panel h3 {
            margin-top: 0;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 40px; /* Déplacé plus bas pour éviter le chevauchement */
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            max-width: 400px;
            z-index: 900;
        }
        
        .progress-bar {
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            margin-bottom: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9900);
            width: 0%;
            transition: width 1s ease-in-out;
        }
        
        #story-milestone {
            position: fixed;
            top: 80px; /* Déplacé encore plus bas */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 12px;
            z-index: 900;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
            padding: 5px 10px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            width: 40%;
            max-width: 400px;
            line-height: 1.3;
            display: none; /* Caché par défaut, sera affiché dans le journal uniquement */
        }
        
        #donor-wall {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Aligné avec le journal d'exploration */
            max-height: 130px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Caché car remplacé par top100 */
        }
        
        #top100-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* En bas de l'écran, directement sous le journal */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px;
            max-height: 150px;
            overflow: hidden;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Caché car remplacé par leaderboard-panel */
        }
        
        #top100-panel h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 13px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .top100-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
            position: relative;
        }
        
        .top100-rank {
            width: 20px;
            text-align: center;
            color: #aaa;
        }
        
        .top100-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .top100-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #narrative-display {
            position: fixed;
            top: 50%; /* Centré verticalement */
            left: 50%;
            transform: translate(-50%, -50%); /* Centrage parfait */
            z-index: 950;
            color: white;
            text-align: center;
            width: 70%;
            max-width: 600px;
            text-shadow: 0 0 3px black, 0 0 5px black;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Fond plus opaque pour meilleure lisibilité */
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none; /* Pour éviter d'interférer avec les clics */
        }
        
        #narrative-display.visible {
            opacity: 0.95;
        }
        
        #clue-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 950;
            color: #ffcc00;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 3px solid #ffcc00;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease-out;
        }
        
        #clue-notification.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #event-counter {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            color: white;
            font-size: 120px;
            text-shadow: 0 0 20px red;
            opacity: 0;
            transition: all 0.3s ease-in-out;
            pointer-events: none;
        }
        
        #event-counter.visible {
            opacity: 1;
        }
        
        button, input { 
            margin: 5px 0; 
            display: block;
            border: none;
            background: #444;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #666;
        }
        
        #sim-donation {
            margin-top: 15px;
            width: 100%;
        }
        
        #vote-panel {
            position: fixed;
            right: 10px;
            bottom: 10px; /* En bas à droite */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 160px;
            font-size: 10px;
            display: none;
        }
        
        .vote-option {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .vote-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .vote-bar {
            height: 5px;
            width: 100%;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .vote-fill {
            height: 100%;
            background: linear-gradient(90deg, #77ccff, #4488ff);
            width: 30%;
        }
        
        /* Animation pour les effects */
        @keyframes pulse {
            0% { opacity: 0.2; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.2; transform: scale(0.95); }
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        #leaderboard-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* Repositionné en bas sous le journal */
            top: auto; /* Annule la position top précédente */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 200px;
            max-height: 145px; /* Hauteur réduite pour éviter le chevauchement (était à 150px) */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #leaderboard-panel h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #aaa;
            width: 20px;
            text-align: center;
        }
        
        .leaderboard-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .leaderboard-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #story-history-panel {
            position: fixed;
            left: 10px;
            bottom: 175px; /* Remonté plus haut pour éviter le chevauchement (était à 70px) */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Élargi pour mieux afficher les messages */
            max-height: 180px; /* Légèrement plus grand */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #story-history-panel h3 {
            margin-top: 0;
            margin-bottom: 3px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .history-item {
            margin-bottom: 4px;
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .history-item-milestone {
            background-color: rgba(255, 204, 0, 0.2);
            border-left: 2px solid #ffcc00;
        }
        
        .history-item-discovery {
            background-color: rgba(119, 204, 255, 0.2);
            border-left: 2px solid #77ccff;
        }
        
        .history-item-event {
            background-color: rgba(255, 102, 102, 0.2);
            border-left: 2px solid #ff6666;
        }
        
        .history-timestamp {
            color: #aaa;
            font-size: 8px;
            margin-bottom: 2px;
            font-style: italic;
        }
        
        /* Style pour réserver l'espace pour la caméra */
        .camera-space {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 100px;
            z-index: 800;
            /* Background commenté - juste pour visualiser l'espace réservé 
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            */
        }
        
        /* Assurons-nous que tous les panneaux ont une apparence cohérente */
        #leaderboard-panel, #story-history-panel, #vote-panel, #donor-wall {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.85; /* Légèrement transparent pour voir le bateau derrière */
        }
        
        /* Animation de défilement automatique pour les panneaux */
        @keyframes autoscroll {
            0% { transform: translateY(0); }
            45% { transform: translateY(calc(-100% + 100px)); }
            55% { transform: translateY(calc(-100% + 100px)); } /* Pause au bas pendant 10% de l'animation */
            57% { transform: translateY(0); } /* Retour très rapide au début (2% de l'animation) */
            100% { transform: translateY(0); } /* Pause au début avant de recommencer */
        }
        
        .autoscroll-container {
            height: 100%;
            overflow: hidden;
            position: relative;
            max-height: inherit;
        }
        
        .autoscroll-content {
            animation: autoscroll 60s linear infinite; /* Remis à "infinite" pour boucler */
            animation-play-state: running;
            padding-bottom: 20px; /* Add space at the bottom before repeating */
        }
        
        .autoscroll-content:hover {
            animation-play-state: paused;
        }
        
        /* Objectifs sur la barre en haut */
        #objectives-panel {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            display: flex;
            gap: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .objective {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .objective-icon {
            color: #ffcc00;
            font-size: 14px;
        }
        
        .objective-text {
            white-space: nowrap;
        }
        
        /* 
        Organisation des panneaux :
        - Haut: Objectifs
        - Droite: Progression narrative 
        - À gauche milieu: Journal d'exploration
        - À gauche bas: Classement des explorateurs
        - En bas à droite: Panneau de vote
        - Centre haut (ajusté): Barre de progression
        - Centre bas: Affichage narratif
        */
        
        /* Hover effect pour rendre les panneaux plus lisibles au survol */
        #leaderboard-panel:hover, #story-history-panel:hover, #donation-panel:hover, #vote-panel:hover, #donor-wall:hover {
            opacity: 0.95;
            z-index: 950; /* Augmente le z-index au survol pour s'assurer qu'il est au-dessus des autres */
        }
        
        /* Style pour les titres des panneaux */
        #leaderboard-panel h3, #story-history-panel h3, #donor-wall h4 {
            color: #ffcc00;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        #details-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 950;
            background: rgba(0,0,0,0.7);
            color: #ffcc00;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid rgba(255, 204, 0, 0.3);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            display: none; /* Cacher le bouton des détails d'exploration */
        }
        
        #details-button:hover {
            background: rgba(50,50,0,0.7);
            border-color: rgba(255, 204, 0, 0.6);
        }
        
        /* Overlay d'authentification */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #33ff33;
            font-family: 'Courier New', monospace;
        }
        
        .auth-content {
            text-align: center;
            max-width: 500px;
            padding: 20px;
        }
        
        .auth-logo {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
        }
        
        .auth-message {
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        .auth-warning {
            color: #ff3333;
            margin-top: 20px;
            font-size: 12px;
            max-width: 80%;
            text-align: justify;
        }
        
        .donation-progress-container {
            width: 300px;
            margin: 0 auto;
        }
        
        .donation-label {
            color: #fff;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .donation-bar {
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #ff3366;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        #auth-donation-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff3366, #ff6699);
            transition: width 0.5s ease-in-out;
        }
        
        .auth-gauge {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .auth-gauge h3 {
            margin-top: 0;
            font-size: 14px;
            color: #ffcc00;
        }
        
        .tiktok-integration-notice {
            font-size: 12px;
            color: #ccc;
        }
        
        /* Notifications d'authentification */
        .auth-notification {
            position: fixed;
            right: -300px;
            top: 100px;
            background: linear-gradient(90deg, #330033, #5a0057);
            border-left: 3px solid #ff3366;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            padding: 15px;
            width: 250px;
            border-radius: 5px 0 0 5px;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .auth-notification.show {
            right: 0;
        }
        
        .auth-username {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .auth-amount {
            color: #ff3366;
            font-weight: bold;
            font-size: 18px;
        }
        
        /* Statut du système */
        .system-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #33ff33;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #ff3333;
        }
        
        .status-indicator.online {
            background-color: #33ff33;
        }
        
        /* Animation de pulsation pour la jauge */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .auth-gauge.pulse {
            animation: pulse 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
    <!-- Inclure les fichiers externes pour la gestion de l'authentification -->
    <script src="auth_gauge.js"></script>
    <script>
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TikTok Horror Experience - Saison 1: Les Profondeurs</title>
    <link rel="stylesheet" href="responsive.css">
    <link rel="stylesheet" href="auth_gauge.css">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
        
        #loading { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: #000; 
            color: #fff; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            z-index: 1000;
        }
        
        #debug {
            position: fixed; 
            top: 10px; 
            left: 10px; 
            z-index: 10;
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px;
            border-radius: 5px;
        }
        
        #donation-panel {
            position: fixed;
            right: 10px;
            top: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 180px;
            font-size: 11px;
            display: none; /* Hide donation panel as requested */
        }
        
        #donation-panel h3 {
            margin-top: 0;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 40px; /* Déplacé plus bas pour éviter le chevauchement */
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            max-width: 400px;
            z-index: 900;
        }
        
        .progress-bar {
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            margin-bottom: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9900);
            width: 0%;
            transition: width 1s ease-in-out;
        }
        
        #story-milestone {
            position: fixed;
            top: 80px; /* Déplacé encore plus bas */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 12px;
            z-index: 900;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
            padding: 5px 10px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            width: 40%;
            max-width: 400px;
            line-height: 1.3;
            display: none; /* Caché par défaut, sera affiché dans le journal uniquement */
        }
        
        #donor-wall {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Aligné avec le journal d'exploration */
            max-height: 130px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Caché car remplacé par top100 */
        }
        
        #top100-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* En bas de l'écran, directement sous le journal */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px;
            max-height: 150px;
            overflow: hidden;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Caché car remplacé par leaderboard-panel */
        }
        
        #top100-panel h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 13px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .top100-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
            position: relative;
        }
        
        .top100-rank {
            width: 20px;
            text-align: center;
            color: #aaa;
        }
        
        .top100-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .top100-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #narrative-display {
            position: fixed;
            top: 50%; /* Centré verticalement */
            left: 50%;
            transform: translate(-50%, -50%); /* Centrage parfait */
            z-index: 950;
            color: white;
            text-align: center;
            width: 70%;
            max-width: 600px;
            text-shadow: 0 0 3px black, 0 0 5px black;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Fond plus opaque pour meilleure lisibilité */
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none; /* Pour éviter d'interférer avec les clics */
        }
        
        #narrative-display.visible {
            opacity: 0.95;
        }
        
        #clue-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 950;
            color: #ffcc00;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 3px solid #ffcc00;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease-out;
        }
        
        #clue-notification.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #event-counter {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            color: white;
            font-size: 120px;
            text-shadow: 0 0 20px red;
            opacity: 0;
            transition: all 0.3s ease-in-out;
            pointer-events: none;
        }
        
        #event-counter.visible {
            opacity: 1;
        }
        
        button, input { 
            margin: 5px 0; 
            display: block;
            border: none;
            background: #444;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #666;
        }
        
        #sim-donation {
            margin-top: 15px;
            width: 100%;
        }
        
        #vote-panel {
            position: fixed;
            right: 10px;
            bottom: 10px; /* En bas à droite */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 160px;
            font-size: 10px;
            display: none;
        }
        
        .vote-option {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .vote-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .vote-bar {
            height: 5px;
            width: 100%;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .vote-fill {
            height: 100%;
            background: linear-gradient(90deg, #77ccff, #4488ff);
            width: 30%;
        }
        
        /* Animation pour les effects */
        @keyframes pulse {
            0% { opacity: 0.2; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.2; transform: scale(0.95); }
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        #leaderboard-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* Repositionné en bas sous le journal */
            top: auto; /* Annule la position top précédente */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 200px;
            max-height: 145px; /* Hauteur réduite pour éviter le chevauchement (était à 150px) */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #leaderboard-panel h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #aaa;
            width: 20px;
            text-align: center;
        }
        
        .leaderboard-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .leaderboard-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #story-history-panel {
            position: fixed;
            left: 10px;
            bottom: 175px; /* Remonté plus haut pour éviter le chevauchement (était à 70px) */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Élargi pour mieux afficher les messages */
            max-height: 180px; /* Légèrement plus grand */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #story-history-panel h3 {
            margin-top: 0;
            margin-bottom: 3px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .history-item {
            margin-bottom: 4px;
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .history-item-milestone {
            background-color: rgba(255, 204, 0, 0.2);
            border-left: 2px solid #ffcc00;
        }
        
        .history-item-discovery {
            background-color: rgba(119, 204, 255, 0.2);
            border-left: 2px solid #77ccff;
        }
        
        .history-item-event {
            background-color: rgba(255, 102, 102, 0.2);
            border-left: 2px solid #ff6666;
        }
        
        .history-timestamp {
            color: #aaa;
            font-size: 8px;
            margin-bottom: 2px;
            font-style: italic;
        }
        
        /* Style pour réserver l'espace pour la caméra */
        .camera-space {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 100px;
            z-index: 800;
            /* Background commenté - juste pour visualiser l'espace réservé 
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            */
        }
        
        /* Assurons-nous que tous les panneaux ont une apparence cohérente */
        #leaderboard-panel, #story-history-panel, #vote-panel, #donor-wall {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.85; /* Légèrement transparent pour voir le bateau derrière */
        }
        
        /* Animation de défilement automatique pour les panneaux */
        @keyframes autoscroll {
            0% { transform: translateY(0); }
            45% { transform: translateY(calc(-100% + 100px)); }
            55% { transform: translateY(calc(-100% + 100px)); } /* Pause au bas pendant 10% de l'animation */
            57% { transform: translateY(0); } /* Retour très rapide au début (2% de l'animation) */
            100% { transform: translateY(0); } /* Pause au début avant de recommencer */
        }
        
        .autoscroll-container {
            height: 100%;
            overflow: hidden;
            position: relative;
            max-height: inherit;
        }
        
        .autoscroll-content {
            animation: autoscroll 60s linear infinite; /* Remis à "infinite" pour boucler */
            animation-play-state: running;
            padding-bottom: 20px; /* Add space at the bottom before repeating */
        }
        
        .autoscroll-content:hover {
            animation-play-state: paused;
        }
        
        /* Objectifs sur la barre en haut */
        #objectives-panel {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            display: flex;
            gap: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .objective {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .objective-icon {
            color: #ffcc00;
            font-size: 14px;
        }
        
        .objective-text {
            white-space: nowrap;
        }
        
        /* 
        Organisation des panneaux :
        - Haut: Objectifs
        - Droite: Progression narrative 
        - À gauche milieu: Journal d'exploration
        - À gauche bas: Classement des explorateurs
        - En bas à droite: Panneau de vote
        - Centre haut (ajusté): Barre de progression
        - Centre bas: Affichage narratif
        */
        
        /* Hover effect pour rendre les panneaux plus lisibles au survol */
        #leaderboard-panel:hover, #story-history-panel:hover, #donation-panel:hover, #vote-panel:hover, #donor-wall:hover {
            opacity: 0.95;
            z-index: 950; /* Augmente le z-index au survol pour s'assurer qu'il est au-dessus des autres */
        }
        
        /* Style pour les titres des panneaux */
        #leaderboard-panel h3, #story-history-panel h3, #donor-wall h4 {
            color: #ffcc00;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        #details-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 950;
            background: rgba(0,0,0,0.7);
            color: #ffcc00;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid rgba(255, 204, 0, 0.3);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            display: none; /* Cacher le bouton des détails d'exploration */
        }
        
        #details-button:hover {
            background: rgba(50,50,0,0.7);
            border-color: rgba(255, 204, 0, 0.6);
        }
        
        /* Overlay d'authentification */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #33ff33;
            font-family: 'Courier New', monospace;
        }
        
        .auth-content {
            text-align: center;
            max-width: 500px;
            padding: 20px;
        }
        
        .auth-logo {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
        }
        
        .auth-message {
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        .auth-warning {
            color: #ff3333;
            margin-top: 20px;
            font-size: 12px;
            max-width: 80%;
            text-align: justify;
        }
        
        .donation-progress-container {
            width: 300px;
            margin: 0 auto;
        }
        
        .donation-label {
            color: #fff;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .donation-bar {
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #ff3366;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        #auth-donation-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff3366, #ff6699);
            transition: width 0.5s ease-in-out;
        }
        
        .auth-gauge {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .auth-gauge h3 {
            margin-top: 0;
            font-size: 14px;
            color: #ffcc00;
        }
        
        .tiktok-integration-notice {
            font-size: 12px;
            color: #ccc;
        }
        
        /* Notifications d'authentification */
        .auth-notification {
            position: fixed;
            right: -300px;
            top: 100px;
            background: linear-gradient(90deg, #330033, #5a0057);
            border-left: 3px solid #ff3366;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            padding: 15px;
            width: 250px;
            border-radius: 5px 0 0 5px;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .auth-notification.show {
            right: 0;
        }
        
        .auth-username {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .auth-amount {
            color: #ff3366;
            font-weight: bold;
            font-size: 18px;
        }
        
        /* Statut du système */
        .system-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #33ff33;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #ff3333;
        }
        
        .status-indicator.online {
            background-color: #33ff33;
        }
        
        /* Animation de pulsation pour la jauge */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .auth-gauge.pulse {
            animation: pulse 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
    <!-- Inclure les fichiers externes pour la gestion de l'authentification -->
    <script src="auth_gauge.js"></script>
    <script>
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TikTok Horror Experience - Saison 1: Les Profondeurs</title>
    <link rel="stylesheet" href="responsive.css">
    <link rel="stylesheet" href="auth_gauge.css">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
        
        #loading { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: #000; 
            color: #fff; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            z-index: 1000;
        }
        
        #debug {
            position: fixed; 
            top: 10px; 
            left: 10px; 
            z-index: 10;
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px;
            border-radius: 5px;
        }
        
        #donation-panel {
            position: fixed;
            right: 10px;
            top: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 180px;
            font-size: 11px;
            display: none; /* Hide donation panel as requested */
        }
        
        #donation-panel h3 {
            margin-top: 0;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 40px; /* Déplacé plus bas pour éviter le chevauchement */
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            max-width: 400px;
            z-index: 900;
        }
        
        .progress-bar {
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            margin-bottom: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9900);
            width: 0%;
            transition: width 1s ease-in-out;
        }
        
        #story-milestone {
            position: fixed;
            top: 80px; /* Déplacé encore plus bas */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 12px;
            z-index: 900;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
            padding: 5px 10px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            width: 40%;
            max-width: 400px;
            line-height: 1.3;
            display: none; /* Caché par défaut, sera affiché dans le journal uniquement */
        }
        
        #donor-wall {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Aligné avec le journal d'exploration */
            max-height: 130px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Caché car remplacé par top100 */
        }
        
        #top100-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* En bas de l'écran, directement sous le journal */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px;
            max-height: 150px;
            overflow: hidden;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Caché car remplacé par leaderboard-panel */
        }
        
        #top100-panel h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 13px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .top100-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
            position: relative;
        }
        
        .top100-rank {
            width: 20px;
            text-align: center;
            color: #aaa;
        }
        
        .top100-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .top100-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #narrative-display {
            position: fixed;
            top: 50%; /* Centré verticalement */
            left: 50%;
            transform: translate(-50%, -50%); /* Centrage parfait */
            z-index: 950;
            color: white;
            text-align: center;
            width: 70%;
            max-width: 600px;
            text-shadow: 0 0 3px black, 0 0 5px black;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Fond plus opaque pour meilleure lisibilité */
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none; /* Pour éviter d'interférer avec les clics */
        }
        
        #narrative-display.visible {
            opacity: 0.95;
        }
        
        #clue-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 950;
            color: #ffcc00;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 3px solid #ffcc00;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease-out;
        }
        
        #clue-notification.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #event-counter {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            color: white;
            font-size: 120px;
            text-shadow: 0 0 20px red;
            opacity: 0;
            transition: all 0.3s ease-in-out;
            pointer-events: none;
        }
        
        #event-counter.visible {
            opacity: 1;
        }
        
        button, input { 
            margin: 5px 0; 
            display: block;
            border: none;
            background: #444;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #666;
        }
        
        #sim-donation {
            margin-top: 15px;
            width: 100%;
        }
        
        #vote-panel {
            position: fixed;
            right: 10px;
            bottom: 10px; /* En bas à droite */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 160px;
            font-size: 10px;
            display: none;
        }
        
        .vote-option {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .vote-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .vote-bar {
            height: 5px;
            width: 100%;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .vote-fill {
            height: 100%;
            background: linear-gradient(90deg, #77ccff, #4488ff);
            width: 30%;
        }
        
        /* Animation pour les effects */
        @keyframes pulse {
            0% { opacity: 0.2; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.2; transform: scale(0.95); }
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        #leaderboard-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* Repositionné en bas sous le journal */
            top: auto; /* Annule la position top précédente */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 200px;
            max-height: 145px; /* Hauteur réduite pour éviter le chevauchement (était à 150px) */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #leaderboard-panel h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #aaa;
            width: 20px;
            text-align: center;
        }
        
        .leaderboard-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .leaderboard-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #story-history-panel {
            position: fixed;
            left: 10px;
            bottom: 175px; /* Remonté plus haut pour éviter le chevauchement (était à 70px) */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Élargi pour mieux afficher les messages */
            max-height: 180px; /* Légèrement plus grand */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #story-history-panel h3 {
            margin-top: 0;
            margin-bottom: 3px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .history-item {
            margin-bottom: 4px;
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .history-item-milestone {
            background-color: rgba(255, 204, 0, 0.2);
            border-left: 2px solid #ffcc00;
        }
        
        .history-item-discovery {
            background-color: rgba(119, 204, 255, 0.2);
            border-left: 2px solid #77ccff;
        }
        
        .history-item-event {
            background-color: rgba(255, 102, 102, 0.2);
            border-left: 2px solid #ff6666;
        }
        
        .history-timestamp {
            color: #aaa;
            font-size: 8px;
            margin-bottom: 2px;
            font-style: italic;
        }
        
        /* Style pour réserver l'espace pour la caméra */
        .camera-space {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 100px;
            z-index: 800;
            /* Background commenté - juste pour visualiser l'espace réservé 
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            */
        }
        
        /* Assurons-nous que tous les panneaux ont une apparence cohérente */
        #leaderboard-panel, #story-history-panel, #vote-panel, #donor-wall {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.85; /* Légèrement transparent pour voir le bateau derrière */
        }
        
        /* Animation de défilement automatique pour les panneaux */
        @keyframes autoscroll {
            0% { transform: translateY(0); }
            45% { transform: translateY(calc(-100% + 100px)); }
            55% { transform: translateY(calc(-100% + 100px)); } /* Pause au bas pendant 10% de l'animation */
            57% { transform: translateY(0); } /* Retour très rapide au début (2% de l'animation) */
            100% { transform: translateY(0); } /* Pause au début avant de recommencer */
        }
        
        .autoscroll-container {
            height: 100%;
            overflow: hidden;
            position: relative;
            max-height: inherit;
        }
        
        .autoscroll-content {
            animation: autoscroll 60s linear infinite; /* Remis à "infinite" pour boucler */
            animation-play-state: running;
            padding-bottom: 20px; /* Add space at the bottom before repeating */
        }
        
        .autoscroll-content:hover {
            animation-play-state: paused;
        }
        
        /* Objectifs sur la barre en haut */
        #objectives-panel {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            display: flex;
            gap: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .objective {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .objective-icon {
            color: #ffcc00;
            font-size: 14px;
        }
        
        .objective-text {
            white-space: nowrap;
        }
        
        /* 
        Organisation des panneaux :
        - Haut: Objectifs
        - Droite: Progression narrative 
        - À gauche milieu: Journal d'exploration
        - À gauche bas: Classement des explorateurs
        - En bas à droite: Panneau de vote
        - Centre haut (ajusté): Barre de progression
        - Centre bas: Affichage narratif
        */
        
        /* Hover effect pour rendre les panneaux plus lisibles au survol */
        #leaderboard-panel:hover, #story-history-panel:hover, #donation-panel:hover, #vote-panel:hover, #donor-wall:hover {
            opacity: 0.95;
            z-index: 950; /* Augmente le z-index au survol pour s'assurer qu'il est au-dessus des autres */
        }
        
        /* Style pour les titres des panneaux */
        #leaderboard-panel h3, #story-history-panel h3, #donor-wall h4 {
            color: #ffcc00;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        #details-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 950;
            background: rgba(0,0,0,0.7);
            color: #ffcc00;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid rgba(255, 204, 0, 0.3);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            display: none; /* Cacher le bouton des détails d'exploration */
        }
        
        #details-button:hover {
            background: rgba(50,50,0,0.7);
            border-color: rgba(255, 204, 0, 0.6);
        }
        
        /* Overlay d'authentification */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #33ff33;
            font-family: 'Courier New', monospace;
        }
        
        .auth-content {
            text-align: center;
            max-width: 500px;
            padding: 20px;
        }
        
        .auth-logo {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
        }
        
        .auth-message {
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        .auth-warning {
            color: #ff3333;
            margin-top: 20px;
            font-size: 12px;
            max-width: 80%;
            text-align: justify;
        }
        
        .donation-progress-container {
            width: 300px;
            margin: 0 auto;
        }
        
        .donation-label {
            color: #fff;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .donation-bar {
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #ff3366;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        #auth-donation-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff3366, #ff6699);
            transition: width 0.5s ease-in-out;
        }
        
        .auth-gauge {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .auth-gauge h3 {
            margin-top: 0;
            font-size: 14px;
            color: #ffcc00;
        }
        
        .tiktok-integration-notice {
            font-size: 12px;
            color: #ccc;
        }
        
        /* Notifications d'authentification */
        .auth-notification {
            position: fixed;
            right: -300px;
            top: 100px;
            background: linear-gradient(90deg, #330033, #5a0057);
            border-left: 3px solid #ff3366;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            padding: 15px;
            width: 250px;
            border-radius: 5px 0 0 5px;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .auth-notification.show {
            right: 0;
        }
        
        .auth-username {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .auth-amount {
            color: #ff3366;
            font-weight: bold;
            font-size: 18px;
        }
        
        /* Statut du système */
        .system-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #33ff33;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #ff3333;
        }
        
        .status-indicator.online {
            background-color: #33ff33;
        }
        
        /* Animation de pulsation pour la jauge */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .auth-gauge.pulse {
            animation: pulse 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
    <!-- Inclure les fichiers externes pour la gestion de l'authentification -->
    <script src="auth_gauge.js"></script>
    <script>
        /**
         * Gestion de la jauge d'authentification du système
         */
        
        // Configuration
        const REQUIRED_AMOUNT = 10; // Montant requis pour débloquer l'accès (en unités)
        let totalProgress = 0; // Variable globale pour suivre la progression
        
        /**
         * Initialisation de la jauge d'authentification
         */
        function initAuthGauge() {
            console.log("Initialisation de la jauge d'authentification");
            
            // Récupérer les éléments pour vérifier qu'ils existent
            const fillBar = document.getElementById('auth-donation-fill');
            const percentText = document.getElementById('auth-donation-percent');
            
            if (fillBar) {
                console.log("Élément 'auth-donation-fill' trouvé");
            } else {
                console.error("Élément 'auth-donation-fill' introuvable");
            }
            
            if (percentText) {
                console.log("Élément 'auth-donation-percent' trouvé");
            } else {
                console.error("Élément 'auth-donation-percent' introuvable");
            }
            
            // Mettre à jour l'affichage initial
            updateAuthGauge(0);
            
            // Écouter les messages d'authentification externes
            window.addEventListener('message', function(event) {
                console.log("Message reçu:", event.data);
                // Vérifier si le message contient des données d'authentification
                if (event.data && event.data.type === 'auth_progress') {
                    processAuthProgress(event.data.data);
                }
            });
        
            // Vérifier la progression à intervalles réguliers
            setInterval(checkAuthProgress, 5000);
            
            // Faire une vérification immédiate
            setTimeout(checkAuthProgress, 1000);
        }
        
        /**
         * Mise à jour visuelle de la jauge d'authentification
         */
        function updateAuthGauge(amount) {
            console.log("Mise à jour de la jauge d'authentification avec:", amount);
            
            // Obtenir les éléments de la jauge
            const fillBar = document.getElementById('auth-donation-fill');
            const percentText = document.getElementById('auth-donation-percent');
            
            // Calculer le pourcentage de progression
            const percentage = Math.min((amount / REQUIRED_AMOUNT) * 100, 100);
            console.log("Pourcentage calculé:", percentage);
            
            if (fillBar) {
                console.log("Mise à jour de la barre de remplissage");
                // Mettre à jour la barre de progression
                fillBar.style.width = percentage + '%';
            } else {
                console.error("Élément 'auth-donation-fill' introuvable");
            }
            
            if (percentText) {
                console.log("Mise à jour du texte de pourcentage");
                // Mettre à jour le texte du pourcentage
                percentText.textContent = Math.floor(percentage) + '%';
            } else {
                console.error("Élément 'auth-donation-percent' introuvable");
            }
            
            // Vérifier si le seuil est atteint pour débloquer
            if (amount >= REQUIRED_AMOUNT) {
                unlockAuthScreen();
            }
        }
        
        /**
         * Traitement d'une progression d'authentification
         */
        function processAuthProgress(progressData) {
            console.log("Traitement des données de progression:", progressData);
            
            // Vérifier que les données contiennent les informations nécessaires
            if (progressData && progressData.username && progressData.amount) {
                // Convertir le montant en unités si nécessaire
                const amount = parseFloat(progressData.amount);
                if (isNaN(amount)) {
                    console.error("Montant invalide:", progressData.amount);
                    return;
                }
        
                console.log("Ajout de", amount, "au total");
                // Mettre à jour le total
                totalProgress += amount;
                
                // Mettre à jour l'affichage
                updateAuthGauge(totalProgress);
                
                // Afficher une notification
                showAuthNotification(progressData.username, amount);
            } else {
                console.error("Données de progression incomplètes:", progressData);
            }
        }
        
        /**
         * Affichage d'une notification pour une progression d'authentification
         */
        function showAuthNotification(username, amount) {
            // Créer un élément de notification
            const notification = document.createElement('div');
            notification.className = 'auth-notification';
            notification.innerHTML = `
                <span class="auth-username">${username}</span>
                <span class="auth-amount">+${amount.toFixed(2)} unités</span>
            `;
            
            // Ajouter la notification au DOM
            document.body.appendChild(notification);
            
            // Animer la notification
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);
            
            // Supprimer la notification après un délai
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 500);
            }, 5000);
        }
        
        /**
         * Vérification de la progression d'authentification à intervalles réguliers
         */
        function checkAuthProgress() {
            console.log("Vérification de la progression locale");
            
            // Utiliser une méthode alternative pour lire le fichier local
            fetch('/latest_auth_progress.json')
                .then(response => {
                    console.log("Réponse du serveur pour le fichier local:", response.status);
                    if (!response.ok) {
                        throw new Error('Fichier non disponible');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log("Données locales récupérées:", data);
                    if (data && data.username && data.amount) {
                        // Traiter le don local
                        processAuthProgress(data);
                        // Réinitialiser le fichier pour éviter de traiter le même don plusieurs fois
                        resetLocalAuthProgress();
                    } else if (Object.keys(data).length === 0) {
                        console.log("Fichier local vide, pas de nouvelle progression");
                    } else {
                        console.error("Fichier local incomplet:", data);
                    }
                })
                .catch(error => {
                    // Silencieux en cas d'erreur - le fichier n'existe peut-être pas encore
                    console.log('Pas de nouveau progrès d\'authentification local:', error.message);
                });
        }
        
        /**
         * Réinitialise le fichier de progression locale après traitement
         */
        function resetLocalAuthProgress() {
            // Appel au serveur pour réinitialiser le fichier
            fetch('/api/reset-auth-progress', {
                method: 'POST'
            }).catch(error => {
                console.error('Erreur lors de la réinitialisation de la progression:', error);
            });
        }
        
        /**
         * Débloque l'écran d'authentification quand le seuil est atteint
         */
        function unlockAuthScreen() {
            const authOverlay = document.getElementById('auth-overlay');
            if (authOverlay && authOverlay.style.display !== 'none') {
                // Animation de disparition
                authOverlay.style.opacity = '0';
                setTimeout(() => {
                    authOverlay.style.display = 'none';
                    // Masquer l'écran de chargement pour afficher l'expérience 3D
                    const loadingScreen = document.getElementById('loading');
                    if (loadingScreen) {
                        loadingScreen.style.display = 'none';
                    }
                    
                    // Initialiser le jeu après l'authentification
                    if (typeof initializeAfterAuth === 'function') {
                        initializeAfterAuth();
                    } else {
                        // Initialiser ou afficher l'expérience du bateau si elle est déjà chargée
                        if (window.scene && window.camera && window.renderer) {
                            console.log("Expérience 3D déjà chargée, activation");
                            // Ajouter ici tout code nécessaire pour démarrer l'animation du bateau
                        } else {
                            console.log("Initialisation de l'expérience 3D");
                            // Initialiser la scène Three.js si pas encore fait
                            initScene();
                        }
                    }
                }, 1000);
                
                console.log("Authentification réussie, accès débloqué");
            }
        }
        
        // Initialiser la jauge d'authentification au chargement de la page
        document.addEventListener('DOMContentLoaded', initAuthGauge);
    </script>
</head>
<body>
    <!-- Overlay d'authentification -->
    <div class="auth-overlay" id="auth-overlay">
        <div class="auth-content">
            <div class="auth-logo">THE-DEPTHS v3.6.7</div>
            <div class="auth-message">
                AVERTISSEMENT: Vous êtes sur le point d'accéder à un réseau non autorisé.<br><br>
                Ce terminal sert d'interface aux communications internes du groupe THE-DEPTHS.<br>
                Toute intrusion non autorisée sera tracée et signalée aux administrateurs.<br><br>
                Cet accès est seulement destiné aux membres confirmés.
            </div>
            
            <div class="auth-gauge">
                <h3 style="text-align: center;">Progression vers l'authentification</h3>
                <div class="donation-progress-container">
                    <div class="donation-label" style="text-align: center; display: block; width: 100%;">Progression : <span id="auth-donation-percent">0%</span></div>
                    <div class="donation-bar">
                        <div id="auth-donation-fill" style="width: 0%;"></div>
                    </div>
                </div>
                <div class="tiktok-integration-notice" style="text-align: center; width: 100%;">
                    Connexion aux systèmes de sécurité en cours...
                </div>
            </div>
            
            <div style="text-align: center; width: 100%;">
                <button id="auth-accept" style="background: #111; color: #777; border: 1px solid #666; padding: 10px 20px; cursor: not-allowed; margin-top: 20px; opacity: 0.6; display: inline-block;">
                    AUTHENTIFICATION VERROUILLÉE
            </button>
            </div>
            
            <div class="auth-warning">
                SYSTÈME DE SÉCURITÉ: L'accès à cette interface est strictement contrôlé. Une authentification externe est nécessaire pour débloquer le terminal.
            </div>
        </div>
    </div>
    
    <!-- Indicateur de statut du système -->
    <div class="system-status" id="system-status">
        <div class="status-indicator" id="status-light"></div>
        <span id="status-text">SYSTÈME HORS LIGNE</span>
    </div>
    
    <div id="loading">
        <h2>Exploration des Profondeurs</h2>
            <div style="width: 200px; height: 20px; background: #333; border-radius: 10px; overflow: hidden; margin: 20px 0;">
                <div id="load-progress" style="width: 0%; height: 100%; background: linear-gradient(90deg, #ff0066, #ffcc00);"></div>
            </div>
            <div>Chargement de l'expérience...</div>
    </div>
    
    <div id="details-button" onclick="window.open('exploration_details.html', '_blank')">
        <span>📊</span>
        <span>Détails d'Exploration</span>
    </div>
    
    <div id="progress-display">
        <div style="display: flex; justify-content: space-between;">
            <span>PROGRESSION: </span>
            <span id="progress-percent">0%</span>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="story-progress"></div>
        </div>
        <div style="display: flex; justify-content: space-between;">
            <span>DÉBUT</span>
            <span>FIN</span>
        </div>
        <div style="text-align: center; font-size: 10px; color: #ffcc00; margin-top: 3px; text-shadow: 0 0 2px #000;">
            Votre participation stabilise la connexion et révèle de nouveaux mystères
        </div>
    </div>
    
    <div id="debug" style="display: none;">
        <h3>Contrôles Debug</h3>
        <button id="giftBtn">Simuler cadeau</button>
        <input id="commentInput" type="text" placeholder="Commentaire">
        <button id="commentBtn">Envoyer</button>
        <button id="likeBtn">Simuler likes</button>
        <button id="toggle-debug">Afficher contrôles avancés</button>
        <div id="advanced-debug" style="display: none; margin-top: 10px;">
            <button id="debug-milestone">Débloquer milestone</button>
            <button id="debug-entity">Invoquer entité</button>
            <button id="debug-clue">Révéler indice</button>
            <button id="debug-event">Déclencher événement</button>
            <button id="debug-vote">Lancer vote</button>
        </div>
    </div>
    
    <div id="donation-panel">
        <h3 style="margin-top: 0; text-align: center;">Les Profondeurs</h3>
        <button id="open-donation-simulator" style="width:100%; margin-bottom:5px; font-size:10px; padding:4px;">
            Ouvrir le Simulateur de Dons
        </button>
        <div style="font-size:9px; margin-bottom:5px; text-align:center;">
            Pour simuler un don, utilisez le simulateur
        </div>
        <button id="open-tiktok-config" style="width:100%; margin-bottom:10px; font-size:10px; padding:4px; background-color:#ff3366;">
            Configurer API TikTok
        </button>
        <div style="display: flex; justify-content: space-between;">
            <span>Progression narrative:</span>
            <span id="progress-percent">0%</span>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="story-progress"></div>
        </div>
        <div style="display: flex; justify-content: space-between;">
            <span>Prochain palier:</span>
            <span id="next-milestone-amount">500 unités</span>
        </div>
        <div id="story-milestone">
            "Le passage vers le secteur 2 semble bloqué. Une intervention externe est nécessaire pour rétablir l'accès..."
        </div>
        <div style="margin-top: 15px;">
            <div style="display: flex; justify-content: space-between;">
                <span>Total des contributions:</span>
                <span id="total-donations">0 unités</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
                <span>Mystères résolus:</span>
                <span id="solved-mysteries">0/13</span>
            </div>
        </div>
    </div>
    
    <div id="donor-wall">
        <h4 style="margin-top: 0;">Contributeurs Récents</h4>
        <div id="donor-list">
            <!-- Les contributeurs seront ajoutés ici dynamiquement -->
        </div>
    </div>
    
    <div id="top100-panel">
        <h4>Top 100 Explorateurs</h4>
        <div id="top100-list">
            <!-- La liste des 100 meilleurs sera ici -->
        </div>
    </div>
    
    <div id="narrative-display"></div>
    
    <div id="clue-notification">Indice trouvé: Enigme #172</div>
    
    <div id="event-counter"></div>
    
    <div id="vote-panel">
        <h4 style="margin-top: 0;">Vote Communautaire</h4>
        <p id="vote-question">Quelle porte le voyageur devrait-il ouvrir ensuite?</p>
        <div class="vote-option" data-option="1">
            <div style="display: flex; justify-content: space-between;">
                <span>Porte avec symbole spirale</span>
                <span>30%</span>
            </div>
            <div class="vote-bar">
                <div class="vote-fill" style="width: 30%"></div>
            </div>
        </div>
        <div class="vote-option" data-option="2">
            <div style="display: flex; justify-content: space-between;">
                <span>Porte rouge clignotante</span>
                <span>45%</span>
            </div>
            <div class="vote-bar">
                <div class="vote-fill" style="width: 45%"></div>
            </div>
        </div>
        <div class="vote-option" data-option="3">
            <div style="display: flex; justify-content: space-between;">
                <span>Porte avec marques de griffes</span>
                <span>25%</span>
            </div>
            <div class="vote-bar">
                <div class="vote-fill" style="width: 25%"></div>
            </div>
        </div>
        <p style="font-size: 12px; text-align: center; margin-top: 10px;">Votre interaction compte comme un vote. Fin dans <span id="vote-timer">02:45</span></p>
    </div>

    <!-- Charger Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Définir les variables globales
        window.scene = null;
        window.camera = null;
        window.renderer = null;
        window.boat = null;
        window.doors = [];
        window.segments = [];
        window.boatSpeed = 0.05;
        window.moveDirection = { x: 0, z: 1 };
        // Variable pour stocker les références aux fenêtres ouvertes
        window.detailWindows = [];
        
        // Variables pour le système de narration et de dons
        window.totalDonations = 0;
        window.currentSeason = 1;
        window.currentEpisode = 1;
        window.currentMilestoneIndex = 0;
        window.storyProgress = 0;
        window.mysteryElements = {};
        window.discoveredClues = [];
        window.solvedMysteries = 0;
        window.activatedDoors = 0;
        window.specialDoors = {};
        window.activeVote = null;
        
        // Constantes
        const TUNNEL_RADIUS = 5;
        const TUNNEL_LENGTH = 20;
        const WATER_LEVEL = -2;
        
        // Définition des paliers de donation pour le progrès narratif
        const STORY_MILESTONES = [
            { amount: 100, title: "Prologue: L'entrée", description: "Les premières portes commencent à révéler d'étranges phénomènes...", unlocksFunction: unlockPrologue },
            { amount: 500, title: "Secteur 2: Murmures", description: "Des voix lointaines résonnent dans l'eau. Elles semblent raconter des fragments d'histoires...", unlocksFunction: unlockSector2 },
            { amount: 1500, title: "Secteur 3: Mémoires", description: "Des symboles apparaissent sur certaines portes. Ils semblent former un code à déchiffrer...", unlocksFunction: unlockSector3 },
            { amount: 3000, title: "Secteur 4: Résonance", description: "L'eau commence à vibrer à intervalles réguliers. Une présence se fait sentir dans les profondeurs...", unlocksFunction: unlockSector4 },
            { amount: 5000, title: "Confrontation Mineure: L'Observateur", description: "Une entité mystérieuse semble suivre le bateau. Ses intentions sont inconnues...", unlocksFunction: unlockMinorEntity },
            { amount: 8000, title: "Secteur 5: Distorsion", description: "La réalité semble se plier. Certaines portes mènent à des lieux impossibles...", unlocksFunction: unlockSector5 },
            { amount: 12000, title: "Secteur 6: Convergence", description: "Les indices commencent à converger. Un schéma plus large se dessine...", unlocksFunction: unlockSector6 },
            { amount: 18000, title: "Confrontation Majeure: Le Gardien", description: "Une présence ancienne bloque le chemin. Elle doit être confrontée pour continuer...", unlocksFunction: unlockMajorEntity },
            { amount: 25000, title: "Secteur 7: Vérité", description: "Les derniers fragments du mystère se dévoilent. La vérité est presque à portée...", unlocksFunction: unlockSector7 },
            { amount: 35000, title: "Finale: Révélation", description: "Le mystère final des Profondeurs est sur le point d'être révélé...", unlocksFunction: unlockFinale }
        ];
        
        // Définition des niveaux de contributeurs
        const DONOR_TIERS = [
            { min: 1, max: 49, name: "Explorateur", class: "donor-common" },
            { min: 50, max: 199, name: "Chercheur", class: "donor-rare" },
            { min: 200, max: 999, name: "Éclaireur", class: "donor-epic" },
            { min: 1000, max: Infinity, name: "Illuminé", class: "donor-legendary" }
        ];
        
        // Base de données des éléments narratifs
        const STORY_ELEMENTS = {
            clues: [
                { id: "C001", text: "Numéro gravé: 7-3-9-4-2", category: "sequence", linkedMystery: "M003" },
                { id: "C002", text: "Inscription: 'Le cercle s'élargit mais revient toujours au centre'", category: "phrase", linkedMystery: "M001" },
                { id: "C003", text: "Symbole récurrent: œil traversé par une ligne verticale", category: "symbol", linkedMystery: "M002" },
                { id: "C004", text: "Date répétitive: 22.07.1976", category: "date", linkedMystery: "M005" },
                { id: "C005", text: "Coordonnées fragmentées: 47°N 13...", category: "location", linkedMystery: "M004" },
                { id: "C006", text: "Mot inversé: RUEGREMBUS", category: "word", linkedMystery: "M002" },
                { id: "C007", text: "Schéma circulaire avec 9 points", category: "pattern", linkedMystery: "M001" },
                { id: "C008", text: "Référence: 'Projet Abyssus'", category: "name", linkedMystery: "M007" },
                { id: "C009", text: "Équation: 2x² + 3x - √(4) = 0", category: "math", linkedMystery: "M003" },
                { id: "C010", text: "Fragment audio: voix distordue répétant 'le sixième cycle'", category: "audio", linkedMystery: "M006" },
                { id: "C011", text: "Phrase codée: VGSPJVYMREGIVPIVW", category: "cipher", linkedMystery: "M005" },
                { id: "C012", text: "Motif de lumières: court-court-long-long-court", category: "pattern", linkedMystery: "M004" }
            ],
            mysteries: [
                { id: "M001", title: "Le Motif Circulaire", requiredClues: ["C002", "C007"], solved: false, reward: "Révèle l'origine du tunnel" },
                { id: "M002", title: "L'Entité Observatrice", requiredClues: ["C003", "C006"], solved: false, reward: "Débloque une porte spéciale" },
                { id: "M003", title: "La Séquence Mathématique", requiredClues: ["C001", "C009"], solved: false, reward: "Permet de prévoir certains événements" },
                { id: "M004", title: "Les Signaux", requiredClues: ["C005", "C012"], solved: false, reward: "Révèle un mode de communication" },
                { id: "M005", title: "L'Incident Initial", requiredClues: ["C004", "C011"], solved: false, reward: "Explique pourquoi le tunnel existe" },
                { id: "M006", title: "Les Cycles Temporels", requiredClues: ["C010"], solved: false, reward: "Débloque une vision du passé/futur" },
                { id: "M007", title: "Les Origines du Projet", requiredClues: ["C008"], solved: false, reward: "Révèle qui a créé cette expérience" }
            ],
            narrativeFragments: [
                "Les enregistrements indiquent que le projet a été abandonné suite à une 'contamination'.",
                "Le tunnel n'a pas été construit. Il est apparu spontanément le 22 juillet 1976.",
                "Certains chercheurs affirment avoir vu leur propre reflet vieilli de plusieurs décennies.",
                "L'eau n'est pas réellement de l'eau. Sa composition moléculaire est inconnue.",
                "Les portes apparaissaient et disparaissaient même avant notre arrivée.",
                "Les tests ont révélé que le temps s'écoule différemment à diverses profondeurs.",
                "Équipe d'exploration #7: 4 entrés, 5 revenus. Anomalie consignée.",
                "Les manifestations semblent réagir aux émotions collectives des observateurs.",
                "Théorie: nous ne sommes pas dans un lieu physique mais dans une projection mentale collective.",
                "Le sixième cycle s'achèvera quand le témoin final comprendra sa fonction."
            ]
        };
        
        // ==========================================
        // FONCTIONS D'INITIALISATION
        // ==========================================
        
        // Gestion du redimensionnement de la fenêtre
        function onWindowResize() {
            // Mettre à jour la caméra
            window.camera.aspect = window.innerWidth / window.innerHeight;
            window.camera.updateProjectionMatrix();
            
            // Mettre à jour le renderer
            window.renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Initialisation de l'application
        function init() {
            // Créer la scène Three.js
            window.scene = new THREE.Scene();
            
            // Créer la caméra
            window.camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            window.camera.position.set(0, 1, -5);
            
            // Créer le renderer
            window.renderer = new THREE.WebGLRenderer({ antialias: false });
            window.renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(window.renderer.domElement);
            
            // Ajouter une lumière ambiante
            const light = new THREE.AmbientLight(0x444444);
            window.scene.add(light);
            
            // Effet de brouillard pour l'atmosphère
            window.scene.fog = new THREE.FogExp2(0x000000, 0.035);
            
            // Créer le bateau
            window.boat = createBoat();
            
            // Créer le tunnel initial
            for (let i = 0; i < 3; i++) {
                createSegment(i * TUNNEL_LENGTH);
            }
            
            // Gérer le redimensionnement
            window.addEventListener('resize', onWindowResize);
            
            // Configurer le debug et les contrôles de simulation
            setupDebug();
            setupDonationSystem();
            setupVoteSystem();
            
            // Masquer l'écran de chargement
            const loadingScreen = document.getElementById('loading');
            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 500);
            }, 2000);
            
            // Afficher le message d'introduction après un délai
            setTimeout(showNarrativeMessage, 3000, "Bienvenue dans Les Profondeurs. Les portes cachent des secrets. À vous de les découvrir...", 8000);
            
            // Initialiser les variables de narration
            updateMilestoneDisplay();
            
            // Créer le panneau d'objectifs
            createObjectivesPanel();
            
            // Initialiser les panneaux avec défilement automatique (activation directe)
            const historyList = document.getElementById('story-history-list');
            const leaderboardList = document.getElementById('leaderboard-list');
            const top100List = document.getElementById('top100-list');
            
            // Activer l'auto-défilement pour l'historique
            if (historyList) {
                const historyPanel = document.getElementById('story-history-panel');
                if (historyPanel) historyPanel.style.display = 'block';
            }
            
            // Activer l'auto-défilement pour le leaderboard
            if (leaderboardList) {
                const leaderboardPanel = document.getElementById('leaderboard-panel');
                if (leaderboardPanel) leaderboardPanel.style.display = 'block';
            }
            
            // Activer l'auto-défilement pour le top100
            if (top100List) {
                const top100Panel = document.getElementById('top100-panel');
                if (top100Panel) top100Panel.style.display = 'block';
            }
            
            // Ajouter quelques entrées initiales dans l'historique si vide
            if (!window.storyHistory || window.storyHistory.length === 0) {
                addToStoryHistory('milestone', 'Bienvenue dans Les Profondeurs');
                addToStoryHistory('discovery', 'Explorez les tunnels à la recherche d\'indices');
                addToStoryHistory('event', 'Attention aux entités mystérieuses');
            }
            
            // Démarrer l'animation
            animate();
            
            // Ajouter un gestionnaire pour le bouton détails d'exploration
            const detailsButton = document.getElementById('details-button');
            if (detailsButton) {
                detailsButton.addEventListener('click', function() {
                    const detailWindow = window.open('exploration_details.html', '_blank');
                    if (detailWindow) {
                        window.detailWindows.push(detailWindow);
                    }
                });
            }
        }
        
        // Animation de chargement
        function simulateLoading() {
                let progress = 5;
                const loadProgressBar = document.getElementById('load-progress');
                
                const interval = setInterval(() => {
                    progress += Math.floor(Math.random() * 8) + 3;
                    if (progress >= 100) {
                        progress = 100;
                        clearInterval(interval);
                    }
                    loadProgressBar.style.width = progress + '%';
                }, 300);
        }
        
        // Configuration du panneau de debug
        function setupDebug() {
            if (window.location.search.includes('debug=true')) {
                const debugPanel = document.getElementById('debug');
                debugPanel.style.display = 'block';
                
                // Toggle des contrôles avancés
                document.getElementById('toggle-debug').addEventListener('click', () => {
                    const advancedDebug = document.getElementById('advanced-debug');
                    advancedDebug.style.display = advancedDebug.style.display === 'none' ? 'block' : 'none';
                });
                
                // Bouton pour simuler un cadeau/don
                document.getElementById('giftBtn').addEventListener('click', () => {
                    const randomAmount = Math.floor(Math.random() * 100) + 5;
                    simulateDonation("Viewer" + Math.floor(Math.random() * 1000), randomAmount);
                });
                
                // Bouton pour envoyer un commentaire
                document.getElementById('commentBtn').addEventListener('click', () => {
                    const text = document.getElementById('commentInput').value.toLowerCase();
                    handleComment(text);
                    document.getElementById('commentInput').value = '';
                });
                
                // Bouton pour simuler des likes
                document.getElementById('likeBtn').addEventListener('click', () => {
                    // Petit effet visuel
                    window.camera.position.x += (Math.random() - 0.5) * 0.1;
                    window.camera.position.y += (Math.random() - 0.5) * 0.1;
                });
                
                // Contrôles avancés
                document.getElementById('debug-milestone').addEventListener('click', () => {
                    unlockNextMilestone("Debug");
                });
                
                document.getElementById('debug-entity').addEventListener('click', () => {
                    spawnSpecialEntity();
                });
                
                document.getElementById('debug-clue').addEventListener('click', () => {
                    revealRandomClue();
                });
                
                document.getElementById('debug-event').addEventListener('click', () => {
                    triggerSpecialEvent();
                });
                
                document.getElementById('debug-vote').addEventListener('click', () => {
                    startVote();
                });
            }
        }
        
        // Configuration du système de dons
        function setupDonationSystem() {
            // Vérifier si le bouton de simulation de dons existe avant d'ajouter l'écouteur
            const simDonationBtn = document.getElementById('sim-donation');
            if (simDonationBtn) {
                simDonationBtn.addEventListener('click', () => {
                    const amountInput = document.getElementById('donation-amount');
                    const amount = parseInt(amountInput.value);
                    
                    if (amount && amount > 0) {
                        const username = "Viewer" + Math.floor(Math.random() * 10000);
                        simulateDonation(username, amount);
                        amountInput.value = '';
                    }
                });
            }
            
            // Configuration du bouton d'ouverture du simulateur de dons
            const openDonationSimBtn = document.getElementById('open-donation-simulator');
            if (openDonationSimBtn) {
                openDonationSimBtn.addEventListener('click', () => {
                    openDonationSimulator();
                });
            }
            
            // Configuration du bouton d'ouverture de la configuration TikTok
            const openTikTokConfigBtn = document.getElementById('open-tiktok-config');
            if (openTikTokConfigBtn) {
                openTikTokConfigBtn.addEventListener('click', () => {
                    openTikTokConfig();
                });
            }
            
            // Initialisation des valeurs
            updateDonationDisplay();
            
            // Charger la configuration TikTok s'il y en a une
            loadTikTokConfig();
        }
        
        // Fonction pour ouvrir le simulateur de dons (sans créer de fenêtre popup)
        function openDonationSimulator() {
            // Vérifier si un panneau de simulation existe déjà et le supprimer s'il est déjà affiché
            const existingPanel = document.getElementById('inline-donation-panel');
            if (existingPanel) {
                existingPanel.remove();
                return;
            }
            
            // Créer un panneau flottant pour le simulateur de dons intégré
            const panel = document.createElement('div');
            panel.id = 'inline-donation-panel';
            panel.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 300px;
                background: rgba(0, 0, 0, 0.9);
                border: 1px solid #ff3366;
                z-index: 1000;
                padding: 15px;
                color: white;
                border-radius: 5px;
                box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            `;
            
            // Ajouter le contenu du simulateur
            panel.innerHTML = `
                <h3 style="text-align: center; margin-top: 0;">Simulateur de Dons</h3>
                <button id="close-simulator" style="position: absolute; top: 5px; right: 5px; background: none; border: none; color: #fff; cursor: pointer; font-size: 16px;">×</button>
                <div style="margin-bottom: 15px;">
                    <label>Nom d'utilisateur:</label>
                    <input type="text" id="sim-username" value="Utilisateur${Math.floor(Math.random() * 1000)}" style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label>Montant:</label>
                    <input type="number" id="sim-amount" value="5" min="1" max="1000" style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label>Message (optionnel):</label>
                    <input type="text" id="sim-message" placeholder="Message avec votre don..." style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <button id="donate-2" style="flex: 1; margin-right: 5px; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+2€</button>
                    <button id="donate-5" style="flex: 1; margin-right: 5px; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+5€</button>
                    <button id="donate-10" style="flex: 1; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+10€</button>
                </div>
                <button id="send-donation" style="width: 100%; margin-top: 15px; background: #ff3366; border: none; color: white; padding: 10px; cursor: pointer;">Simuler le Don</button>
            `;
            
            // Ajouter le panneau au document
            document.body.appendChild(panel);
            
            // Gérer la fermeture du panneau
            document.getElementById('close-simulator').addEventListener('click', () => {
                panel.remove();
            });
            
            // Gérer les boutons de montant prédéfinis
            document.getElementById('donate-2').addEventListener('click', () => {
                document.getElementById('sim-amount').value = "2";
            });
            
            document.getElementById('donate-5').addEventListener('click', () => {
                document.getElementById('sim-amount').value = "5";
            });
            
            document.getElementById('donate-10').addEventListener('click', () => {
                document.getElementById('sim-amount').value = "10";
            });
            
            // Gérer l'envoi du don
            document.getElementById('send-donation').addEventListener('click', async () => {
                const username = document.getElementById('sim-username').value || `Utilisateur${Math.floor(Math.random() * 1000)}`;
                const amount = parseFloat(document.getElementById('sim-amount').value) || 5;
                const message = document.getElementById('sim-message').value || '';
                
                if (amount <= 0) {
                    alert('Veuillez entrer un montant positif.');
                    return;
                }
                
                try {
                    // Simuler le don via l'API
                    const response = await fetch('/api/simulate/donation', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ username, amount, message })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        // Fermer le panneau après un don réussi
                        panel.remove();
                        
                        // Appliquer directement le don à l'interface actuelle
                        simulateDonation(username, amount);
                    } else {
                        console.error('Erreur lors de la simulation du don:', data.message);
                        alert('Erreur lors de la simulation du don: ' + data.message);
                    }
                } catch (error) {
                    console.error('Erreur lors de la simulation du don:', error);
                    alert('Erreur lors de la simulation du don.');
                }
            });
        }
        
        // Ouvrir la page de configuration de l'API TikTok
        function openTikTokConfig() {
            const width = 800;
            const height = 700;
            const left = (window.innerWidth - width) / 2;
            const top = (window.innerHeight - height) / 2;
            
            const popup = window.open('tiktok_api_config.html', 'TikTokConfig', 
                `width=${width},height=${height},left=${left},top=${top},resizable=yes`);
            
            if (popup) {
                window.tikTokConfigPopup = popup;
            }
        }
        
        // Charger la configuration TikTok depuis localStorage
        function loadTikTokConfig() {
            const savedConfig = localStorage.getItem('tiktokApiConfig');
            
            if (savedConfig) {
                try {
                    window.tikTokConfig = JSON.parse(savedConfig);
                    console.log('Configuration TikTok chargée:', window.tikTokConfig);
                } catch (error) {
                    console.error('Erreur lors du chargement de la configuration TikTok:', error);
                }
            }
        }
        
        // Mettre à jour la configuration TikTok (appelé depuis la page de configuration)
        function updateTikTokConfig(config) {
            window.tikTokConfig = config;
            console.log('Configuration TikTok mise à jour:', config);
        }
        
        // Traiter un événement TikTok (appelé depuis la page de configuration ou par l'API)
        function processTikTokEvent(event) {
            console.log('Événement TikTok reçu:', event);
            
            switch (event.type) {
                case 'donation':
                    // Convertir le montant en pièces/diamants en euros
                    const convertedAmount = event.convertedAmount || 
                        (event.amount * (window.tikTokConfig?.donationConversion || 0.01));
                    
                    // Simuler un don avec le montant converti
                    simulateDonation(event.username, convertedAmount, event.giftName || 'Don TikTok');
                    
                    // Amélioration: Vérifier si c'est un don majeur pour des effets spéciaux
                    if (convertedAmount >= 50) {
                        triggerSpecialEvent(event.username);
                    } else if (convertedAmount >= 20) {
                        spawnSpecialEntity();
                    }
                    break;
                    
                case 'subscription':
                    // Traiter l'abonnement comme un don avec un montant fixe
                    const subValue = event.value || 
                        (window.tikTokConfig?.subscriptionValue || 4.99);
                    
                    simulateDonation(event.username, subValue, 'Abonnement');
                    
                    // Amélioration: Ajouter un indice spécial pour les abonnés
                    revealSpecialClue(event.username);
                    break;
                    
                case 'comment':
                    // Traiter les commentaires pour détecter les mots-clés
                    if (window.tikTokConfig?.enableComments) {
                        handleComment(event.comment, event.username);
                    }
                    break;
                    
                case 'follow':
                    // Ajouter au journal d'exploration
                    addToStoryHistory('event', `${event.username} suit maintenant le stream!`);
                    break;
                    
                case 'share':
                    // Récompenser le partage avec un petit don virtuel
                    simulateDonation(event.username, 1, 'Partage');
                    
                    // Ajouter au journal d'exploration
                    addToStoryHistory('event', `${event.username} a partagé le stream!`);
                    break;
                    
                case 'like':
                    // Reconnaître les likes en masse
                    if (event.likeCount && event.likeCount > 5) {
                        // Déclencher des effets mineurs d'ambiance
                        triggerAmbientEffect(event.likeCount);
                        
                        // Ajouter au journal d'exploration pour les likes importants
                        addToStoryHistory('event', `${event.username} a envoyé ${event.likeCount} likes!`);
                    }
                    break;
                    
                case 'importantComment':
                    // Traiter les commentaires importants spécifiquement
                    handleImportantComment(event.comment, event.username);
                    break;
                    
                case 'memberJoin':
                    // Membre rejoignant le stream
                    addToStoryHistory('discovery', `${event.username} a rejoint l'exploration!`);
                    break;
            }
        }
        
        // Fonction pour révéler un indice spécial aux abonnés
        function revealSpecialClue(username) {
            // Sélectionner un indice pas encore découvert
            const unrevealedClues = STORY_ELEMENTS.clues.filter(clue => !window.discoveredClues.includes(clue.id));
            
            if (unrevealedClues.length > 0) {
                const randomIndex = Math.floor(Math.random() * unrevealedClues.length);
                const clue = unrevealedClues[randomIndex];
                
                // Révéler un indice pour l'utilisateur
                revealClue(clue.id, username);
                
                // Ajouter un message spécial dans le journal
                addToStoryHistory('discovery', `Indice spécial révélé à ${username}: "${clue.text}"`);
            }
        }
        
        // Fonction pour gérer les commentaires importants
        function handleImportantComment(comment, username) {
            // Évaluer si le commentaire contient des mots-clés liés à l'histoire
            const storyKeywords = [
                'mystère', 'créature', 'secret', 'porte', 'symbole', 'code', 
                'énigme', 'indice', 'lumière', 'ombre', 'profondeur',
                'abîme', 'portail', 'anciens', 'artefact', 'clé'
            ];
            
            const lowerComment = comment.toLowerCase();
            const matchedKeywords = storyKeywords.filter(keyword => lowerComment.includes(keyword));
            
            if (matchedKeywords.length >= 2) {
                // Commentaire très pertinent pour l'histoire
                addToStoryHistory('discovery', `Observation de ${username}: "${comment}"`);
                
                // Potentiellement révéler un indice basé sur ce commentaire
                if (Math.random() < 0.3) {
                    // 30% de chance de révéler un indice
                    setTimeout(() => {
                        revealRandomClue(username);
                    }, 3000 + Math.random() * 5000);
                }
                
                // Pour les commentaires très pertinents, ajouter un effet visuel subtil
                flashCameraEffect(0.3);
            }
        }
        
        // Fonction pour déclencher des effets d'ambiance basés sur l'activité TikTok
        function triggerAmbientEffect(intensity) {
            // L'intensité représente combien l'effet doit être prononcé, basé sur les likes/interactions
            intensity = Math.min(intensity / 10, 1.0); // Normaliser entre 0 et 1
            
            // Types d'effets d'ambiance
            const effects = [
                'flicker', // Effet de vacillement des lumières
                'ripple',  // Effet d'ondulation sur l'eau
                'mist',    // Effet de brume temporaire
                'whisper'  // Sons subtils d'ambiance
            ];
            
            // Sélectionner un effet aléatoire
            const effect = effects[Math.floor(Math.random() * effects.length)];
            
            // Appliquer l'effet selon le type
            switch (effect) {
                case 'flicker':
                    // Faire vaciller les lumières dans le tunnel
                    flickerLights(intensity);
                    break;
                case 'ripple':
                    // Créer des ondulations sur l'eau
                    createWaterRipple(intensity);
                    break;
                case 'mist':
                    // Ajouter une brume temporaire
                    addTemporaryMist(intensity);
                    break;
                case 'whisper':
                    // Jouer des sons d'ambiance
                    playAmbientSound(intensity);
                    break;
            }
        }
        
        // Faire vaciller les lumières du tunnel
        function flickerLights(intensity) {
            // Trouver toutes les lumières dans la scène
            const lights = [];
            window.scene.traverse(function(object) {
                if (object.userData && object.userData.light) {
                    lights.push(object.userData.light);
                }
            });
            
            // Aucune lumière trouvée
            if (lights.length === 0) return;
            
            // Sauvegarder les intensités d'origine
            const originalIntensities = lights.map(light => light.intensity);
            
            // Nombre de vacillements
            const flickerCount = Math.floor(3 + intensity * 7);
            
            // Fonction pour un vacillement aléatoire
            function singleFlicker(index) {
                if (index >= flickerCount) {
                    // Restaurer les intensités d'origine
                    lights.forEach((light, i) => { 
                        if (light) light.intensity = originalIntensities[i]; 
                    });
                    return;
                }
                
                // Appliquer un vacillement aléatoire à chaque lumière
                lights.forEach((light, i) => {
                    if (light) {
                        const randomFactor = 0.3 + Math.random() * 0.7;
                        light.intensity = originalIntensities[i] * randomFactor;
                    }
                });
                
                // Planifier le prochain vacillement
                setTimeout(() => singleFlicker(index + 1), 50 + Math.random() * 150);
            }
            
            // Démarrer la séquence de vacillement
            singleFlicker(0);
        }
        
        // Créer des ondulations sur l'eau
        function createWaterRipple(intensity) {
            if (!window.waterMesh) return;
            
            // Créer un effet d'ondulation sur l'eau
            const rippleDuration = 2000 + intensity * 3000; // 2-5 secondes selon l'intensité
            const startTime = Date.now();
            const originalY = window.waterMesh.position.y;
            
            // Fonction d'animation pour l'ondulation
            function animateRipple() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / rippleDuration;
                
                if (progress >= 1) {
                    // Restaurer la position de l'eau
                    window.waterMesh.position.y = originalY;
                    return;
                }
                
                // Calcul de l'ondulation
                const amplitude = 0.05 * intensity;
                const frequency = 6 + intensity * 4;
                const ripple = amplitude * Math.sin(frequency * progress * Math.PI) * (1 - progress);
                
                // Appliquer l'ondulation
                window.waterMesh.position.y = originalY + ripple;
                
                // Continuer l'animation
                requestAnimationFrame(animateRipple);
            }
            
            // Démarrer l'animation
            animateRipple();
        }
        
        // Ajouter de la brume temporaire
        function addTemporaryMist(intensity) {
            // Vérifier si la brume existe déjà
            if (window.mistMesh) return;
            
            // Créer une sphère de brume semi-transparente
            const mistGeometry = new THREE.SphereGeometry(10, 16, 16);
            const mistMaterial = new THREE.MeshBasicMaterial({
                color: 0xccccff,
                transparent: true,
                opacity: 0
            });
            
            const mistMesh = new THREE.Mesh(mistGeometry, mistMaterial);
            mistMesh.position.set(window.boat.position.x, 0, window.boat.position.z);
            window.scene.add(mistMesh);
            window.mistMesh = mistMesh;
            
            // Durée de la brume
            const mistDuration = 3000 + intensity * 4000; // 3-7 secondes
            const startTime = Date.now();
            
            // Fonction d'animation pour la brume
            function animateMist() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / mistDuration;
                
                if (progress >= 1) {
                    // Supprimer la brume
                    window.scene.remove(mistMesh);
                    window.mistMesh = null;
                    return;
                }
                
                // Animation de l'opacité (apparition puis disparition)
                let opacity;
                if (progress < 0.3) {
                    // Apparition
                    opacity = (progress / 0.3) * 0.3 * intensity;
                } else if (progress > 0.7) {
                    // Disparition
                    opacity = ((1 - progress) / 0.3) * 0.3 * intensity;
                } else {
                    // Plateau
                    opacity = 0.3 * intensity;
                }
                
                // Appliquer l'opacité
                mistMaterial.opacity = opacity;
                
                // Continuer l'animation
                requestAnimationFrame(animateMist);
            }
            
            // Démarrer l'animation
            animateMist();
        }
        
        // Jouer un son d'ambiance
        function playAmbientSound(intensity) {
            // Si le son est désactivé, ne rien faire
            if (!window.audioEnabled) return;
            
            // Sélectionner un son d'ambiance aléatoire
            const ambientSounds = [
                'whisper', 'creak', 'drip', 'distant_echo'
            ];
            
            const sound = ambientSounds[Math.floor(Math.random() * ambientSounds.length)];
            const volume = 0.1 + intensity * 0.2; // Volume entre 0.1 et 0.3
            
            // Créer un élément audio
            const audio = new Audio();
            audio.volume = volume;
            
            // Définir la source du son
            switch (sound) {
                case 'whisper':
                    audio.src = 'sounds/whisper.mp3';
                    break;
                case 'creak':
                    audio.src = 'sounds/creak.mp3';
                    break;
                case 'drip':
                    audio.src = 'sounds/drip.mp3';
                    break;
                case 'distant_echo':
                    audio.src = 'sounds/echo.mp3';
                    break;
            }
            
            // Jouer le son
            try {
                audio.play().catch(error => {
                    console.warn('Impossible de jouer le son:', error);
                });
            } catch (error) {
                console.warn('Erreur lors de la lecture du son:', error);
            }
        }
        
        // Configuration du système de vote
        function setupVoteSystem() {
            // Gestion des clics sur les options de vote
            document.querySelectorAll('.vote-option').forEach(option => {
                option.addEventListener('click', (e) => {
                    const optionIndex = e.currentTarget.getAttribute('data-option');
                    voteForOption(optionIndex);
                });
            });
        }
        
        // ==========================================
        // FONCTIONS DE CRÉATION D'OBJETS 3D
        // ==========================================
        
        // Créer une barque avec un modèle Three.js détaillé
        function createBoat() {
            const boat = new THREE.Group();
            
            // Coque principale - forme d'une barque traditionnelle
            const hullShape = new THREE.Shape();
            // Définir un contour en forme de barque vue de dessus
            hullShape.moveTo(-0.7, -1.2);
            hullShape.quadraticCurveTo(-0.2, -1.5, 0, -1.5);
            hullShape.quadraticCurveTo(0.2, -1.5, 0.7, -1.2);
            hullShape.quadraticCurveTo(0.9, -0.8, 0.9, 0);
            hullShape.quadraticCurveTo(0.9, 0.8, 0.7, 1.2);
            hullShape.quadraticCurveTo(0.2, 1.5, 0, 1.5);
            hullShape.quadraticCurveTo(-0.2, 1.5, -0.7, 1.2);
            hullShape.quadraticCurveTo(-0.9, 0.8, -0.9, 0);
            hullShape.quadraticCurveTo(-0.9, -0.8, -0.7, -1.2);
            
            // Extruder la forme pour créer la coque 3D
            const extrudeSettings = {
                steps: 2,
                depth: 0.5,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.1,
                bevelOffset: 0,
                bevelSegments: 3
            };
            
            const hullGeometry = new THREE.ExtrudeGeometry(hullShape, extrudeSettings);
            
            // Créer un matériau pour la coque avec texture de bois
            const hullMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.7,
                metalness: 0.2
            });
            
            // Créer un effet de veine de bois (procédural)
            const woodTexture = createWoodTexture();
            hullMaterial.map = woodTexture;
            
            const hull = new THREE.Mesh(hullGeometry, hullMaterial);
            hull.rotation.x = Math.PI / 2; // Orienter correctement la barque
            boat.add(hull);
            
            // Ajouter des bancs transversaux
            const benchMaterial = new THREE.MeshStandardMaterial({
                color: 0x964B00,
                roughness: 0.8,
                metalness: 0.1
            });
            
            // Banc avant
            const frontBenchGeometry = new THREE.BoxGeometry(1.4, 0.1, 0.25);
            const frontBench = new THREE.Mesh(frontBenchGeometry, benchMaterial);
            frontBench.position.set(0, 0.3, 0.9);
            boat.add(frontBench);
            
            // Banc arrière
            const backBenchGeometry = new THREE.BoxGeometry(1.4, 0.1, 0.25);
            const backBench = new THREE.Mesh(backBenchGeometry, benchMaterial);
            backBench.position.set(0, 0.3, -0.9);
            boat.add(backBench);
            
            // Banc milieu
            const middleBenchGeometry = new THREE.BoxGeometry(1.4, 0.1, 0.25);
            const middleBench = new THREE.Mesh(middleBenchGeometry, benchMaterial);
            middleBench.position.set(0, 0.3, 0);
            boat.add(middleBench);
            
            // Ajouter une lanterne pour l'ambiance
            const lanternBase = new THREE.CylinderGeometry(0.05, 0.05, 0.2, 8);
            const lanternGlobe = new THREE.SphereGeometry(0.1, 8, 8);
            const lanternMaterial = new THREE.MeshStandardMaterial({
                color: 0x553311,
                roughness: 0.5
            });
            const lanternGlassMaterial = new THREE.MeshStandardMaterial({
                color: 0xffaa55,
                emissive: 0xff6622,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.7
            });
            
            const lanternBaseObj = new THREE.Mesh(lanternBase, lanternMaterial);
            const lanternGlobeObj = new THREE.Mesh(lanternGlobe, lanternGlassMaterial);
            lanternGlobeObj.position.y = 0.15;
            
            const lantern = new THREE.Group();
            lantern.add(lanternBaseObj);
            lantern.add(lanternGlobeObj);
            lantern.position.set(0, 0.4, 0.9);
            boat.add(lantern);
            
            // Ajouter une lumière dans la lanterne
            const lanternLight = new THREE.PointLight(0xff6622, 1, 3);
            lanternLight.position.set(0, 0.15, 0);
            lantern.add(lanternLight);
            
            // Position et échelle finale de la barque
            boat.scale.set(0.7, 0.7, 0.7);
            boat.position.y = WATER_LEVEL + 0.4;
            window.scene.add(boat);
            
            // Variables pour l'animation narrative de la barque
            boat.userData = {
                lanternLight: lanternLight,
                lanternOriginalIntensity: 1,
                narrativeState: "normal"
            };
            
            return boat;
        }
        
        // Fonction pour créer une texture de bois
        function createWoodTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            
            // Fond
            context.fillStyle = "#8B4513";
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Veines de bois
            for (let i = 0; i < 30; i++) {
                // Position et épaisseur variables
                const y = Math.random() * canvas.height;
                const width = 1 + Math.random() * 3;
                
                // Couleur de veine légèrement variable
                const brightness = 100 + Math.floor(Math.random() * 50);
                const color = `rgb(${brightness}, ${brightness * 0.6}, ${brightness * 0.4})`;
                
                context.beginPath();
                context.moveTo(0, y);
                
                // Créer une ligne ondulée
                for (let x = 0; x < canvas.width; x += canvas.width/20) {
                    const newY = y + (Math.random() - 0.5) * 15;
                    context.lineTo(x, newY);
                }
                
                context.strokeStyle = color;
                context.lineWidth = width;
                context.stroke();
            }
            
            // Noeuds du bois
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 3 + Math.random() * 8;
                
                const gradient = context.createRadialGradient(x, y, 1, x, y, radius);
                gradient.addColorStop(0, "#4B2809");
                gradient.addColorStop(1, "#8B4513");
                
                context.beginPath();
                context.arc(x, y, radius, 0, Math.PI * 2);
                context.fillStyle = gradient;
                context.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }
        
        // Créer un segment de tunnel avec rebords et portes
        function createSegment(zPosition) {
            const segment = new THREE.Group();
            segment.position.z = zPosition;
            
            // Tunnel principal
            const tunnelGeometry = new THREE.CylinderGeometry(
                TUNNEL_RADIUS, TUNNEL_RADIUS, TUNNEL_LENGTH, 16, 1, true
            );
            const tunnelMaterial = new THREE.MeshPhongMaterial({
                color: 0x333333, 
                side: THREE.BackSide
            });
            const tunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
            tunnel.rotation.x = Math.PI / 2;
            segment.add(tunnel);
            
            // Sol/eau au centre
            const waterWidth = TUNNEL_RADIUS * 1.2; // Réduire pour laisser de la place aux rebords
            const floorGeometry = new THREE.PlaneGeometry(
                waterWidth, TUNNEL_LENGTH
            );
            const waterMaterial = new THREE.MeshPhongMaterial({
                color: 0x006666,
                transparent: true,
                opacity: 0.7
            });
            const floor = new THREE.Mesh(floorGeometry, waterMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = WATER_LEVEL;
            segment.add(floor);
            
            // Ajouter un effet de miroitement à l'eau
            segment.userData.water = floor;
            segment.userData.waterBaseColor = new THREE.Color(0x006666);
            
            // Ajouter des rebords et des portes régulièrement
            for (let z = 0; z < TUNNEL_LENGTH; z += 5) {
                // Position en z
                const doorZ = z - TUNNEL_LENGTH / 2;
                
                // Déterminer si cette porte est spéciale (narrative)
                const isSpecialDoor = Math.random() < 0.05 + (window.storyProgress * 0.02);
                
                // Porte gauche
                const leftDoor = createDoor(isSpecialDoor);
                leftDoor.position.set(-TUNNEL_RADIUS + 0.2, WATER_LEVEL + 1.5, doorZ);
                leftDoor.rotation.y = Math.PI/2; // Rotation pour que la porte soit perpendiculaire à la paroi du tunnel
                leftDoor.rotation.z = 0; // Assurer que la porte est verticale
                segment.add(leftDoor);
                
                if (isSpecialDoor) {
                    registerSpecialDoor(leftDoor);
                }
                
                window.doors.push(leftDoor);
                
                // Porte droite - perpendiculaire à la paroi et verticale
                const rightDoor = createDoor(isSpecialDoor);
                rightDoor.position.set(TUNNEL_RADIUS - 0.2, WATER_LEVEL + 1.5, doorZ);
                rightDoor.rotation.y = -Math.PI/2; // Rotation pour que la porte soit perpendiculaire à la paroi du tunnel
                rightDoor.rotation.z = 0; // Assurer que la porte est verticale
                segment.add(rightDoor);
                
                if (isSpecialDoor) {
                    registerSpecialDoor(rightDoor);
                }
                
                window.doors.push(rightDoor);
                
                // Rebords pour marcher (gauche et droite)
                createWalkway(segment, -TUNNEL_RADIUS + 0.6, WATER_LEVEL + 0.1, doorZ - 2.5, 5);
                createWalkway(segment, TUNNEL_RADIUS - 0.6, WATER_LEVEL + 0.1, doorZ - 2.5, 5);
                
                // Lumières murales
                createWallLight(segment, -TUNNEL_RADIUS + 0.1, WATER_LEVEL + 2, doorZ - 1.5);
                createWallLight(segment, TUNNEL_RADIUS - 0.1, WATER_LEVEL + 2, doorZ - 1.5);
            }
            
            // Lumière générale du tunnel (faible)
            const ambientLight = new THREE.PointLight(0x333333, 0.3, TUNNEL_RADIUS * 2);
            ambientLight.position.set(0, 0, 0);
            segment.add(ambientLight);
            
            // Stocker la position et les données supplémentaires
            segment.userData = { 
                ...segment.userData,
                zPosition: zPosition,
                narrativeZone: determineNarrativeZone(zPosition),
                ambientLight: ambientLight
            };
            
            window.scene.add(segment);
            window.segments.push(segment);
            return segment;
        }
        
        // Créer un rebord pour marcher
        function createWalkway(parent, x, y, z, length) {
            // Plateforme pour marcher
            const walkwayGeometry = new THREE.BoxGeometry(1, 0.2, length);
            const walkwayMaterial = new THREE.MeshPhongMaterial({color: 0x555555});
            const walkway = new THREE.Mesh(walkwayGeometry, walkwayMaterial);
            walkway.position.set(x, y, z + length/2);
            parent.add(walkway);
            
            // Support métallique
            for (let i = 0; i < length; i += 1.5) {
                const supportGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 6);
                const supportMaterial = new THREE.MeshPhongMaterial({color: 0x777777});
                const support = new THREE.Mesh(supportGeometry, supportMaterial);
                support.position.set(x, y - 0.35, z + i);
                parent.add(support);
            }
            
            return walkway;
        }
        
        // Créer une lumière murale
        function createWallLight(parent, x, y, z) {
            // Groupe pour la lumière
            const lightGroup = new THREE.Group();
            lightGroup.position.set(x, y, z);
            
            // Support mural
            const baseGeometry = new THREE.BoxGeometry(0.1, 0.3, 0.3);
            const baseMaterial = new THREE.MeshPhongMaterial({color: 0x333333});
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            
            // Orientation selon le côté
            if (x < 0) { // Côté gauche
                base.rotation.y = 0;
                lightGroup.rotation.y = 0;
            } else { // Côté droit
                base.rotation.y = Math.PI;
                lightGroup.rotation.y = Math.PI;
            }
            
            lightGroup.add(base);
            
            // Ampoule/Globe
            const bulbGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            
            // La couleur varie en fonction de la progression de l'histoire
            const colorProgress = Math.min(window.storyProgress, 1);
            const bulbColor = new THREE.Color().setHSL(
                0.1 - (colorProgress * 0.1), // De jaune vers rouge
                0.7,
                0.5 + (colorProgress * 0.2) // Devient plus brillant
            );
            
            const bulbMaterial = new THREE.MeshBasicMaterial({
                color: bulbColor
                // emissive et emissiveIntensity sont retirés car non supportés par MeshBasicMaterial
            });
            
            const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
            bulb.position.x = (x < 0) ? 0.1 : -0.1; // Position selon le côté
            lightGroup.add(bulb);
            
            // Lumière
            const intensity = 0.5 + Math.random() * 0.5;
            const light = new THREE.PointLight(bulbColor, intensity, 3);
            light.position.copy(bulb.position);
            lightGroup.add(light);
            
            // Ajouter des données pour les animations
            lightGroup.userData = {
                bulb: bulb,
                light: light,
                originalIntensity: intensity,
                flicker: Math.random() < 0.3, // 30% de chance de scintillement
                flickerSpeed: 0.5 + Math.random() * 2,
                originalColor: bulbColor.clone()
            };
            
            parent.add(lightGroup);
            return lightGroup;
        }
        
        // Créer une porte avec une orientation correcte et thématique
        function createDoor(isSpecial = false) {
            const door = new THREE.Group();
            
            // Couleurs différentes selon le type de porte
            let doorColor, frameColor, detailsColor;
            let doorSymbol = null;
            
            if (isSpecial) {
                // Porte spéciale avec couleur et caractéristiques uniques
                const specialType = Math.floor(Math.random() * 5);
                
                switch(specialType) {
                    case 0: // Porte mystérieuse avec symboles
                        frameColor = 0x443322;
                        doorColor = 0x221100;
                        detailsColor = 0xaa8866;
                        doorSymbol = "symbol";
                        break;
                    case 1: // Porte rouge sang
                        frameColor = 0x662222;
                        doorColor = 0x990000;
                        detailsColor = 0xaa3333;
                        doorSymbol = "blood";
                        break;
                    case 2: // Porte luminescente
                        frameColor = 0x443355;
                        doorColor = 0x334466;
                        detailsColor = 0x88aaff;
                        doorSymbol = "glow";
                        break;
                    case 3: // Porte métallique rouillée
                        frameColor = 0x775533;
                        doorColor = 0x996633;
                        detailsColor = 0xcc8844;
                        doorSymbol = "rust";
                        break;
                    case 4: // Porte avec marques de griffes
                        frameColor = 0x554433;
                        doorColor = 0x443322;
                        detailsColor = 0x333333;
                        doorSymbol = "claw";
                        break;
                }
            } else {
                // Porte standard
                frameColor = 0x553322;
                doorColor = 0x332211;
                detailsColor = 0x888888;
            }
            
            // Cadre de porte
            const frameGeometry = new THREE.BoxGeometry(2, 3, 0.2);
            const frameMaterial = new THREE.MeshPhongMaterial({color: frameColor});
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            door.add(frame);
            
            // La porte elle-même (panneau)
            const doorGeometry = new THREE.BoxGeometry(1.8, 2.8, 0.1);
            const doorMaterial = new THREE.MeshPhongMaterial({color: doorColor});
            const doorMesh = new THREE.Mesh(doorGeometry, doorMaterial);
            // Positionner la porte correctement pour l'animation
            doorMesh.position.z = -0.15; 
            door.add(doorMesh);
            
            // Poignée de porte
            const handleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const handleMaterial = new THREE.MeshPhongMaterial({color: detailsColor});
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.set(0.5, 0, -0.15); // À droite de la porte vue de face
            door.add(handle);
            
            // Ajout de numéro ou symbole de porte
            const doorNumber = Math.floor(Math.random() * 900) + 100;
            
            // Plaque de numéro/symbole
            const plateGeometry = new THREE.PlaneGeometry(0.4, 0.2);
            const plateMaterial = new THREE.MeshPhongMaterial({
                color: detailsColor,
                side: THREE.DoubleSide
            });
            const plate = new THREE.Mesh(plateGeometry, plateMaterial);
            plate.position.set(0, 1, -0.11);
            door.add(plate);
            
            // Ajouter un symbole spécial si c'est une porte spéciale
            if (isSpecial && doorSymbol) {
                // Créer le symbole selon le type
                switch(doorSymbol) {
                    case "symbol":
                        // Ajouter un symbole ésotérique
                        addSymbolToDoor(door, plate);
                        break;
                    case "blood":
                        // Ajouter des taches de sang
                        addBloodToDoor(door, doorMesh);
                        break;
                    case "glow":
                        // Ajouter un effet lumineux
                        addGlowToDoor(door, doorMesh);
                        break;
                    case "rust":
                        // Ajouter des taches de rouille
                        addRustToDoor(door, doorMesh);
                        break;
                    case "claw":
                        // Ajouter des marques de griffes
                        addClawMarksToDoor(door, doorMesh);
                        break;
                }
            }
            
            // Données pour l'animation et statut narratif
            door.userData = {
                doorMesh: doorMesh,
                animating: false,
                doorNumber: doorNumber,
                isSpecial: isSpecial,
                doorSymbol: doorSymbol,
                activated: false,
                containsClue: isSpecial && (Math.random() < 0.6), // 60% des portes spéciales contiennent un indice
                containsEntity: isSpecial && (Math.random() < 0.3), // 30% des portes spéciales contiennent une entité
                entityType: isSpecial ? Math.floor(Math.random() * 7) : null,
                narrativeElement: null
            };
            
            return door;
        }
        
        // Ajouter un symbole ésotérique à une porte
        function addSymbolToDoor(door, plate) {
            // Créer un canvas pour dessiner le symbole
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Fond transparent
            ctx.fillStyle = 'rgba(0, 0, 0, 0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Choisir un symbole aléatoire
            const symbolType = Math.floor(Math.random() * 5);
            
            // Dessiner le symbole en blanc
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.fillStyle = 'white';
            
            switch(symbolType) {
                case 0: // Cercle avec triangle
                    ctx.beginPath();
                    ctx.arc(64, 64, 40, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(64, 34);
                    ctx.lineTo(94, 94);
                    ctx.lineTo(34, 94);
                    ctx.closePath();
                    ctx.stroke();
                    break;
                    
                case 1: // Spirale
                    ctx.beginPath();
                    let radius = 5;
                    let angle = 0;
                    let x = 64;
                    let y = 64;
                    
                    for (let i = 0; i < 200; i++) {
                        angle += 0.1;
                        radius += 0.2;
                        const newX = 64 + Math.cos(angle) * radius;
                        const newY = 64 + Math.sin(angle) * radius;
                        ctx.lineTo(newX, newY);
                        x = newX;
                        y = newY;
                        
                        if (radius > 40) break;
                    }
                    ctx.stroke();
                    break;
                    
                case 2: // Œil
                    ctx.beginPath();
                    ctx.ellipse(64, 64, 45, 25, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(64, 64, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(64, 39);
                    ctx.lineTo(64, 89);
                    ctx.stroke();
                    break;
                    
                case 3: // Runes
                    for (let i = 0; i < 3; i++) {
                        const startX = 34 + i * 30;
                        ctx.beginPath();
                        
                        // Runes aléatoires
                        switch(Math.floor(Math.random() * 5)) {
                            case 0: // F-like
                                ctx.moveTo(startX, 44);
                                ctx.lineTo(startX, 94);
                                ctx.moveTo(startX, 44);
                                ctx.lineTo(startX + 20, 44);
                                ctx.moveTo(startX, 69);
                                ctx.lineTo(startX + 15, 69);
                                break;
                            case 1: // X-like
                                ctx.moveTo(startX - 10, 44);
                                ctx.lineTo(startX + 10, 94);
                                ctx.moveTo(startX + 10, 44);
                                ctx.lineTo(startX - 10, 94);
                                break;
                            case 2: // O with line
                                ctx.arc(startX, 69, 25, 0, Math.PI * 2);
                                ctx.moveTo(startX - 25, 69);
                                ctx.lineTo(startX + 25, 69);
                                break;
                            case 3: // Arrow
                                ctx.moveTo(startX, 44);
                                ctx.lineTo(startX, 94);
                                ctx.moveTo(startX - 10, 54);
                                ctx.lineTo(startX, 44);
                                ctx.lineTo(startX + 10, 54);
                                break;
                            case 4: // Wave
                                ctx.moveTo(startX - 15, 69);
                                for (let j = 0; j < 30; j++) {
                                    ctx.lineTo(startX - 15 + j, 69 + Math.sin(j * 0.3) * 15);
                                }
                                break;
                        }
                        
                        ctx.stroke();
                    }
                    break;
                    
                case 4: // Constellation
                    // Points
                    const points = [];
                    for (let i = 0; i < 7; i++) {
                        points.push({
                            x: 30 + Math.random() * 68,
                            y: 30 + Math.random() * 68,
                            r: 2 + Math.random() * 3
                        });
                    }
                    
                    // Dessiner les points
                    points.forEach(point => {
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, point.r, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Relier certains points
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) {
                        if (Math.random() < 0.7) { // 70% de chance de relier deux points
                            ctx.lineTo(points[i].x, points[i].y);
                        } else {
                            ctx.moveTo(points[i].x, points[i].y);
                        }
                    }
                    ctx.stroke();
                    break;
            }
            
            // Créer une texture à partir du canvas
            const symbolTexture = new THREE.CanvasTexture(canvas);
            
            // Créer un matériau avec cette texture
            const symbolMaterial = new THREE.MeshBasicMaterial({
                map: symbolTexture,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            
            // Remplacer le matériau de la plaque
            plate.material = symbolMaterial;
            
            // Agrandir la plaque pour le symbole
            plate.scale.set(2, 2, 1);
            
            // Stocker les données pour animation
            door.userData.symbolType = symbolType;
            door.userData.symbolTexture = symbolTexture;
        }
        
        // Ajouter des taches de sang à une porte
        function addBloodToDoor(door, doorMesh) {
            // Créer un canvas pour dessiner les taches
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Copier la couleur de base de la porte
            ctx.fillStyle = '#990000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner des taches de sang aléatoires
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 10 + Math.random() * 50;
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, 'rgba(120, 0, 0, 0.9)');
                gradient.addColorStop(0.7, 'rgba(80, 0, 0, 0.6)');
                gradient.addColorStop(1, 'rgba(80, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Dessiner des traînées de sang coulant
            for (let i = 0; i < 5; i++) {
                const startX = Math.random() * canvas.width;
                const startY = Math.random() * (canvas.height / 2); // Commencer dans la moitié supérieure
                
                ctx.strokeStyle = 'rgba(100, 0, 0, 0.8)';
                ctx.lineWidth = 3 + Math.random() * 8;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                
                let currentX = startX;
                let currentY = startY;
                
                // Créer une ligne descendante avec zigzags aléatoires
                const length = 50 + Math.random() * 200;
                for (let j = 0; j < length; j += 10) {
                    currentY += 10;
                    currentX += (Math.random() - 0.5) * 15;
                    
                    // Réduire progressivement l'épaisseur de la ligne
                    ctx.lineWidth = Math.max(1, ctx.lineWidth - 0.2);
                    
                    ctx.lineTo(currentX, currentY);
                    
                    if (currentY > canvas.height) break;
                }
                
                ctx.stroke();
            }
            
            // Créer une texture à partir du canvas
            const bloodTexture = new THREE.CanvasTexture(canvas);
            
            // Appliquer la texture à la porte
            const bloodMaterial = new THREE.MeshStandardMaterial({
                map: bloodTexture,
                color: 0x990000,
                roughness: 0.7,
                metalness: 0.2
            });
            
            doorMesh.material = bloodMaterial;
        }
        
        // Ajouter un effet lumineux à une porte
        function addGlowToDoor(door, doorMesh) {
            // Créer un matériau avec émission pour l'effet lumineux
            const glowMaterial = new THREE.MeshStandardMaterial({
                color: 0x334466,
                emissive: 0x88aaff,
                emissiveIntensity: 0.5,
                roughness: 0.4,
                metalness: 0.6
            });
            
            doorMesh.material = glowMaterial;
            
            // Ajouter une lumière pour renforcer l'effet
            const glowLight = new THREE.PointLight(0x88aaff, 0.8, 1);
            glowLight.position.set(0, 0, -0.1);
            doorMesh.add(glowLight);
            
            // Stocker la lumière pour l'animation
            door.userData.glowLight = glowLight;
            door.userData.originalIntensity = 0.8;
        }
        
        // Ajouter des taches de rouille à une porte
        function addRustToDoor(door, doorMesh) {
            // Créer un canvas pour dessiner la rouille
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Couleur de base métallique
            ctx.fillStyle = '#996633';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Ajouter une texture métallique de base
            for (let i = 0; i < 20; i++) {
                ctx.strokeStyle = `rgba(153, 122, 102, ${Math.random() * 0.3})`;
                ctx.lineWidth = 1 + Math.random() * 2;
                
                ctx.beginPath();
                ctx.moveTo(0, Math.random() * canvas.height);
                ctx.lineTo(canvas.width, Math.random() * canvas.height);
                ctx.stroke();
            }
            
            // Ajouter des taches de rouille
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 5 + Math.random() * 40;
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, 'rgba(180, 60, 20, 0.9)');
                gradient.addColorStop(0.6, 'rgba(160, 80, 30, 0.6)');
                gradient.addColorStop(1, 'rgba(153, 102, 51, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Ajouter quelques trous de rouille
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 2 + Math.random() * 6;
                
                ctx.fillStyle = 'rgba(30, 20, 10, 0.8)';
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Ajouter un halo de rouille intense autour du trou
                const holeGradient = ctx.createRadialGradient(x, y, radius, x, y, radius * 3);
                holeGradient.addColorStop(0, 'rgba(180, 60, 20, 0.9)');
                holeGradient.addColorStop(1, 'rgba(180, 60, 20, 0)');
                
                ctx.fillStyle = holeGradient;
                ctx.beginPath();
                ctx.arc(x, y, radius * 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Créer une texture à partir du canvas
            const rustTexture = new THREE.CanvasTexture(canvas);
            
            // Appliquer la texture à la porte
            const rustMaterial = new THREE.MeshStandardMaterial({
                map: rustTexture,
                roughness: 0.9,
                metalness: 0.4
            });
            
            doorMesh.material = rustMaterial;
        }
        
        // Ajouter des marques de griffes à une porte
        function addClawMarksToDoor(door, doorMesh) {
            // Créer un canvas pour dessiner les marques
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Couleur de base de la porte
            ctx.fillStyle = '#443322';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner des marques de griffes
            const clawSets = Math.floor(Math.random() * 3) + 2; // 2-4 sets de griffes
            
            for (let set = 0; set < clawSets; set++) {
                const startX = 50 + Math.random() * (canvas.width - 100);
                const startY = 50 + Math.random() * (canvas.height - 100);
                const angle = Math.random() * Math.PI / 4 - Math.PI / 8; // Angle aléatoire léger
                const length = 100 + Math.random() * 200;
                
                // 3-5 griffes par set
                const claws = Math.floor(Math.random() * 3) + 3;
                const spacing = 10 + Math.random() * 15;
                
                for (let claw = 0; claw < claws; claw++) {
                    // Calculer le décalage perpendiculaire à l'angle
                    const offsetX = Math.sin(angle) * spacing * (claw - (claws - 1) / 2);
                    const offsetY = -Math.cos(angle) * spacing * (claw - (claws - 1) / 2);
                    
                    ctx.strokeStyle = '#221100';
                    ctx.lineWidth = 3 + Math.random() * 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(startX + offsetX, startY + offsetY);
                    
                    // Ligne principale
                    const endX = startX + Math.cos(angle) * length + offsetX;
                    const endY = startY + Math.sin(angle) * length + offsetY;
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    // Ajouter une ligne plus claire pour montrer le bois exposé
                    ctx.strokeStyle = 'rgba(200, 150, 100, 0.7)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(startX + offsetX + 1, startY + offsetY + 1);
                    ctx.lineTo(endX + 1, endY + 1);
                    ctx.stroke();
                }
            }
            
            // Créer une texture à partir du canvas
            const clawTexture = new THREE.CanvasTexture(canvas);
            
            // Appliquer la texture à la porte
            const clawMaterial = new THREE.MeshStandardMaterial({
                map: clawTexture,
                roughness: 0.8,
                metalness: 0.1
            });
            
            doorMesh.material = clawMaterial;
        }
        
        // Déterminer la zone narrative en fonction de la position
        function determineNarrativeZone(zPosition) {
            // La progression narrative est déterminée par la distance parcourue
            // Plus on s'enfonce dans le tunnel, plus l'histoire avance
            const absolutePosition = Math.abs(zPosition);
            
            // Secteurs déterminés par les paliers de milestone
            if (absolutePosition < 50) return "prologue";
            if (absolutePosition < 150) return "secteur2";
            if (absolutePosition < 300) return "secteur3";
            if (absolutePosition < 500) return "secteur4";
            if (absolutePosition < 800) return "secteur5";
            if (absolutePosition < 1200) return "secteur6";
            if (absolutePosition < 1800) return "secteur7";
            return "finale";
        }
        
        // Enregistrer une porte spéciale
        function registerSpecialDoor(door) {
            const doorId = "door_" + Math.floor(Math.random() * 10000);
            window.specialDoors[doorId] = door;
            door.userData.doorId = doorId;
            
            // Si nous avons des indices non découverts, attribuer l'un d'eux à cette porte
            const availableClues = STORY_ELEMENTS.clues.filter(
                clue => !window.discoveredClues.includes(clue.id)
            );
            
            if (availableClues.length > 0 && door.userData.containsClue) {
                const randomClue = availableClues[Math.floor(Math.random() * availableClues.length)];
                door.userData.narrativeElement = {
                    type: "clue",
                    data: randomClue
                };
            }
        }
        
        // ==========================================
        // FONCTIONS D'ANIMATION ET INTERACTION
        // ==========================================
        
        // Animer une porte et révéler son contenu
        function animateDoor(door) {
            if (!door || door.userData.animating) return;
            
            door.userData.animating = true;
            const doorMesh = door.userData.doorMesh;
            const originalPosition = -0.15; // Position initiale
            
            // Incrémenter le compteur de portes activées
            window.activatedDoors++;
            
            // Si c'est une porte spéciale, la marquer comme activée
            if (door.userData.isSpecial && !door.userData.activated) {
                door.userData.activated = true;
                
                // Révéler un indice ou déclencher un événement narratif si applicable
                if (door.userData.narrativeElement) {
                    handleNarrativeElement(door.userData.narrativeElement);
                }
            }
            
            // Créer ou récupérer l'élément mystérieux derrière la porte
            let mysteryElement = null;
            
            if (!door.userData.mysteryElement) {
                // Déterminer le type d'élément mystérieux
                const entityType = door.userData.entityType || Math.floor(Math.random() * 7);
                
                // Si la porte est spéciale, plus de chance d'avoir une entité complexe
                const mysteryType = door.userData.isSpecial ? 
                    Math.min(6, Math.floor(Math.random() * 8)) : // Favorise les entités 0-6
                    Math.floor(Math.random() * 7); // Distribution uniforme
                
                mysteryElement = createMysteryElement(mysteryType, entityType);
                
                // Positionner l'élément derrière la porte
                const doorPosition = new THREE.Vector3();
                door.getWorldPosition(doorPosition);
                
                // Ajuster la position en fonction de l'orientation de la porte
                const doorDirection = new THREE.Vector3(0, 0, -1);
                doorDirection.applyQuaternion(door.quaternion);
                
                // Placer l'élément derrière la porte à une distance appropriée
                mysteryElement.position.copy(doorPosition);
                mysteryElement.position.add(doorDirection.multiplyScalar(1.5));
                
                // Attacher l'élément à la porte
                door.userData.mysteryElement = mysteryElement;
                door.userData.mysteryType = mysteryType;
                
                // Ajouter l'élément à la scène
                window.scene.add(mysteryElement);
                
                // Stocker dans la liste globale pour les mises à jour
                window.mysteryElements[mysteryElement.uuid] = mysteryElement;
            } else {
                mysteryElement = door.userData.mysteryElement;
            }
            
            // Animation d'ouverture puis de fermeture
            let openAmount = 0;
            let opening = true;
            let revealSound = false;
            let effectTriggered = false;
            
            const interval = setInterval(() => {
                if (opening) {
                    // Phase d'ouverture
                    openAmount += 0.02;
                    
                    // Jouer un son/effet à mi-ouverture
                    if (openAmount >= 0.15 && !revealSound) {
                        playMysterySound(door.userData.mysteryType || 0);
                        revealSound = true;
                    }
                    
                    // Limitation de l'ouverture maximale
                    if (openAmount >= 0.3) {
                        opening = false;
                        
                        // Déclencher un effet spécial une seule fois
                        if (!effectTriggered) {
                            triggerMysteryEffect(door.userData.mysteryType || 0, mysteryElement);
                            effectTriggered = true;
                        }
                    }
                } else {
                    // Phase de fermeture
                    openAmount -= 0.02;
                    
                    // Vérification fin de fermeture
                    if (openAmount <= 0) {
                        openAmount = 0;
                        clearInterval(interval);
                        door.userData.animating = false;
                        
                        // Ne pas supprimer l'élément mystérieux pour permettre des interactions continues
                        // avec le même élément si la porte est rouverte
                    }
                }
                
                // Appliquer le mouvement de la porte correctement
                doorMesh.position.z = originalPosition - openAmount;
            }, 50);
        }
        
        // Créer un élément mystérieux
        function createMysteryElement(type, entityVariant = 0) {
            const group = new THREE.Group();
            
            switch (type) {
                case 0: // Yeux brillants
                    const glowingEyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const glowingEyeMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
                    
                    const glowingLeftEye = new THREE.Mesh(glowingEyeGeometry, glowingEyeMaterial);
                    glowingLeftEye.position.x = 0.2;
                    group.add(glowingLeftEye);
                    
                    const glowingRightEye = new THREE.Mesh(glowingEyeGeometry, glowingEyeMaterial);
                    glowingRightEye.position.x = -0.2;
                    group.add(glowingRightEye);
                    
                    // Animation de clignotement
                    group.userData.update = (time) => {
                        const blink = Math.sin(time * 10) > 0.7;
                        glowingLeftEye.visible = glowingRightEye.visible = blink;
                    };
                    break;
                    
                case 1: // Tentacule ondulante
                    const tentacleGeometry = new THREE.CylinderGeometry(0.1, 0.02, 1.5, 8);
                    const tentacleMaterial = new THREE.MeshPhongMaterial({
                        color: 0x660066,
                        specular: 0x555555,
                        shininess: 30
                    });
                    
                    // Créer plusieurs segments pour la tentacule
                    const segments = 5;
                    const tentacleSegments = [];
                    
                    for (let i = 0; i < segments; i++) {
                        const segment = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.1 - (i * 0.02), 0.08 - (i * 0.02), 0.4, 8),
                            tentacleMaterial
                        );
                        segment.position.y = -i * 0.3;
                        if (i > 0) {
                            segment.position.z = 0.1;
                        }
                        
                        if (i > 0) {
                            tentacleSegments[i-1].add(segment);
                        } else {
                            group.add(segment);
                        }
                        
                        tentacleSegments.push(segment);
                    }
                    
                    // Animation d'ondulation
                    group.userData.update = (time) => {
                        tentacleSegments.forEach((segment, index) => {
                            segment.rotation.x = Math.sin(time * 3 + index * 0.5) * 0.3;
                            segment.rotation.z = Math.cos(time * 2 + index * 0.5) * 0.3;
                        });
                    };
                    break;
                    
                case 2: // Silhouette sombre
                    const torsoGeometry = new THREE.BoxGeometry(0.5, 0.8, 0.3);
                    const headGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                    const limbGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
                    
                    const shadowMaterial = new THREE.MeshBasicMaterial({
                        color: 0x000000,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const torso = new THREE.Mesh(torsoGeometry, shadowMaterial);
                    group.add(torso);
                    
                    const head = new THREE.Mesh(headGeometry, shadowMaterial);
                    head.position.y = 0.5;
                    group.add(head);
                    
                    // Membres
                    const arms = [];
                    for (let i = 0; i < 2; i++) {
                        const arm = new THREE.Mesh(limbGeometry, shadowMaterial);
                        arm.position.set(i === 0 ? -0.3 : 0.3, 0.1, 0);
                        arm.rotation.z = i === 0 ? Math.PI/4 : -Math.PI/4;
                        group.add(arm);
                        arms.push(arm);
                    }
                    
                    const legs = [];
                    for (let i = 0; i < 2; i++) {
                        const leg = new THREE.Mesh(limbGeometry, shadowMaterial);
                        leg.position.set(i === 0 ? -0.15 : 0.15, -0.6, 0);
                        group.add(leg);
                        legs.push(leg);
                    }
                    
                    // Animation d'agitation
                    group.userData.update = (time) => {
                        head.rotation.y = Math.sin(time * 2) * 0.5;
                        arms.forEach((arm, index) => {
                            arm.rotation.x = Math.sin(time * 3 + index) * 0.2;
                        });
                        legs.forEach((leg, index) => {
                            leg.rotation.x = Math.sin(time * 2 + index * Math.PI) * 0.1;
                        });
                        
                        group.position.y = Math.sin(time * 2) * 0.05;
                    };
                    break;
                    
                case 3: // Objet flottant lumineux
                    const coreGeometry = new THREE.OctahedronGeometry(0.2, 1);
                    const coreMaterial = new THREE.MeshBasicMaterial({
                        color: 0x88ffff,
                        wireframe: true
                    });
                    
                    const core = new THREE.Mesh(coreGeometry, coreMaterial);
                    group.add(core);
                    
                    // Lumière interne
                    const coreLight = new THREE.PointLight(0x88ffff, 1, 3);
                    core.add(coreLight);
                    
                    // Particules orbitales
                    const particles = [];
                    const particleGeometry = new THREE.SphereGeometry(0.03, 4, 4);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff
                    });
                    
                    for (let i = 0; i < 8; i++) {
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        particle.userData = {
                            orbitRadius: 0.3 + Math.random() * 0.2,
                            orbitSpeed: 0.5 + Math.random() * 2,
                            orbitOffset: Math.random() * Math.PI * 2,
                            elevation: (Math.random() - 0.5) * 0.3
                        };
                        group.add(particle);
                        particles.push(particle);
                    }
                    
                    // Animation d'orbite
                    group.userData.update = (time) => {
                        core.rotation.x = time * 0.5;
                        core.rotation.y = time * 0.8;
                        
                        particles.forEach(particle => {
                            const orbit = particle.userData;
                            particle.position.x = Math.cos(time * orbit.orbitSpeed + orbit.orbitOffset) * orbit.orbitRadius;
                            particle.position.z = Math.sin(time * orbit.orbitSpeed + orbit.orbitOffset) * orbit.orbitRadius;
                            particle.position.y = orbit.elevation + Math.sin(time * 2) * 0.1;
                        });
                        
                        coreLight.intensity = 0.7 + Math.sin(time * 5) * 0.3;
                    };
                    break;
                    
                case 4: // Visage fantomatique
                    const faceGeometry = new THREE.PlaneGeometry(0.6, 0.8);
                    
                    // Créer une texture dynamique pour le visage
                    const canvas = document.createElement('canvas');
                    canvas.width = 256;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    
                    // Fond transparent
                    ctx.fillStyle = 'rgba(0, 0, 0, 0)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Dessiner un visage de base
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(128, 120, 90, 120, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Yeux
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.ellipse(90, 100, 20, 25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.ellipse(166, 100, 20, 25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bouche
                    ctx.beginPath();
                    ctx.ellipse(128, 160, 40, 20, 0, 0, Math.PI);
                    ctx.fill();
                    
                    const faceTexture = new THREE.CanvasTexture(canvas);
                    const faceMaterial = new THREE.MeshBasicMaterial({
                        map: faceTexture,
                        transparent: true,
                        opacity: 0.7,
                        side: THREE.DoubleSide
                    });
                    
                    const face = new THREE.Mesh(faceGeometry, faceMaterial);
                    group.add(face);
                    
                    // Animation du visage
                    group.userData.canvas = canvas;
                    group.userData.texture = faceTexture;
                    group.userData.context = ctx;
                    
                    group.userData.update = (time) => {
                        const ctx = group.userData.context;
                        const canvas = group.userData.canvas;
                        
                        // Effacer et redessiner
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Visage de base
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.beginPath();
                        ctx.ellipse(128, 120, 90, 120, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Yeux animés
                        const eyeScaleY = Math.max(0.1, Math.sin(time * 4) * 0.5 + 0.5);
                        
                        ctx.fillStyle = '#000000';
                        ctx.beginPath();
                        ctx.ellipse(90, 100, 20, 25 * eyeScaleY, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.ellipse(166, 100, 20, 25 * eyeScaleY, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Bouche animée
                        const mouthOpen = 0.3 + Math.sin(time * 2) * 0.2;
                        ctx.beginPath();
                        ctx.ellipse(128, 160, 40, 20 * mouthOpen, 0, 0, Math.PI);
                        ctx.fill();
                        
                        // Mettre à jour la texture
                        group.userData.texture.needsUpdate = true;
                        
                        // Mouvement flottant
                        group.position.y = Math.sin(time * 1.5) * 0.1;
                        face.rotation.y = Math.sin(time) * 0.2;
                    };
                    break;
                    
                case 5: // Portail énergétique
                    const ringGeometry = new THREE.TorusGeometry(0.3, 0.03, 16, 32);
                    const ringMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffaa00,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    group.add(ring);
                    
                    // Ajouter des anneaux supplémentaires
                    const rings = [ring];
                    for (let i = 1; i < 3; i++) {
                        const newRing = new THREE.Mesh(
                            new THREE.TorusGeometry(0.3, 0.02, 16, 32),
                            new THREE.MeshBasicMaterial({
                                color: 0xffaa00,
                                transparent: true,
                                opacity: 0.5 - (i * 0.1)
                            })
                        );
                        rings.push(newRing);
                        group.add(newRing);
                    }
                    
                    // Centre du portail
                    const centerGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                    const centerMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.5
                    });
                    
                    const center = new THREE.Mesh(centerGeometry, centerMaterial);
                    group.add(center);
                    
                    // Lumière du portail
                    const portalLight = new THREE.PointLight(0xffaa00, 1, 3);
                    group.add(portalLight);
                    
                    // Animation du portail
                    group.userData.update = (time) => {
                        rings.forEach((ring, i) => {
                            ring.rotation.x = time * (1 + i * 0.2);
                            ring.rotation.y = time * (0.5 + i * 0.1);
                            
                            const scalePulse = 1 + Math.sin(time * (3 + i)) * 0.1;
                            ring.scale.set(scalePulse, scalePulse, 1);
                        });
                        
                        center.scale.setScalar(0.8 + Math.sin(time * 4) * 0.2);
                        portalLight.intensity = 0.7 + Math.sin(time * 5) * 0.3;
                    };
                    break;
                    
                case 6: // Créature obscure
                    // Remplacer CapsuleGeometry (non disponible en r128) par une combinaison de cylindre et sphères
                    const body = new THREE.Group();
                    
                    // Cylindre pour le corps
                    const bodyMainGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 12);
                    const bodyMaterial = new THREE.MeshPhongMaterial({
                        color: 0x330000,
                        specular: 0x111111,
                        shininess: 50
                    });
                    const bodyMain = new THREE.Mesh(bodyMainGeometry, bodyMaterial);
                    body.add(bodyMain);
                    
                    // Sphères pour arrondir les extrémités (effet capsule)
                    const topSphereGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                    const topSphere = new THREE.Mesh(topSphereGeometry, bodyMaterial);
                    topSphere.position.y = 0.2;
                    body.add(topSphere);
                    
                    const bottomSphereGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                    const bottomSphere = new THREE.Mesh(bottomSphereGeometry, bodyMaterial);
                    bottomSphere.position.y = -0.2;
                    body.add(bottomSphere);
                    
                    group.add(body);
                    
                    // Membres
                    const limbs = [];
                    const limbMaterial = new THREE.MeshPhongMaterial({
                        color: 0x220000,
                        specular: 0x111111,
                        shininess: 30
                    });
                    
                    for (let i = 0; i < 6; i++) {
                        const limbGeometry = new THREE.CylinderGeometry(0.03, 0.01, 0.5, 5);
                        const limb = new THREE.Mesh(limbGeometry, limbMaterial);
                        
                        const angle = (i / 6) * Math.PI * 2;
                        limb.position.set(
                            Math.cos(angle) * 0.2,
                            0,
                            Math.sin(angle) * 0.2
                        );
                        
                        limb.rotation.x = Math.PI / 2;
                        limb.rotation.z = angle;
                        
                        body.add(limb);
                        limbs.push(limb);
                    }
                    
                    // Yeux
                    const creatureEyeGeometry = new THREE.SphereGeometry(0.03, 8, 8);
                    const creatureEyeMaterial = new THREE.MeshBasicMaterial({
                        color: 0xff0000
                    });
                    
                    const creatureLeftEye = new THREE.Mesh(creatureEyeGeometry, creatureEyeMaterial);
                    creatureLeftEye.position.set(0.1, 0.2, 0.15);
                    body.add(creatureLeftEye);
                    
                    const creatureRightEye = new THREE.Mesh(creatureEyeGeometry, creatureEyeMaterial);
                    creatureRightEye.position.set(-0.1, 0.2, 0.15);
                    body.add(creatureRightEye);
                    
                    // Animation de la créature
                    group.userData.update = (time) => {
                        body.rotation.y = Math.sin(time) * 0.3;
                        
                        limbs.forEach((limb, i) => {
                            limb.rotation.x = Math.PI/2 + Math.sin(time * 3 + i) * 0.3;
                        });
                        
                        creatureLeftEye.scale.setScalar(0.8 + Math.sin(time * 5) * 0.2);
                        creatureRightEye.scale.setScalar(0.8 + Math.sin(time * 5 + 1) * 0.2);
                    };
                    break;
            }
            
            // Personnaliser l'entité selon sa variante
            customizeEntityByVariant(group, entityVariant);
            
            return group;
        }
        
        // Personnaliser l'entité en fonction de sa variante (pour la diversité)
        function customizeEntityByVariant(entity, variant) {
            // Appliquer des modifications selon le type de variante
            switch(variant) {
                case 1: // Variante plus grande
                    entity.scale.set(1.3, 1.3, 1.3);
                    break;
                case 2: // Variante colorée différemment
                    entity.traverse(child => {
                        if (child.isMesh && child.material) {
                            // Changer la teinte
                            if (child.material.color) {
                                const color = child.material.color;
                                color.setHSL((color.getHSL({}).h + 0.2) % 1, color.getHSL({}).s, color.getHSL({}).l);
                            }
                        }
                    });
                    break;
                case 3: // Variante déformée
                    entity.rotation.set(Math.PI/6, 0, Math.PI/8);
                    entity.scale.set(0.9, 1.2, 0.9);
                    break;
                case 4: // Variante avec lueur
                    const glow = new THREE.PointLight(0xaaccff, 0.5, 2);
                    entity.add(glow);
                    break;
                case 5: // Variante multiple (clones)
                    for (let i = 0; i < 2; i++) {
                        const clone = entity.clone();
                        clone.position.set(
                            (Math.random() - 0.5) * 0.5,
                            (Math.random() - 0.5) * 0.5,
                            (Math.random() - 0.5) * 0.5
                        );
                        clone.scale.set(0.7, 0.7, 0.7);
                        entity.add(clone);
                    }
                    break;
                case 6: // Variante plus angoissante/agressive
                    // Augmenter la vitesse d'animation
                    const originalUpdate = entity.userData.update;
                    if (originalUpdate) {
                        entity.userData.update = (time) => {
                            originalUpdate(time * 1.5); // Animation plus rapide
                        };
                    }
                    break;
                // Cas par défaut: aucune modification
            }
        }
        
        // Jouer un son mystérieux (simulation)
        function playMysterySound(type) {
            // Ici, on ne fait que simuler le son avec console.log
            // Dans une application réelle, vous utiliseriez l'API Web Audio
            const sounds = [
                "Chuchotements inquiétants",
                "Crissement humide",
                "Respiration profonde",
                "Bourdonnement électrique",
                "Gémissement spectral",
                "Vrombissement énergétique",
                "Grognement menaçant"
            ];
            
            console.log(`Son: ${sounds[Math.min(type, sounds.length - 1)]}`);
            
            // Déclencher un événement aléatoire basé sur la progression narrative
            if (Math.random() < window.storyProgress * 0.05) {
                setTimeout(() => {
                    console.log("Événement sonore spécial déclenché!");
                    // Effet supplémentaire possible ici
                }, 1000 + Math.random() * 2000);
            }
        }
        
        // Déclencher un effet spécial selon le type d'élément mystérieux
        function triggerMysteryEffect(type, element) {
            // Effets variés selon le type
            switch(type) {
                case 0: // Yeux - Flash rapide de lumière rouge
                    flashLightEffect(0xff0000);
                    break;
                case 1: // Tentacule - Secousse de caméra
                    cameraShakeEffect(0.5);
                    break;
                case 2: // Silhouette - Assombrissement temporaire
                    darkenEffect(1.5);
                    break;
                case 3: // Objet flottant - Pulse lumineux
                    pulseLightEffect(0x88ffff, 3);
                    break;
            }
        }
        
        // Effet de flash de lumière
        function flashLightEffect(color) {
            const flashLight = new THREE.PointLight(color, 2, 10);
            flashLight.position.set(0, 0, 0);
            window.scene.add(flashLight);
            
            // Animation du flash
            let intensity = 2;
            const interval = setInterval(() => {
                intensity -= 0.1;
                flashLight.intensity = intensity;
                
                if (intensity <= 0) {
                    clearInterval(interval);
                    window.scene.remove(flashLight);
                }
            }, 50);
        }
        
        // Effet de secousse de caméra
        function cameraShakeEffect(intensity) {
            const originalPosition = window.camera.position.clone();
            
            const interval = setInterval(() => {
                const shakeX = (Math.random() - 0.5) * intensity;
                const shakeY = (Math.random() - 0.5) * intensity;
                
                window.camera.position.set(
                    originalPosition.x + shakeX,
                    originalPosition.y + shakeY,
                    originalPosition.z
                );
                
                intensity -= 0.01;
                if (intensity <= 0) {
                    clearInterval(interval);
                    window.camera.position.copy(originalPosition);
                }
            }, 50);
        }
        
        // Effet d'assombrissement temporaire
        function darkenEffect(duration) {
            const originalIntensity = window.ambientLight.intensity;
            window.ambientLight.intensity = 0.1;
            
            setTimeout(() => {
                window.ambientLight.intensity = originalIntensity;
            }, duration * 1000);
        }
        
        // Effet de pulse lumineux
        function pulseLightEffect(color, duration) {
            const pulseLight = new THREE.PointLight(color, 1, 10);
            pulseLight.position.set(0, 0, 0);
            window.scene.add(pulseLight);
            
            let intensity = 1;
            const interval = setInterval(() => {
                intensity = 1 + Math.sin(Date.now() * 0.005) * 0.5;
                pulseLight.intensity = intensity;
                
                duration -= 0.1;
                if (duration <= 0) {
                    clearInterval(interval);
                    window.scene.remove(pulseLight);
                }
            }, 50);
        }
        
        // ==========================================
        // FONCTIONS DE GESTION DE L'EXPÉRIENCE
        // ==========================================
        
        // Gérer un élément narratif
        function handleNarrativeElement(element) {
            switch (element.type) {
                case "clue":
                    // Afficher l'indice
                    showClue(element.data);
                    break;
                case "event":
                    // Déclencher un événement narratif
                    triggerNarrativeEvent(element.data);
                    break;
            }
        }
        
        // Afficher un indice
        function showClue(clue) {
            // Afficher l'indice dans l'interface utilisateur
            console.log(`Indice découvert: ${clue.title}`);
            console.log(clue.description);
            
            // Marquer l'indice comme découvert
            window.discoveredClues.push(clue.id);
        }
        
        // Déclencher un événement narratif
        function triggerNarrativeEvent(event) {
            // Déclencher l'événement narratif
            console.log(`Événement narratif déclenché: ${event.title}`);
            console.log(event.description);
            
            // Appliquer les effets de l'événement
            event.effects.forEach(effect => {
                switch (effect.type) {
                    case "light":
                        // Modifier l'intensité de la lumière
                        window.ambientLight.intensity = effect.intensity;
                        break;
                    case "sound":
                        // Jouer un son
                        playSound(effect.sound);
                        break;
                    case "camera":
                        // Effet de caméra
                        cameraShakeEffect(effect.intensity);
                        break;
                    case "door":
                        // Modifier une porte
                        modifyDoor(effect.doorId, effect.modification);
                        break;
                }
            });
        }
        
        // Jouer un son
        function playSound(sound) {
            // Ici, on ne fait que simuler le son avec console.log
            // Dans une application réelle, vous utiliseriez l'API Web Audio
            console.log(`Son: ${sound}`);
        }
        
        // Modifier une porte
        function modifyDoor(doorId, modification) {
            const door = window.specialDoors[doorId];
            if (!door) return;
            
            switch (modification.type) {
                case "glow":
                    // Ajouter un effet lumineux
                    addGlowToDoor(door, door.userData.doorMesh);
                    break;
                case "rust":
                    // Ajouter des taches de rouille
                    addRustToDoor(door, door.userData.doorMesh);
                    break;
                case "clawMarks":
                    // Ajouter des marques de griffes
                    addClawMarksToDoor(door, door.userData.doorMesh);
                    break;
            }
        }
        
        // ==========================================
        // FONCTIONS DE GESTION DES ÉVÉNEMENTS
        // ==========================================
        
        // Gérer les événements narratifs
        function handleStoryUpdates(updates) {
            // Traiter les mises à jour narratives
            updates.forEach(update => {
                switch (update.type) {
                    case "clue":
                        // Afficher un indice
                        showClue(update.data);
                        break;
                    case "event":
                        // Déclencher un événement narratif
                        triggerNarrativeEvent(update.data);
                        break;
                }
            });
        }
        
        // Gérer les donations
        function handleDonations(donations) {
            // Traiter les donations
            donations.forEach(donation => {
                // Mettre à jour la jauge d'authentification
                updateAuthGauge(donation.amount);
                
                // Afficher une notification
                showDonationNotification(donation);
            });
        }
        
        // Afficher une notification de donation
        function showDonationNotification(donation) {
            // Afficher une notification dans l'interface utilisateur
            console.log(`Donation reçue: ${donation.amount} SATS de ${donation.sender}`);
        }
        
        // ==========================================
        // FONCTIONS DE GESTION DE L'INTERFACE UTILISATEUR
        // ==========================================
        
        // Mettre à jour la jauge d'authentification
        function updateAuthGauge(amount) {
            // Mettre à jour la jauge d'authentification
            window.authGauge.update(amount);
        }
        
        // Mettre à jour le compte à rebours
        function updateCountdown(remainingTime) {
            // Mettre à jour le compte à rebours
            const minutes = Math.floor(remainingTime / 60);
            const seconds = remainingTime % 60;
            const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            document.getElementById('vote-timer').textContent = formattedTime;
        }
        
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TikTok Horror Experience - Saison 1: Les Profondeurs</title>
    <link rel="stylesheet" href="responsive.css">
    <link rel="stylesheet" href="auth_gauge.css">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
        
        #loading { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: #000; 
            color: #fff; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            z-index: 1000;
        }
        
        #debug {
            position: fixed; 
            top: 10px; 
            left: 10px; 
            z-index: 10;
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px;
            border-radius: 5px;
        }
        
        #donation-panel {
            position: fixed;
            right: 10px;
            top: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 180px;
            font-size: 11px;
            display: none; /* Hide donation panel as requested */
        }
        
        #donation-panel h3 {
            margin-top: 0;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 40px; /* Déplacé plus bas pour éviter le chevauchement */
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            max-width: 400px;
            z-index: 900;
        }
        
        .progress-bar {
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            margin-bottom: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9900);
            width: 0%;
            transition: width 1s ease-in-out;
        }
        
        #story-milestone {
            position: fixed;
            top: 80px; /* Déplacé encore plus bas */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 12px;
            z-index: 900;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
            padding: 5px 10px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            width: 40%;
            max-width: 400px;
            line-height: 1.3;
            display: none; /* Caché par défaut, sera affiché dans le journal uniquement */
        }
        
        #donor-wall {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Aligné avec le journal d'exploration */
            max-height: 130px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Caché car remplacé par top100 */
        }
        
        #top100-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* En bas de l'écran, directement sous le journal */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px;
            max-height: 150px;
            overflow: hidden;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Caché car remplacé par leaderboard-panel */
        }
        
        #top100-panel h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 13px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .top100-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
            position: relative;
        }
        
        .top100-rank {
            width: 20px;
            text-align: center;
            color: #aaa;
        }
        
        .top100-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .top100-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #narrative-display {
            position: fixed;
            top: 50%; /* Centré verticalement */
            left: 50%;
            transform: translate(-50%, -50%); /* Centrage parfait */
            z-index: 950;
            color: white;
            text-align: center;
            width: 70%;
            max-width: 600px;
            text-shadow: 0 0 3px black, 0 0 5px black;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Fond plus opaque pour meilleure lisibilité */
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none; /* Pour éviter d'interférer avec les clics */
        }
        
        #narrative-display.visible {
            opacity: 0.95;
        }
        
        #clue-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 950;
            color: #ffcc00;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 3px solid #ffcc00;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease-out;
        }
        
        #clue-notification.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #event-counter {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            color: white;
            font-size: 120px;
            text-shadow: 0 0 20px red;
            opacity: 0;
            transition: all 0.3s ease-in-out;
            pointer-events: none;
        }
        
        #event-counter.visible {
            opacity: 1;
        }
        
        button, input { 
            margin: 5px 0; 
            display: block;
            border: none;
            background: #444;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #666;
        }
        
        #sim-donation {
            margin-top: 15px;
            width: 100%;
        }
        
        #vote-panel {
            position: fixed;
            right: 10px;
            bottom: 10px; /* En bas à droite */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 160px;
            font-size: 10px;
            display: none;
        }
        
        .vote-option {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .vote-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .vote-bar {
            height: 5px;
            width: 100%;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .vote-fill {
            height: 100%;
            background: linear-gradient(90deg, #77ccff, #4488ff);
            width: 30%;
        }
        
        /* Animation pour les effects */
        @keyframes pulse {
            0% { opacity: 0.2; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.2; transform: scale(0.95); }
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        #leaderboard-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* Repositionné en bas sous le journal */
            top: auto; /* Annule la position top précédente */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 200px;
            max-height: 145px; /* Hauteur réduite pour éviter le chevauchement (était à 150px) */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #leaderboard-panel h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #aaa;
            width: 20px;
            text-align: center;
        }
        
        .leaderboard-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .leaderboard-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #story-history-panel {
            position: fixed;
            left: 10px;
            bottom: 175px; /* Remonté plus haut pour éviter le chevauchement (était à 70px) */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Élargi pour mieux afficher les messages */
            max-height: 180px; /* Légèrement plus grand */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #story-history-panel h3 {
            margin-top: 0;
            margin-bottom: 3px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .history-item {
            margin-bottom: 4px;
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .history-item-milestone {
            background-color: rgba(255, 204, 0, 0.2);
            border-left: 2px solid #ffcc00;
        }
        
        .history-item-discovery {
            background-color: rgba(119, 204, 255, 0.2);
            border-left: 2px solid #77ccff;
        }
        
        .history-item-event {
            background-color: rgba(255, 102, 102, 0.2);
            border-left: 2px solid #ff6666;
        }
        
        .history-timestamp {
            color: #aaa;
            font-size: 8px;
            margin-bottom: 2px;
            font-style: italic;
        }
        
        /* Style pour réserver l'espace pour la caméra */
        .camera-space {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 100px;
            z-index: 800;
            /* Background commenté - juste pour visualiser l'espace réservé 
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            */
        }
        
        /* Assurons-nous que tous les panneaux ont une apparence cohérente */
        #leaderboard-panel, #story-history-panel, #vote-panel, #donor-wall {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.85; /* Légèrement transparent pour voir le bateau derrière */
        }
        
        /* Animation de défilement automatique pour les panneaux */
        @keyframes autoscroll {
            0% { transform: translateY(0); }
            45% { transform: translateY(calc(-100% + 100px)); }
            55% { transform: translateY(calc(-100% + 100px)); } /* Pause au bas pendant 10% de l'animation */
            57% { transform: translateY(0); } /* Retour très rapide au début (2% de l'animation) */
            100% { transform: translateY(0); } /* Pause au début avant de recommencer */
        }
        
        .autoscroll-container {
            height: 100%;
            overflow: hidden;
            position: relative;
            max-height: inherit;
        }
        
        .autoscroll-content {
            animation: autoscroll 60s linear infinite; /* Remis à "infinite" pour boucler */
            animation-play-state: running;
            padding-bottom: 20px; /* Add space at the bottom before repeating */
        }
        
        .autoscroll-content:hover {
            animation-play-state: paused;
        }
        
        /* Objectifs sur la barre en haut */
        #objectives-panel {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            display: flex;
            gap: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .objective {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .objective-icon {
            color: #ffcc00;
            font-size: 14px;
        }
        
        .objective-text {
            white-space: nowrap;
        }
        
        /* 
        Organisation des panneaux :
        - Haut: Objectifs
        - Droite: Progression narrative 
        - À gauche milieu: Journal d'exploration
        - À gauche bas: Classement des explorateurs
        - En bas à droite: Panneau de vote
        - Centre haut (ajusté): Barre de progression
        - Centre bas: Affichage narratif
        */
        
        /* Hover effect pour rendre les panneaux plus lisibles au survol */
        #leaderboard-panel:hover, #story-history-panel:hover, #donation-panel:hover, #vote-panel:hover, #donor-wall:hover {
            opacity: 0.95;
            z-index: 950; /* Augmente le z-index au survol pour s'assurer qu'il est au-dessus des autres */
        }
        
        /* Style pour les titres des panneaux */
        #leaderboard-panel h3, #story-history-panel h3, #donor-wall h4 {
            color: #ffcc00;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        #details-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 950;
            background: rgba(0,0,0,0.7);
            color: #ffcc00;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid rgba(255, 204, 0, 0.3);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            display: none; /* Cacher le bouton des détails d'exploration */
        }
        
        #details-button:hover {
            background: rgba(50,50,0,0.7);
            border-color: rgba(255, 204, 0, 0.6);
        }
        
        /* Overlay d'authentification */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #33ff33;
            font-family: 'Courier New', monospace;
        }
        
        .auth-content {
            text-align: center;
            max-width: 500px;
            padding: 20px;
        }
        
        .auth-logo {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
        }
        
        .auth-message {
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        .auth-warning {
            color: #ff3333;
            margin-top: 20px;
            font-size: 12px;
            max-width: 80%;
            text-align: justify;
        }
        
        .donation-progress-container {
            width: 300px;
            margin: 0 auto;
        }
        
        .donation-label {
            color: #fff;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .donation-bar {
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #ff3366;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        #auth-donation-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff3366, #ff6699);
            transition: width 0.5s ease-in-out;
        }
        
        .auth-gauge {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .auth-gauge h3 {
            margin-top: 0;
            font-size: 14px;
            color: #ffcc00;
        }
        
        .tiktok-integration-notice {
            font-size: 12px;
            color: #ccc;
        }
        
        /* Notifications d'authentification */
        .auth-notification {
            position: fixed;
            right: -300px;
            top: 100px;
            background: linear-gradient(90deg, #330033, #5a0057);
            border-left: 3px solid #ff3366;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            padding: 15px;
            width: 250px;
            border-radius: 5px 0 0 5px;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .auth-notification.show {
            right: 0;
        }
        
        .auth-username {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .auth-amount {
            color: #ff3366;
            font-weight: bold;
            font-size: 18px;
        }
        
        /* Statut du système */
        .system-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #33ff33;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #ff3333;
        }
        
        .status-indicator.online {
            background-color: #33ff33;
        }
        
        /* Animation de pulsation pour la jauge */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .auth-gauge.pulse {
            animation: pulse 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
    <!-- Inclure les fichiers externes pour la gestion de l'authentification -->
    <script src="auth_gauge.js"></script>
    <script>
        /**
         * Gestion de la jauge d'authentification du système
         */
        
        // Configuration
        const REQUIRED_AMOUNT = 10; // Montant requis pour débloquer l'accès (en unités)
        let totalProgress = 0; // Variable globale pour suivre la progression
        
        /**
         * Initialisation de la jauge d'authentification
         */
        function initAuthGauge() {
            console.log("Initialisation de la jauge d'authentification");
            
            // Récupérer les éléments pour vérifier qu'ils existent
            const fillBar = document.getElementById('auth-donation-fill');
            const percentText = document.getElementById('auth-donation-percent');
            
            if (fillBar) {
                console.log("Élément 'auth-donation-fill' trouvé");
            } else {
                console.error("Élément 'auth-donation-fill' introuvable");
            }
            
            if (percentText) {
                console.log("Élément 'auth-donation-percent' trouvé");
            } else {
                console.error("Élément 'auth-donation-percent' introuvable");
            }
            
            // Mettre à jour l'affichage initial
            updateAuthGauge(0);
            
            // Écouter les messages d'authentification externes
            window.addEventListener('message', function(event) {
                console.log("Message reçu:", event.data);
                // Vérifier si le message contient des données d'authentification
                if (event.data && event.data.type === 'auth_progress') {
                    processAuthProgress(event.data.data);
                }
            });
        
            // Vérifier la progression à intervalles réguliers
            setInterval(checkAuthProgress, 5000);
            
            // Faire une vérification immédiate
            setTimeout(checkAuthProgress, 1000);
        }
        
        /**
         * Mise à jour visuelle de la jauge d'authentification
         */
        function updateAuthGauge(amount) {
            console.log("Mise à jour de la jauge d'authentification avec:", amount);
            
            // Obtenir les éléments de la jauge
            const fillBar = document.getElementById('auth-donation-fill');
            const percentText = document.getElementById('auth-donation-percent');
            
            // Calculer le pourcentage de progression
            const percentage = Math.min((amount / REQUIRED_AMOUNT) * 100, 100);
            console.log("Pourcentage calculé:", percentage);
            
            if (fillBar) {
                console.log("Mise à jour de la barre de remplissage");
                // Mettre à jour la barre de progression
                fillBar.style.width = percentage + '%';
            } else {
                console.error("Élément 'auth-donation-fill' introuvable");
            }
            
            if (percentText) {
                console.log("Mise à jour du texte de pourcentage");
                // Mettre à jour le texte du pourcentage
                percentText.textContent = Math.floor(percentage) + '%';
            } else {
                console.error("Élément 'auth-donation-percent' introuvable");
            }
            
            // Vérifier si le seuil est atteint pour débloquer
            if (amount >= REQUIRED_AMOUNT) {
                unlockAuthScreen();
            }
        }
        
        /**
         * Traitement d'une progression d'authentification
         */
        function processAuthProgress(progressData) {
            console.log("Traitement des données de progression:", progressData);
            
            // Vérifier que les données contiennent les informations nécessaires
            if (progressData && progressData.username && progressData.amount) {
                // Convertir le montant en unités si nécessaire
                const amount = parseFloat(progressData.amount);
                if (isNaN(amount)) {
                    console.error("Montant invalide:", progressData.amount);
                    return;
                }
        
                console.log("Ajout de", amount, "au total");
                // Mettre à jour le total
                totalProgress += amount;
                
                // Mettre à jour l'affichage
                updateAuthGauge(totalProgress);
                
                // Afficher une notification
                showAuthNotification(progressData.username, amount);
            } else {
                console.error("Données de progression incomplètes:", progressData);
            }
        }
        
        /**
         * Affichage d'une notification pour une progression d'authentification
         */
        function showAuthNotification(username, amount) {
            // Créer un élément de notification
            const notification = document.createElement('div');
            notification.className = 'auth-notification';
            notification.innerHTML = `
                <span class="auth-username">${username}</span>
                <span class="auth-amount">+${amount.toFixed(2)} unités</span>
            `;
            
            // Ajouter la notification au DOM
            document.body.appendChild(notification);
            
            // Animer la notification
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);
            
            // Supprimer la notification après un délai
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 500);
            }, 5000);
        }
        
        /**
         * Vérification de la progression d'authentification à intervalles réguliers
         */
        function checkAuthProgress() {
            console.log("Vérification de la progression locale");
            
            // Utiliser une méthode alternative pour lire le fichier local
            fetch('/latest_auth_progress.json')
                .then(response => {
                    console.log("Réponse du serveur pour le fichier local:", response.status);
                    if (!response.ok) {
                        throw new Error('Fichier non disponible');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log("Données locales récupérées:", data);
                    if (data && data.username && data.amount) {
                        // Traiter le don local
                        processAuthProgress(data);
                        // Réinitialiser le fichier pour éviter de traiter le même don plusieurs fois
                        resetLocalAuthProgress();
                    } else if (Object.keys(data).length === 0) {
                        console.log("Fichier local vide, pas de nouvelle progression");
                    } else {
                        console.error("Fichier local incomplet:", data);
                    }
                })
                .catch(error => {
                    // Silencieux en cas d'erreur - le fichier n'existe peut-être pas encore
                    console.log('Pas de nouveau progrès d\'authentification local:', error.message);
                });
        }
        
        /**
         * Réinitialise le fichier de progression locale après traitement
         */
        function resetLocalAuthProgress() {
            // Appel au serveur pour réinitialiser le fichier
            fetch('/api/reset-auth-progress', {
                method: 'POST'
            }).catch(error => {
                console.error('Erreur lors de la réinitialisation de la progression:', error);
            });
        }
        
        /**
         * Débloque l'écran d'authentification quand le seuil est atteint
         */
        function unlockAuthScreen() {
            const authOverlay = document.getElementById('auth-overlay');
            if (authOverlay && authOverlay.style.display !== 'none') {
                // Animation de disparition
                authOverlay.style.opacity = '0';
                setTimeout(() => {
                    authOverlay.style.display = 'none';
                    // Masquer l'écran de chargement pour afficher l'expérience 3D
                    const loadingScreen = document.getElementById('loading');
                    if (loadingScreen) {
                        loadingScreen.style.display = 'none';
                    }
                    
                    // Initialiser le jeu après l'authentification
                    if (typeof initializeAfterAuth === 'function') {
                        initializeAfterAuth();
                    } else {
                        // Initialiser ou afficher l'expérience du bateau si elle est déjà chargée
                        if (window.scene && window.camera && window.renderer) {
                            console.log("Expérience 3D déjà chargée, activation");
                            // Ajouter ici tout code nécessaire pour démarrer l'animation du bateau
                        } else {
                            console.log("Initialisation de l'expérience 3D");
                            // Initialiser la scène Three.js si pas encore fait
                            initScene();
                        }
                    }
                }, 1000);
                
                console.log("Authentification réussie, accès débloqué");
            }
        }
        
        // Initialiser la jauge d'authentification au chargement de la page
        document.addEventListener('DOMContentLoaded', initAuthGauge);
    </script>
</head>
<body>
    <!-- Overlay d'authentification -->
    <div class="auth-overlay" id="auth-overlay">
        <div class="auth-content">
            <div class="auth-logo">THE-DEPTHS v3.6.7</div>
            <div class="auth-message">
                AVERTISSEMENT: Vous êtes sur le point d'accéder à un réseau non autorisé.<br><br>
                Ce terminal sert d'interface aux communications internes du groupe THE-DEPTHS.<br>
                Toute intrusion non autorisée sera tracée et signalée aux administrateurs.<br><br>
                Cet accès est seulement destiné aux membres confirmés.
            </div>
            
            <div class="auth-gauge">
                <h3 style="text-align: center;">Progression vers l'authentification</h3>
                <div class="donation-progress-container">
                    <div class="donation-label" style="text-align: center; display: block; width: 100%;">Progression : <span id="auth-donation-percent">0%</span></div>
                    <div class="donation-bar">
                        <div id="auth-donation-fill" style="width: 0%;"></div>
                    </div>
                </div>
                <div class="tiktok-integration-notice" style="text-align: center; width: 100%;">
                    Connexion aux systèmes de sécurité en cours...
                </div>
            </div>
            
            <div style="text-align: center; width: 100%;">
                <button id="auth-accept" style="background: #111; color: #777; border: 1px solid #666; padding: 10px 20px; cursor: not-allowed; margin-top: 20px; opacity: 0.6; display: inline-block;">
                    AUTHENTIFICATION VERROUILLÉE
            </button>
            </div>
            
            <div class="auth-warning">
                SYSTÈME DE SÉCURITÉ: L'accès à cette interface est strictement contrôlé. Une authentification externe est nécessaire pour débloquer le terminal.
            </div>
        </div>
    </div>
    
    <!-- Indicateur de statut du système -->
    <div class="system-status" id="system-status">
        <div class="status-indicator" id="status-light"></div>
        <span id="status-text">SYSTÈME HORS LIGNE</span>
    </div>
    
    <div id="loading">
        <h2>Exploration des Profondeurs</h2>
            <div style="width: 200px; height: 20px; background: #333; border-radius: 10px; overflow: hidden; margin: 20px 0;">
                <div id="load-progress" style="width: 0%; height: 100%; background: linear-gradient(90deg, #ff0066, #ffcc00);"></div>
            </div>
            <div>Chargement de l'expérience...</div>
    </div>
    
    <div id="details-button" onclick="window.open('exploration_details.html', '_blank')">
        <span>📊</span>
        <span>Détails d'Exploration</span>
    </div>
    
    <div id="progress-display">
        <div style="display: flex; justify-content: space-between;">
            <span>PROGRESSION: </span>
            <span id="progress-percent">0%</span>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="story-progress"></div>
        </div>
        <div style="display: flex; justify-content: space-between;">
            <span>DÉBUT</span>
            <span>FIN</span>
        </div>
        <div style="text-align: center; font-size: 10px; color: #ffcc00; margin-top: 3px; text-shadow: 0 0 2px #000;">
            Votre participation stabilise la connexion et révèle de nouveaux mystères
        </div>
    </div>
    
    <div id="debug" style="display: none;">
        <h3>Contrôles Debug</h3>
        <button id="giftBtn">Simuler cadeau</button>
        <input id="commentInput" type="text" placeholder="Commentaire">
        <button id="commentBtn">Envoyer</button>
        <button id="likeBtn">Simuler likes</button>
        <button id="toggle-debug">Afficher contrôles avancés</button>
        <div id="advanced-debug" style="display: none; margin-top: 10px;">
            <button id="debug-milestone">Débloquer milestone</button>
            <button id="debug-entity">Invoquer entité</button>
            <button id="debug-clue">Révéler indice</button>
            <button id="debug-event">Déclencher événement</button>
            <button id="debug-vote">Lancer vote</button>
        </div>
    </div>
    
    <div id="donation-panel">
        <h3 style="margin-top: 0; text-align: center;">Les Profondeurs</h3>
        <button id="open-donation-simulator" style="width:100%; margin-bottom:5px; font-size:10px; padding:4px;">
            Ouvrir le Simulateur de Dons
        </button>
        <div style="font-size:9px; margin-bottom:5px; text-align:center;">
            Pour simuler un don, utilisez le simulateur
        </div>
        <button id="open-tiktok-config" style="width:100%; margin-bottom:10px; font-size:10px; padding:4px; background-color:#ff3366;">
            Configurer API TikTok
        </button>
        <div style="display: flex; justify-content: space-between;">
            <span>Progression narrative:</span>
            <span id="progress-percent">0%</span>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="story-progress"></div>
        </div>
        <div style="display: flex; justify-content: space-between;">
            <span>Prochain palier:</span>
            <span id="next-milestone-amount">500 unités</span>
        </div>
        <div id="story-milestone">
            "Le passage vers le secteur 2 semble bloqué. Une intervention externe est nécessaire pour rétablir l'accès..."
        </div>
        <div style="margin-top: 15px;">
            <div style="display: flex; justify-content: space-between;">
                <span>Total des contributions:</span>
                <span id="total-donations">0 unités</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
                <span>Mystères résolus:</span>
                <span id="solved-mysteries">0/13</span>
            </div>
        </div>
    </div>
    
    <div id="donor-wall">
        <h4 style="margin-top: 0;">Contributeurs Récents</h4>
        <div id="donor-list">
            <!-- Les contributeurs seront ajoutés ici dynamiquement -->
        </div>
    </div>
    
    <div id="top100-panel">
        <h4>Top 100 Explorateurs</h4>
        <div id="top100-list">
            <!-- La liste des 100 meilleurs sera ici -->
        </div>
    </div>
    
    <div id="narrative-display"></div>
    
    <div id="clue-notification">Indice trouvé: Enigme #172</div>
    
    <div id="event-counter"></div>
    
    <div id="vote-panel">
        <h4 style="margin-top: 0;">Vote Communautaire</h4>
        <p id="vote-question">Quelle porte le voyageur devrait-il ouvrir ensuite?</p>
        <div class="vote-option" data-option="1">
            <div style="display: flex; justify-content: space-between;">
                <span>Porte avec symbole spirale</span>
                <span>30%</span>
            </div>
            <div class="vote-bar">
                <div class="vote-fill" style="width: 30%"></div>
            </div>
        </div>
        <div class="vote-option" data-option="2">
            <div style="display: flex; justify-content: space-between;">
                <span>Porte rouge clignotante</span>
                <span>45%</span>
            </div>
            <div class="vote-bar">
                <div class="vote-fill" style="width: 45%"></div>
            </div>
        </div>
        <div class="vote-option" data-option="3">
            <div style="display: flex; justify-content: space-between;">
                <span>Porte avec marques de griffes</span>
                <span>25%</span>
            </div>
            <div class="vote-bar">
                <div class="vote-fill" style="width: 25%"></div>
            </div>
        </div>
        <p style="font-size: 12px; text-align: center; margin-top: 10px;">Votre interaction compte comme un vote. Fin dans <span id="vote-timer">02:45</span></p>
    </div>

    <!-- Charger Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Définir les variables globales
        window.scene = null;
        window.camera = null;
        window.renderer = null;
        window.boat = null;
        window.doors = [];
        window.segments = [];
        window.boatSpeed = 0.05;
        window.moveDirection = { x: 0, z: 1 };
        // Variable pour stocker les références aux fenêtres ouvertes
        window.detailWindows = [];
        
        // Variables pour le système de narration et de dons
        window.totalDonations = 0;
        window.currentSeason = 1;
        window.currentEpisode = 1;
        window.currentMilestoneIndex = 0;
        window.storyProgress = 0;
        window.mysteryElements = {};
        window.discoveredClues = [];
        window.solvedMysteries = 0;
        window.activatedDoors = 0;
        window.specialDoors = {};
        window.activeVote = null;
        
        // Constantes
        const TUNNEL_RADIUS = 5;
        const TUNNEL_LENGTH = 20;
        const WATER_LEVEL = -2;
        
        // Définition des paliers de donation pour le progrès narratif
        const STORY_MILESTONES = [
            { amount: 100, title: "Prologue: L'entrée", description: "Les premières portes commencent à révéler d'étranges phénomènes...", unlocksFunction: unlockPrologue },
            { amount: 500, title: "Secteur 2: Murmures", description: "Des voix lointaines résonnent dans l'eau. Elles semblent raconter des fragments d'histoires...", unlocksFunction: unlockSector2 },
            { amount: 1500, title: "Secteur 3: Mémoires", description: "Des symboles apparaissent sur certaines portes. Ils semblent former un code à déchiffrer...", unlocksFunction: unlockSector3 },
            { amount: 3000, title: "Secteur 4: Résonance", description: "L'eau commence à vibrer à intervalles réguliers. Une présence se fait sentir dans les profondeurs...", unlocksFunction: unlockSector4 },
            { amount: 5000, title: "Confrontation Mineure: L'Observateur", description: "Une entité mystérieuse semble suivre le bateau. Ses intentions sont inconnues...", unlocksFunction: unlockMinorEntity },
            { amount: 8000, title: "Secteur 5: Distorsion", description: "La réalité semble se plier. Certaines portes mènent à des lieux impossibles...", unlocksFunction: unlockSector5 },
            { amount: 12000, title: "Secteur 6: Convergence", description: "Les indices commencent à converger. Un schéma plus large se dessine...", unlocksFunction: unlockSector6 },
            { amount: 18000, title: "Confrontation Majeure: Le Gardien", description: "Une présence ancienne bloque le chemin. Elle doit être confrontée pour continuer...", unlocksFunction: unlockMajorEntity },
            { amount: 25000, title: "Secteur 7: Vérité", description: "Les derniers fragments du mystère se dévoilent. La vérité est presque à portée...", unlocksFunction: unlockSector7 },
            { amount: 35000, title: "Finale: Révélation", description: "Le mystère final des Profondeurs est sur le point d'être révélé...", unlocksFunction: unlockFinale }
        ];
        
        // Définition des niveaux de contributeurs
        const DONOR_TIERS = [
            { min: 1, max: 49, name: "Explorateur", class: "donor-common" },
            { min: 50, max: 199, name: "Chercheur", class: "donor-rare" },
            { min: 200, max: 999, name: "Éclaireur", class: "donor-epic" },
            { min: 1000, max: Infinity, name: "Illuminé", class: "donor-legendary" }
        ];
        
        // Base de données des éléments narratifs
        const STORY_ELEMENTS = {
            clues: [
                { id: "C001", text: "Numéro gravé: 7-3-9-4-2", category: "sequence", linkedMystery: "M003" },
                { id: "C002", text: "Inscription: 'Le cercle s'élargit mais revient toujours au centre'", category: "phrase", linkedMystery: "M001" },
                { id: "C003", text: "Symbole récurrent: œil traversé par une ligne verticale", category: "symbol", linkedMystery: "M002" },
                { id: "C004", text: "Date répétitive: 22.07.1976", category: "date", linkedMystery: "M005" },
                { id: "C005", text: "Coordonnées fragmentées: 47°N 13...", category: "location", linkedMystery: "M004" },
                { id: "C006", text: "Mot inversé: RUEGREMBUS", category: "word", linkedMystery: "M002" },
                { id: "C007", text: "Schéma circulaire avec 9 points", category: "pattern", linkedMystery: "M001" },
                { id: "C008", text: "Référence: 'Projet Abyssus'", category: "name", linkedMystery: "M007" },
                { id: "C009", text: "Équation: 2x² + 3x - √(4) = 0", category: "math", linkedMystery: "M003" },
                { id: "C010", text: "Fragment audio: voix distordue répétant 'le sixième cycle'", category: "audio", linkedMystery: "M006" },
                { id: "C011", text: "Phrase codée: VGSPJVYMREGIVPIVW", category: "cipher", linkedMystery: "M005" },
                { id: "C012", text: "Motif de lumières: court-court-long-long-court", category: "pattern", linkedMystery: "M004" }
            ],
            mysteries: [
                { id: "M001", title: "Le Motif Circulaire", requiredClues: ["C002", "C007"], solved: false, reward: "Révèle l'origine du tunnel" },
                { id: "M002", title: "L'Entité Observatrice", requiredClues: ["C003", "C006"], solved: false, reward: "Débloque une porte spéciale" },
                { id: "M003", title: "La Séquence Mathématique", requiredClues: ["C001", "C009"], solved: false, reward: "Permet de prévoir certains événements" },
                { id: "M004", title: "Les Signaux", requiredClues: ["C005", "C012"], solved: false, reward: "Révèle un mode de communication" },
                { id: "M005", title: "L'Incident Initial", requiredClues: ["C004", "C011"], solved: false, reward: "Explique pourquoi le tunnel existe" },
                { id: "M006", title: "Les Cycles Temporels", requiredClues: ["C010"], solved: false, reward: "Débloque une vision du passé/futur" },
                { id: "M007", title: "Les Origines du Projet", requiredClues: ["C008"], solved: false, reward: "Révèle qui a créé cette expérience" }
            ],
            narrativeFragments: [
                "Les enregistrements indiquent que le projet a été abandonné suite à une 'contamination'.",
                "Le tunnel n'a pas été construit. Il est apparu spontanément le 22 juillet 1976.",
                "Certains chercheurs affirment avoir vu leur propre reflet vieilli de plusieurs décennies.",
                "L'eau n'est pas réellement de l'eau. Sa composition moléculaire est inconnue.",
                "Les portes apparaissaient et disparaissaient même avant notre arrivée.",
                "Les tests ont révélé que le temps s'écoule différemment à diverses profondeurs.",
                "Équipe d'exploration #7: 4 entrés, 5 revenus. Anomalie consignée.",
                "Les manifestations semblent réagir aux émotions collectives des observateurs.",
                "Théorie: nous ne sommes pas dans un lieu physique mais dans une projection mentale collective.",
                "Le sixième cycle s'achèvera quand le témoin final comprendra sa fonction."
            ]
        };
        
        // ==========================================
        // FONCTIONS D'INITIALISATION
        // ==========================================
        
        // Gestion du redimensionnement de la fenêtre
        function onWindowResize() {
            // Mettre à jour la caméra
            window.camera.aspect = window.innerWidth / window.innerHeight;
            window.camera.updateProjectionMatrix();
            
            // Mettre à jour le renderer
            window.renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Initialisation de l'application
        function init() {
            // Créer la scène Three.js
            window.scene = new THREE.Scene();
            
            // Créer la caméra
            window.camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            window.camera.position.set(0, 1, -5);
            
            // Créer le renderer
            window.renderer = new THREE.WebGLRenderer({ antialias: false });
            window.renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(window.renderer.domElement);
            
            // Ajouter une lumière ambiante
            const light = new THREE.AmbientLight(0x444444);
            window.scene.add(light);
            
            // Effet de brouillard pour l'atmosphère
            window.scene.fog = new THREE.FogExp2(0x000000, 0.035);
            
            // Créer le bateau
            window.boat = createBoat();
            
            // Créer le tunnel initial
            for (let i = 0; i < 3; i++) {
                createSegment(i * TUNNEL_LENGTH);
            }
            
            // Gérer le redimensionnement
            window.addEventListener('resize', onWindowResize);
            
            // Configurer le debug et les contrôles de simulation
            setupDebug();
            setupDonationSystem();
            setupVoteSystem();
            
            // Masquer l'écran de chargement
            const loadingScreen = document.getElementById('loading');
            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 500);
            }, 2000);
            
            // Afficher le message d'introduction après un délai
            setTimeout(showNarrativeMessage, 3000, "Bienvenue dans Les Profondeurs. Les portes cachent des secrets. À vous de les découvrir...", 8000);
            
            // Initialiser les variables de narration
            updateMilestoneDisplay();
            
            // Créer le panneau d'objectifs
            createObjectivesPanel();
            
            // Initialiser les panneaux avec défilement automatique (activation directe)
            const historyList = document.getElementById('story-history-list');
            const leaderboardList = document.getElementById('leaderboard-list');
            const top100List = document.getElementById('top100-list');
            
            // Activer l'auto-défilement pour l'historique
            if (historyList) {
                const historyPanel = document.getElementById('story-history-panel');
                if (historyPanel) historyPanel.style.display = 'block';
            }
            
            // Activer l'auto-défilement pour le leaderboard
            if (leaderboardList) {
                const leaderboardPanel = document.getElementById('leaderboard-panel');
                if (leaderboardPanel) leaderboardPanel.style.display = 'block';
            }
            
            // Activer l'auto-défilement pour le top100
            if (top100List) {
                const top100Panel = document.getElementById('top100-panel');
                if (top100Panel) top100Panel.style.display = 'block';
            }
            
            // Ajouter quelques entrées initiales dans l'historique si vide
            if (!window.storyHistory || window.storyHistory.length === 0) {
                addToStoryHistory('milestone', 'Bienvenue dans Les Profondeurs');
                addToStoryHistory('discovery', 'Explorez les tunnels à la recherche d\'indices');
                addToStoryHistory('event', 'Attention aux entités mystérieuses');
            }
            
            // Démarrer l'animation
            animate();
            
            // Ajouter un gestionnaire pour le bouton détails d'exploration
            const detailsButton = document.getElementById('details-button');
            if (detailsButton) {
                detailsButton.addEventListener('click', function() {
                    const detailWindow = window.open('exploration_details.html', '_blank');
                    if (detailWindow) {
                        window.detailWindows.push(detailWindow);
                    }
                });
            }
        }
        
        // Animation de chargement
        function simulateLoading() {
                let progress = 5;
                const loadProgressBar = document.getElementById('load-progress');
                
                const interval = setInterval(() => {
                    progress += Math.floor(Math.random() * 8) + 3;
                    if (progress >= 100) {
                        progress = 100;
                        clearInterval(interval);
                    }
                    loadProgressBar.style.width = progress + '%';
                }, 300);
        }
        
        // Configuration du panneau de debug
        function setupDebug() {
            if (window.location.search.includes('debug=true')) {
                const debugPanel = document.getElementById('debug');
                debugPanel.style.display = 'block';
                
                // Toggle des contrôles avancés
                document.getElementById('toggle-debug').addEventListener('click', () => {
                    const advancedDebug = document.getElementById('advanced-debug');
                    advancedDebug.style.display = advancedDebug.style.display === 'none' ? 'block' : 'none';
                });
                
                // Bouton pour simuler un cadeau/don
                document.getElementById('giftBtn').addEventListener('click', () => {
                    const randomAmount = Math.floor(Math.random() * 100) + 5;
                    simulateDonation("Viewer" + Math.floor(Math.random() * 1000), randomAmount);
                });
                
                // Bouton pour envoyer un commentaire
                document.getElementById('commentBtn').addEventListener('click', () => {
                    const text = document.getElementById('commentInput').value.toLowerCase();
                    handleComment(text);
                    document.getElementById('commentInput').value = '';
                });
                
                // Bouton pour simuler des likes
                document.getElementById('likeBtn').addEventListener('click', () => {
                    // Petit effet visuel
                    window.camera.position.x += (Math.random() - 0.5) * 0.1;
                    window.camera.position.y += (Math.random() - 0.5) * 0.1;
                });
                
                // Contrôles avancés
                document.getElementById('debug-milestone').addEventListener('click', () => {
                    unlockNextMilestone("Debug");
                });
                
                document.getElementById('debug-entity').addEventListener('click', () => {
                    spawnSpecialEntity();
                });
                
                document.getElementById('debug-clue').addEventListener('click', () => {
                    revealRandomClue();
                });
                
                document.getElementById('debug-event').addEventListener('click', () => {
                    triggerSpecialEvent();
                });
                
                document.getElementById('debug-vote').addEventListener('click', () => {
                    startVote();
                });
            }
        }
        
        // Configuration du système de dons
        function setupDonationSystem() {
            // Vérifier si le bouton de simulation de dons existe avant d'ajouter l'écouteur
            const simDonationBtn = document.getElementById('sim-donation');
            if (simDonationBtn) {
                simDonationBtn.addEventListener('click', () => {
                    const amountInput = document.getElementById('donation-amount');
                    const amount = parseInt(amountInput.value);
                    
                    if (amount && amount > 0) {
                        const username = "Viewer" + Math.floor(Math.random() * 10000);
                        simulateDonation(username, amount);
                        amountInput.value = '';
                    }
                });
            }
            
            // Configuration du bouton d'ouverture du simulateur de dons
            const openDonationSimBtn = document.getElementById('open-donation-simulator');
            if (openDonationSimBtn) {
                openDonationSimBtn.addEventListener('click', () => {
                    openDonationSimulator();
                });
            }
            
            // Configuration du bouton d'ouverture de la configuration TikTok
            const openTikTokConfigBtn = document.getElementById('open-tiktok-config');
            if (openTikTokConfigBtn) {
                openTikTokConfigBtn.addEventListener('click', () => {
                    openTikTokConfig();
                });
            }
            
            // Initialisation des valeurs
            updateDonationDisplay();
            
            // Charger la configuration TikTok s'il y en a une
            loadTikTokConfig();
        }
        
        // Fonction pour ouvrir le simulateur de dons (sans créer de fenêtre popup)
        function openDonationSimulator() {
            // Vérifier si un panneau de simulation existe déjà et le supprimer s'il est déjà affiché
            const existingPanel = document.getElementById('inline-donation-panel');
            if (existingPanel) {
                existingPanel.remove();
                return;
            }
            
            // Créer un panneau flottant pour le simulateur de dons intégré
            const panel = document.createElement('div');
            panel.id = 'inline-donation-panel';
            panel.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 300px;
                background: rgba(0, 0, 0, 0.9);
                border: 1px solid #ff3366;
                z-index: 1000;
                padding: 15px;
                color: white;
                border-radius: 5px;
                box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            `;
            
            // Ajouter le contenu du simulateur
            panel.innerHTML = `
                <h3 style="text-align: center; margin-top: 0;">Simulateur de Dons</h3>
                <button id="close-simulator" style="position: absolute; top: 5px; right: 5px; background: none; border: none; color: #fff; cursor: pointer; font-size: 16px;">×</button>
                <div style="margin-bottom: 15px;">
                    <label>Nom d'utilisateur:</label>
                    <input type="text" id="sim-username" value="Utilisateur${Math.floor(Math.random() * 1000)}" style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label>Montant:</label>
                    <input type="number" id="sim-amount" value="5" min="1" max="1000" style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label>Message (optionnel):</label>
                    <input type="text" id="sim-message" placeholder="Message avec votre don..." style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <button id="donate-2" style="flex: 1; margin-right: 5px; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+2€</button>
                    <button id="donate-5" style="flex: 1; margin-right: 5px; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+5€</button>
                    <button id="donate-10" style="flex: 1; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+10€</button>
                </div>
                <button id="send-donation" style="width: 100%; margin-top: 15px; background: #ff3366; border: none; color: white; padding: 10px; cursor: pointer;">Simuler le Don</button>
            `;
            
            // Ajouter le panneau au document
            document.body.appendChild(panel);
            
            // Gérer la fermeture du panneau
            document.getElementById('close-simulator').addEventListener('click', () => {
                panel.remove();
            });
            
            // Gérer les boutons de montant prédéfinis
            document.getElementById('donate-2').addEventListener('click', () => {
                document.getElementById('sim-amount').value = "2";
            });
            
            document.getElementById('donate-5').addEventListener('click', () => {
                document.getElementById('sim-amount').value = "5";
            });
            
            document.getElementById('donate-10').addEventListener('click', () => {
                document.getElementById('sim-amount').value = "10";
            });
            
            // Gérer l'envoi du don
            document.getElementById('send-donation').addEventListener('click', async () => {
                const username = document.getElementById('sim-username').value || `Utilisateur${Math.floor(Math.random() * 1000)}`;
                const amount = parseFloat(document.getElementById('sim-amount').value) || 5;
                const message = document.getElementById('sim-message').value || '';
                
                if (amount <= 0) {
                    alert('Veuillez entrer un montant positif.');
                    return;
                }
                
                try {
                    // Simuler le don via l'API
                    const response = await fetch('/api/simulate/donation', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ username, amount, message })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        // Fermer le panneau après un don réussi
                        panel.remove();
                        
                        // Appliquer directement le don à l'interface actuelle
                        simulateDonation(username, amount);
                    } else {
                        console.error('Erreur lors de la simulation du don:', data.message);
                        alert('Erreur lors de la simulation du don: ' + data.message);
                    }
                } catch (error) {
                    console.error('Erreur lors de la simulation du don:', error);
                    alert('Erreur lors de la simulation du don.');
                }
            });
        }
        
        // Ouvrir la page de configuration de l'API TikTok
        function openTikTokConfig() {
            const width = 800;
            const height = 700;
            const left = (window.innerWidth - width) / 2;
            const top = (window.innerHeight - height) / 2;
            
            const popup = window.open('tiktok_api_config.html', 'TikTokConfig', 
                `width=${width},height=${height},left=${left},top=${top},resizable=yes`);
            
            if (popup) {
                window.tikTokConfigPopup = popup;
            }
        }
        
        // Charger la configuration TikTok depuis localStorage
        function loadTikTokConfig() {
            const savedConfig = localStorage.getItem('tiktokApiConfig');
            
            if (savedConfig) {
                try {
                    window.tikTokConfig = JSON.parse(savedConfig);
                    console.log('Configuration TikTok chargée:', window.tikTokConfig);
                } catch (error) {
                    console.error('Erreur lors du chargement de la configuration TikTok:', error);
                }
            }
        }
        
        // Mettre à jour la configuration TikTok (appelé depuis la page de configuration)
        function updateTikTokConfig(config) {
            window.tikTokConfig = config;
            console.log('Configuration TikTok mise à jour:', config);
        }
        
        // Traiter un événement TikTok (appelé depuis la page de configuration ou par l'API)
        function processTikTokEvent(event) {
            console.log('Événement TikTok reçu:', event);
            
            switch (event.type) {
                case 'donation':
                    // Convertir le montant en pièces/diamants en euros
                    const convertedAmount = event.convertedAmount || 
                        (event.amount * (window.tikTokConfig?.donationConversion || 0.01));
                    
                    // Simuler un don avec le montant converti
                    simulateDonation(event.username, convertedAmount, event.giftName || 'Don TikTok');
                    
                    // Amélioration: Vérifier si c'est un don majeur pour des effets spéciaux
                    if (convertedAmount >= 50) {
                        triggerSpecialEvent(event.username);
                    } else if (convertedAmount >= 20) {
                        spawnSpecialEntity();
                    }
                    break;
                    
                case 'subscription':
                    // Traiter l'abonnement comme un don avec un montant fixe
                    const subValue = event.value || 
                        (window.tikTokConfig?.subscriptionValue || 4.99);
                    
                    simulateDonation(event.username, subValue, 'Abonnement');
                    
                    // Amélioration: Ajouter un indice spécial pour les abonnés
                    revealSpecialClue(event.username);
                    break;
                    
                case 'comment':
                    // Traiter les commentaires pour détecter les mots-clés
                    if (window.tikTokConfig?.enableComments) {
                        handleComment(event.comment, event.username);
                    }
                    break;
                    
                case 'follow':
                    // Ajouter au journal d'exploration
                    addToStoryHistory('event', `${event.username} suit maintenant le stream!`);
                    break;
                    
                case 'share':
                    // Récompenser le partage avec un petit don virtuel
                    simulateDonation(event.username, 1, 'Partage');
                    
                    // Ajouter au journal d'exploration
                    addToStoryHistory('event', `${event.username} a partagé le stream!`);
                    break;
                    
                case 'like':
                    // Reconnaître les likes en masse
                    if (event.likeCount && event.likeCount > 5) {
                        // Déclencher des effets mineurs d'ambiance
                        triggerAmbientEffect(event.likeCount);
                        
                        // Ajouter au journal d'exploration pour les likes importants
                        addToStoryHistory('event', `${event.username} a envoyé ${event.likeCount} likes!`);
                    }
                    break;
                    
                case 'importantComment':
                    // Traiter les commentaires importants spécifiquement
                    handleImportantComment(event.comment, event.username);
                    break;
                    
                case 'memberJoin':
                    // Membre rejoignant le stream
                    addToStoryHistory('discovery', `${event.username} a rejoint l'exploration!`);
                    break;
            }
        }
        
        // Fonction pour révéler un indice spécial aux abonnés
        function revealSpecialClue(username) {
            // Sélectionner un indice pas encore découvert
            const unrevealedClues = STORY_ELEMENTS.clues.filter(clue => !window.discoveredClues.includes(clue.id));
            
            if (unrevealedClues.length > 0) {
                const randomIndex = Math.floor(Math.random() * unrevealedClues.length);
                const clue = unrevealedClues[randomIndex];
                
                // Révéler un indice pour l'utilisateur
                revealClue(clue.id, username);
                
                // Ajouter un message spécial dans le journal
                addToStoryHistory('discovery', `Indice spécial révélé à ${username}: "${clue.text}"`);
            }
        }
        
        // Fonction pour gérer les commentaires importants
        function handleImportantComment(comment, username) {
            // Évaluer si le commentaire contient des mots-clés liés à l'histoire
            const storyKeywords = [
                'mystère', 'créature', 'secret', 'porte', 'symbole', 'code', 
                'énigme', 'indice', 'lumière', 'ombre', 'profondeur',
                'abîme', 'portail', 'anciens', 'artefact', 'clé'
            ];
            
            const lowerComment = comment.toLowerCase();
            const matchedKeywords = storyKeywords.filter(keyword => lowerComment.includes(keyword));
            
            if (matchedKeywords.length >= 2) {
                // Commentaire très pertinent pour l'histoire
                addToStoryHistory('discovery', `Observation de ${username}: "${comment}"`);
                
                // Potentiellement révéler un indice basé sur ce commentaire
                if (Math.random() < 0.3) {
                    // 30% de chance de révéler un indice
                    setTimeout(() => {
                        revealRandomClue(username);
                    }, 3000 + Math.random() * 5000);
                }
                
                // Pour les commentaires très pertinents, ajouter un effet visuel subtil
                flashCameraEffect(0.3);
            }
        }
        
        // Fonction pour déclencher des effets d'ambiance basés sur l'activité TikTok
        function triggerAmbientEffect(intensity) {
            // L'intensité représente combien l'effet doit être prononcé, basé sur les likes/interactions
            intensity = Math.min(intensity / 10, 1.0); // Normaliser entre 0 et 1
            
            // Types d'effets d'ambiance
            const effects = [
                'flicker', // Effet de vacillement des lumières
                'ripple',  // Effet d'ondulation sur l'eau
                'mist',    // Effet de brume temporaire
                'whisper'  // Sons subtils d'ambiance
            ];
            
            // Sélectionner un effet aléatoire
            const effect = effects[Math.floor(Math.random() * effects.length)];
            
            // Appliquer l'effet selon le type
            switch (effect) {
                case 'flicker':
                    // Faire vaciller les lumières dans le tunnel
                    flickerLights(intensity);
                    break;
                case 'ripple':
                    // Créer des ondulations sur l'eau
                    createWaterRipple(intensity);
                    break;
                case 'mist':
                    // Ajouter une brume temporaire
                    addTemporaryMist(intensity);
                    break;
                case 'whisper':
                    // Jouer des sons d'ambiance
                    playAmbientSound(intensity);
                    break;
            }
        }
        
        // Faire vaciller les lumières du tunnel
        function flickerLights(intensity) {
            // Trouver toutes les lumières dans la scène
            const lights = [];
            window.scene.traverse(function(object) {
                if (object.userData && object.userData.light) {
                    lights.push(object.userData.light);
                }
            });
            
            // Aucune lumière trouvée
            if (lights.length === 0) return;
            
            // Sauvegarder les intensités d'origine
            const originalIntensities = lights.map(light => light.intensity);
            
            // Nombre de vacillements
            const flickerCount = Math.floor(3 + intensity * 7);
            
            // Fonction pour un vacillement aléatoire
            function singleFlicker(index) {
                if (index >= flickerCount) {
                    // Restaurer les intensités d'origine
                    lights.forEach((light, i) => { 
                        if (light) light.intensity = originalIntensities[i]; 
                    });
                    return;
                }
                
                // Appliquer un vacillement aléatoire à chaque lumière
                lights.forEach((light, i) => {
                    if (light) {
                        const randomFactor = 0.3 + Math.random() * 0.7;
                        light.intensity = originalIntensities[i] * randomFactor;
                    }
                });
                
                // Planifier le prochain vacillement
                setTimeout(() => singleFlicker(index + 1), 50 + Math.random() * 150);
            }
            
            // Démarrer la séquence de vacillement
            singleFlicker(0);
        }
        
        // Créer des ondulations sur l'eau
        function createWaterRipple(intensity) {
            if (!window.waterMesh) return;
            
            // Créer un effet d'ondulation sur l'eau
            const rippleDuration = 2000 + intensity * 3000; // 2-5 secondes selon l'intensité
            const startTime = Date.now();
            const originalY = window.waterMesh.position.y;
            
            // Fonction d'animation pour l'ondulation
            function animateRipple() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / rippleDuration;
                
                if (progress >= 1) {
                    // Restaurer la position de l'eau
                    window.waterMesh.position.y = originalY;
                    return;
                }
                
                // Calcul de l'ondulation
                const amplitude = 0.05 * intensity;
                const frequency = 6 + intensity * 4;
                const ripple = amplitude * Math.sin(frequency * progress * Math.PI) * (1 - progress);
                
                // Appliquer l'ondulation
                window.waterMesh.position.y = originalY + ripple;
                
                // Continuer l'animation
                requestAnimationFrame(animateRipple);
            }
            
            // Démarrer l'animation
            animateRipple();
        }
        
        // Ajouter de la brume temporaire
        function addTemporaryMist(intensity) {
            // Vérifier si la brume existe déjà
            if (window.mistMesh) return;
            
            // Créer une sphère de brume semi-transparente
            const mistGeometry = new THREE.SphereGeometry(10, 16, 16);
            const mistMaterial = new THREE.MeshBasicMaterial({
                color: 0xccccff,
                transparent: true,
                opacity: 0
            });
            
            const mistMesh = new THREE.Mesh(mistGeometry, mistMaterial);
            mistMesh.position.set(window.boat.position.x, 0, window.boat.position.z);
            window.scene.add(mistMesh);
            window.mistMesh = mistMesh;
            
            // Durée de la brume
            const mistDuration = 3000 + intensity * 4000; // 3-7 secondes
            const startTime = Date.now();
            
            // Fonction d'animation pour la brume
            function animateMist() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / mistDuration;
                
                if (progress >= 1) {
                    // Supprimer la brume
                    window.scene.remove(mistMesh);
                    window.mistMesh = null;
                    return;
                }
                
                // Animation de l'opacité (apparition puis disparition)
                let opacity;
                if (progress < 0.3) {
                    // Apparition
                    opacity = (progress / 0.3) * 0.3 * intensity;
                } else if (progress > 0.7) {
                    // Disparition
                    opacity = ((1 - progress) / 0.3) * 0.3 * intensity;
                } else {
                    // Plateau
                    opacity = 0.3 * intensity;
                }
                
                // Appliquer l'opacité
                mistMaterial.opacity = opacity;
                
                // Continuer l'animation
                requestAnimationFrame(animateMist);
            }
            
            // Démarrer l'animation
            animateMist();
        }
        
        // Jouer un son d'ambiance
        function playAmbientSound(intensity) {
            // Si le son est désactivé, ne rien faire
            if (!window.audioEnabled) return;
            
            // Sélectionner un son d'ambiance aléatoire
            const ambientSounds = [
                'whisper', 'creak', 'drip', 'distant_echo'
            ];
            
            const sound = ambientSounds[Math.floor(Math.random() * ambientSounds.length)];
            const volume = 0.1 + intensity * 0.2; // Volume entre 0.1 et 0.3
            
            // Créer un élément audio
            const audio = new Audio();
            audio.volume = volume;
            
            // Définir la source du son
            switch (sound) {
                case 'whisper':
                    audio.src = 'sounds/whisper.mp3';
                    break;
                case 'creak':
                    audio.src = 'sounds/creak.mp3';
                    break;
                case 'drip':
                    audio.src = 'sounds/drip.mp3';
                    break;
                case 'distant_echo':
                    audio.src = 'sounds/echo.mp3';
                    break;
            }
            
            // Jouer le son
            try {
                audio.play().catch(error => {
                    console.warn('Impossible de jouer le son:', error);
                });
            } catch (error) {
                console.warn('Erreur lors de la lecture du son:', error);
            }
        }
        
        // Configuration du système de vote
        function setupVoteSystem() {
            // Gestion des clics sur les options de vote
            document.querySelectorAll('.vote-option').forEach(option => {
                option.addEventListener('click', (e) => {
                    const optionIndex = e.currentTarget.getAttribute('data-option');
                    voteForOption(optionIndex);
                });
            });
        }
        
        // ==========================================
        // FONCTIONS DE CRÉATION D'OBJETS 3D
        // ==========================================
        
        // Créer une barque avec un modèle Three.js détaillé
        function createBoat() {
            const boat = new THREE.Group();
            
            // Coque principale - forme d'une barque traditionnelle
            const hullShape = new THREE.Shape();
            // Définir un contour en forme de barque vue de dessus
            hullShape.moveTo(-0.7, -1.2);
            hullShape.quadraticCurveTo(-0.2, -1.5, 0, -1.5);
            hullShape.quadraticCurveTo(0.2, -1.5, 0.7, -1.2);
            hullShape.quadraticCurveTo(0.9, -0.8, 0.9, 0);
            hullShape.quadraticCurveTo(0.9, 0.8, 0.7, 1.2);
            hullShape.quadraticCurveTo(0.2, 1.5, 0, 1.5);
            hullShape.quadraticCurveTo(-0.2, 1.5, -0.7, 1.2);
            hullShape.quadraticCurveTo(-0.9, 0.8, -0.9, 0);
            hullShape.quadraticCurveTo(-0.9, -0.8, -0.7, -1.2);
            
            // Extruder la forme pour créer la coque 3D
            const extrudeSettings = {
                steps: 2,
                depth: 0.5,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.1,
                bevelOffset: 0,
                bevelSegments: 3
            };
            
            const hullGeometry = new THREE.ExtrudeGeometry(hullShape, extrudeSettings);
            
            // Créer un matériau pour la coque avec texture de bois
            const hullMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.7,
                metalness: 0.2
            });
            
            // Créer un effet de veine de bois (procédural)
            const woodTexture = createWoodTexture();
            hullMaterial.map = woodTexture;
            
            const hull = new THREE.Mesh(hullGeometry, hullMaterial);
            hull.rotation.x = Math.PI / 2; // Orienter correctement la barque
            boat.add(hull);
            
            // Ajouter des bancs transversaux
            const benchMaterial = new THREE.MeshStandardMaterial({
                color: 0x964B00,
                roughness: 0.8,
                metalness: 0.1
            });
            
            // Banc avant
            const frontBenchGeometry = new THREE.BoxGeometry(1.4, 0.1, 0.25);
            const frontBench = new THREE.Mesh(frontBenchGeometry, benchMaterial);
            frontBench.position.set(0, 0.3, 0.9);
            boat.add(frontBench);
            
            // Banc arrière
            const backBenchGeometry = new THREE.BoxGeometry(1.4, 0.1, 0.25);
            const backBench = new THREE.Mesh(backBenchGeometry, benchMaterial);
            backBench.position.set(0, 0.3, -0.9);
            boat.add(backBench);
            
            // Banc milieu
            const middleBenchGeometry = new THREE.BoxGeometry(1.4, 0.1, 0.25);
            const middleBench = new THREE.Mesh(middleBenchGeometry, benchMaterial);
            middleBench.position.set(0, 0.3, 0);
            boat.add(middleBench);
            
            // Ajouter une lanterne pour l'ambiance
            const lanternBase = new THREE.CylinderGeometry(0.05, 0.05, 0.2, 8);
            const lanternGlobe = new THREE.SphereGeometry(0.1, 8, 8);
            const lanternMaterial = new THREE.MeshStandardMaterial({
                color: 0x553311,
                roughness: 0.5
            });
            const lanternGlassMaterial = new THREE.MeshStandardMaterial({
                color: 0xffaa55,
                emissive: 0xff6622,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.7
            });
            
            const lanternBaseObj = new THREE.Mesh(lanternBase, lanternMaterial);
            const lanternGlobeObj = new THREE.Mesh(lanternGlobe, lanternGlassMaterial);
            lanternGlobeObj.position.y = 0.15;
            
            const lantern = new THREE.Group();
            lantern.add(lanternBaseObj);
            lantern.add(lanternGlobeObj);
            lantern.position.set(0, 0.4, 0.9);
            boat.add(lantern);
            
            // Ajouter une lumière dans la lanterne
            const lanternLight = new THREE.PointLight(0xff6622, 1, 3);
            lanternLight.position.set(0, 0.15, 0);
            lantern.add(lanternLight);
            
            // Position et échelle finale de la barque
            boat.scale.set(0.7, 0.7, 0.7);
            boat.position.y = WATER_LEVEL + 0.4;
            window.scene.add(boat);
            
            // Variables pour l'animation narrative de la barque
            boat.userData = {
                lanternLight: lanternLight,
                lanternOriginalIntensity: 1,
                narrativeState: "normal"
            };
            
            return boat;
        }
        
        // Fonction pour créer une texture de bois
        function createWoodTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            
            // Fond
            context.fillStyle = "#8B4513";
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Veines de bois
            for (let i = 0; i < 30; i++) {
                // Position et épaisseur variables
                const y = Math.random() * canvas.height;
                const width = 1 + Math.random() * 3;
                
                // Couleur de veine légèrement variable
                const brightness = 100 + Math.floor(Math.random() * 50);
                const color = `rgb(${brightness}, ${brightness * 0.6}, ${brightness * 0.4})`;
                
                context.beginPath();
                context.moveTo(0, y);
                
                // Créer une ligne ondulée
                for (let x = 0; x < canvas.width; x += canvas.width/20) {
                    const newY = y + (Math.random() - 0.5) * 15;
                    context.lineTo(x, newY);
                }
                
                context.strokeStyle = color;
                context.lineWidth = width;
                context.stroke();
            }
            
            // Noeuds du bois
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 3 + Math.random() * 8;
                
                const gradient = context.createRadialGradient(x, y, 1, x, y, radius);
                gradient.addColorStop(0, "#4B2809");
                gradient.addColorStop(1, "#8B4513");
                
                context.beginPath();
                context.arc(x, y, radius, 0, Math.PI * 2);
                context.fillStyle = gradient;
                context.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }
        
        // Créer un segment de tunnel avec rebords et portes
        function createSegment(zPosition) {
            const segment = new THREE.Group();
            segment.position.z = zPosition;
            
            // Tunnel principal
            const tunnelGeometry = new THREE.CylinderGeometry(
                TUNNEL_RADIUS, TUNNEL_RADIUS, TUNNEL_LENGTH, 16, 1, true
            );
            const tunnelMaterial = new THREE.MeshPhongMaterial({
                color: 0x333333, 
                side: THREE.BackSide
            });
            const tunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
            tunnel.rotation.x = Math.PI / 2;
            segment.add(tunnel);
            
            // Sol/eau au centre
            const waterWidth = TUNNEL_RADIUS * 1.2; // Réduire pour laisser de la place aux rebords
            const floorGeometry = new THREE.PlaneGeometry(
                waterWidth, TUNNEL_LENGTH
            );
            const waterMaterial = new THREE.MeshPhongMaterial({
                color: 0x006666,
                transparent: true,
                opacity: 0.7
            });
            const floor = new THREE.Mesh(floorGeometry, waterMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = WATER_LEVEL;
            segment.add(floor);
            
            // Ajouter un effet de miroitement à l'eau
            segment.userData.water = floor;
            segment.userData.waterBaseColor = new THREE.Color(0x006666);
            
            // Ajouter des rebords et des portes régulièrement
            for (let z = 0; z < TUNNEL_LENGTH; z += 5) {
                // Position en z
                const doorZ = z - TUNNEL_LENGTH / 2;
                
                // Déterminer si cette porte est spéciale (narrative)
                const isSpecialDoor = Math.random() < 0.05 + (window.storyProgress * 0.02);
                
                // Porte gauche
                const leftDoor = createDoor(isSpecialDoor);
                leftDoor.position.set(-TUNNEL_RADIUS + 0.2, WATER_LEVEL + 1.5, doorZ);
                leftDoor.rotation.y = Math.PI/2; // Rotation pour que la porte soit perpendiculaire à la paroi du tunnel
                leftDoor.rotation.z = 0; // Assurer que la porte est verticale
                segment.add(leftDoor);
                
                if (isSpecialDoor) {
                    registerSpecialDoor(leftDoor);
                }
                
                window.doors.push(leftDoor);
                
                // Porte droite - perpendiculaire à la paroi et verticale
                const rightDoor = createDoor(isSpecialDoor);
                rightDoor.position.set(TUNNEL_RADIUS - 0.2, WATER_LEVEL + 1.5, doorZ);
                rightDoor.rotation.y = -Math.PI/2; // Rotation pour que la porte soit perpendiculaire à la paroi du tunnel
                rightDoor.rotation.z = 0; // Assurer que la porte est verticale
                segment.add(rightDoor);
                
                if (isSpecialDoor) {
                    registerSpecialDoor(rightDoor);
                }
                
                window.doors.push(rightDoor);
                
                // Rebords pour marcher (gauche et droite)
                createWalkway(segment, -TUNNEL_RADIUS + 0.6, WATER_LEVEL + 0.1, doorZ - 2.5, 5);
                createWalkway(segment, TUNNEL_RADIUS - 0.6, WATER_LEVEL + 0.1, doorZ - 2.5, 5);
                
                // Lumières murales
                createWallLight(segment, -TUNNEL_RADIUS + 0.1, WATER_LEVEL + 2, doorZ - 1.5);
                createWallLight(segment, TUNNEL_RADIUS - 0.1, WATER_LEVEL + 2, doorZ - 1.5);
            }
            
            // Lumière générale du tunnel (faible)
            const ambientLight = new THREE.PointLight(0x333333, 0.3, TUNNEL_RADIUS * 2);
            ambientLight.position.set(0, 0, 0);
            segment.add(ambientLight);
            
            // Stocker la position et les données supplémentaires
            segment.userData = { 
                ...segment.userData,
                zPosition: zPosition,
                narrativeZone: determineNarrativeZone(zPosition),
                ambientLight: ambientLight
            };
            
            window.scene.add(segment);
            window.segments.push(segment);
            return segment;
        }
        
        // Créer un rebord pour marcher
        function createWalkway(parent, x, y, z, length) {
            // Plateforme pour marcher
            const walkwayGeometry = new THREE.BoxGeometry(1, 0.2, length);
            const walkwayMaterial = new THREE.MeshPhongMaterial({color: 0x555555});
            const walkway = new THREE.Mesh(walkwayGeometry, walkwayMaterial);
            walkway.position.set(x, y, z + length/2);
            parent.add(walkway);
            
            // Support métallique
            for (let i = 0; i < length; i += 1.5) {
                const supportGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 6);
                const supportMaterial = new THREE.MeshPhongMaterial({color: 0x777777});
                const support = new THREE.Mesh(supportGeometry, supportMaterial);
                support.position.set(x, y - 0.35, z + i);
                parent.add(support);
            }
            
            return walkway;
        }
        
        // Créer une lumière murale
        function createWallLight(parent, x, y, z) {
            // Groupe pour la lumière
            const lightGroup = new THREE.Group();
            lightGroup.position.set(x, y, z);
            
            // Support mural
            const baseGeometry = new THREE.BoxGeometry(0.1, 0.3, 0.3);
            const baseMaterial = new THREE.MeshPhongMaterial({color: 0x333333});
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            
            // Orientation selon le côté
            if (x < 0) { // Côté gauche
                base.rotation.y = 0;
                lightGroup.rotation.y = 0;
            } else { // Côté droit
                base.rotation.y = Math.PI;
                lightGroup.rotation.y = Math.PI;
            }
            
            lightGroup.add(base);
            
            // Ampoule/Globe
            const bulbGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            
            // La couleur varie en fonction de la progression de l'histoire
            const colorProgress = Math.min(window.storyProgress, 1);
            const bulbColor = new THREE.Color().setHSL(
                0.1 - (colorProgress * 0.1), // De jaune vers rouge
                0.7,
                0.5 + (colorProgress * 0.2) // Devient plus brillant
            );
            
            const bulbMaterial = new THREE.MeshBasicMaterial({
                color: bulbColor
                // emissive et emissiveIntensity sont retirés car non supportés par MeshBasicMaterial
            });
            
            const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
            bulb.position.x = (x < 0) ? 0.1 : -0.1; // Position selon le côté
            lightGroup.add(bulb);
            
            // Lumière
            const intensity = 0.5 + Math.random() * 0.5;
            const light = new THREE.PointLight(bulbColor, intensity, 3);
            light.position.copy(bulb.position);
            lightGroup.add(light);
            
            // Ajouter des données pour les animations
            lightGroup.userData = {
                bulb: bulb,
                light: light,
                originalIntensity: intensity,
                flicker: Math.random() < 0.3, // 30% de chance de scintillement
                flickerSpeed: 0.5 + Math.random() * 2,
                originalColor: bulbColor.clone()
            };
            
            parent.add(lightGroup);
            return lightGroup;
        }
        
        // Créer une porte avec une orientation correcte et thématique
        function createDoor(isSpecial = false) {
            const door = new THREE.Group();
            
            // Couleurs différentes selon le type de porte
            let doorColor, frameColor, detailsColor;
            let doorSymbol = null;
            
            if (isSpecial) {
                // Porte spéciale avec couleur et caractéristiques uniques
                const specialType = Math.floor(Math.random() * 5);
                
                switch(specialType) {
                    case 0: // Porte mystérieuse avec symboles
                        frameColor = 0x443322;
                        doorColor = 0x221100;
                        detailsColor = 0xaa8866;
                        doorSymbol = "symbol";
                        break;
                    case 1: // Porte rouge sang
                        frameColor = 0x662222;
                        doorColor = 0x990000;
                        detailsColor = 0xaa3333;
                        doorSymbol = "blood";
                        break;
                    case 2: // Porte luminescente
                        frameColor = 0x443355;
                        doorColor = 0x334466;
                        detailsColor = 0x88aaff;
                        doorSymbol = "glow";
                        break;
                    case 3: // Porte métallique rouillée
                        frameColor = 0x775533;
                        doorColor = 0x996633;
                        detailsColor = 0xcc8844;
                        doorSymbol = "rust";
                        break;
                    case 4: // Porte avec marques de griffes
                        frameColor = 0x554433;
                        doorColor = 0x443322;
                        detailsColor = 0x333333;
                        doorSymbol = "claw";
                        break;
                }
            } else {
                // Porte standard
                frameColor = 0x553322;
                doorColor = 0x332211;
                detailsColor = 0x888888;
            }
            
            // Cadre de porte
            const frameGeometry = new THREE.BoxGeometry(2, 3, 0.2);
            const frameMaterial = new THREE.MeshPhongMaterial({color: frameColor});
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            door.add(frame);
            
            // La porte elle-même (panneau)
            const doorGeometry = new THREE.BoxGeometry(1.8, 2.8, 0.1);
            const doorMaterial = new THREE.MeshPhongMaterial({color: doorColor});
            const doorMesh = new THREE.Mesh(doorGeometry, doorMaterial);
            // Positionner la porte correctement pour l'animation
            doorMesh.position.z = -0.15; 
            door.add(doorMesh);
            
            // Poignée de porte
            const handleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const handleMaterial = new THREE.MeshPhongMaterial({color: detailsColor});
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.set(0.5, 0, -0.15); // À droite de la porte vue de face
            door.add(handle);
            
            // Ajout de numéro ou symbole de porte
            const doorNumber = Math.floor(Math.random() * 900) + 100;
            
            // Plaque de numéro/symbole
            const plateGeometry = new THREE.PlaneGeometry(0.4, 0.2);
            const plateMaterial = new THREE.MeshPhongMaterial({
                color: detailsColor,
                side: THREE.DoubleSide
            });
            const plate = new THREE.Mesh(plateGeometry, plateMaterial);
            plate.position.set(0, 1, -0.11);
            door.add(plate);
            
            // Ajouter un symbole spécial si c'est une porte spéciale
            if (isSpecial && doorSymbol) {
                // Créer le symbole selon le type
                switch(doorSymbol) {
                    case "symbol":
                        // Ajouter un symbole ésotérique
                        addSymbolToDoor(door, plate);
                        break;
                    case "blood":
                        // Ajouter des taches de sang
                        addBloodToDoor(door, doorMesh);
                        break;
                    case "glow":
                        // Ajouter un effet lumineux
                        addGlowToDoor(door, doorMesh);
                        break;
                    case "rust":
                        // Ajouter des taches de rouille
                        addRustToDoor(door, doorMesh);
                        break;
                    case "claw":
                        // Ajouter des marques de griffes
                        addClawMarksToDoor(door, doorMesh);
                        break;
                }
            }
            
            // Données pour l'animation et statut narratif
            door.userData = {
                doorMesh: doorMesh,
                animating: false,
                doorNumber: doorNumber,
                isSpecial: isSpecial,
                doorSymbol: doorSymbol,
                activated: false,
                containsClue: isSpecial && (Math.random() < 0.6), // 60% des portes spéciales contiennent un indice
                containsEntity: isSpecial && (Math.random() < 0.3), // 30% des portes spéciales contiennent une entité
                entityType: isSpecial ? Math.floor(Math.random() * 7) : null,
                narrativeElement: null
            };
            
            return door;
        }
        
        // Ajouter un symbole ésotérique à une porte
        function addSymbolToDoor(door, plate) {
            // Créer un canvas pour dessiner le symbole
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Fond transparent
            ctx.fillStyle = 'rgba(0, 0, 0, 0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Choisir un symbole aléatoire
            const symbolType = Math.floor(Math.random() * 5);
            
            // Dessiner le symbole en blanc
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.fillStyle = 'white';
            
            switch(symbolType) {
                case 0: // Cercle avec triangle
                    ctx.beginPath();
                    ctx.arc(64, 64, 40, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(64, 34);
                    ctx.lineTo(94, 94);
                    ctx.lineTo(34, 94);
                    ctx.closePath();
                    ctx.stroke();
                    break;
                    
                case 1: // Spirale
                    ctx.beginPath();
                    let radius = 5;
                    let angle = 0;
                    let x = 64;
                    let y = 64;
                    
                    for (let i = 0; i < 200; i++) {
                        angle += 0.1;
                        radius += 0.2;
                        const newX = 64 + Math.cos(angle) * radius;
                        const newY = 64 + Math.sin(angle) * radius;
                        ctx.lineTo(newX, newY);
                        x = newX;
                        y = newY;
                        
                        if (radius > 40) break;
                    }
                    ctx.stroke();
                    break;
                    
                case 2: // Œil
                    ctx.beginPath();
                    ctx.ellipse(64, 64, 45, 25, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(64, 64, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(64, 39);
                    ctx.lineTo(64, 89);
                    ctx.stroke();
                    break;
                    
                case 3: // Runes
                    for (let i = 0; i < 3; i++) {
                        const startX = 34 + i * 30;
                        ctx.beginPath();
                        
                        // Runes aléatoires
                        switch(Math.floor(Math.random() * 5)) {
                            case 0: // F-like
                                ctx.moveTo(startX, 44);
                                ctx.lineTo(startX, 94);
                                ctx.moveTo(startX, 44);
                                ctx.lineTo(startX + 20, 44);
                                ctx.moveTo(startX, 69);
                                ctx.lineTo(startX + 15, 69);
                                break;
                            case 1: // X-like
                                ctx.moveTo(startX - 10, 44);
                                ctx.lineTo(startX + 10, 94);
                                ctx.moveTo(startX + 10, 44);
                                ctx.lineTo(startX - 10, 94);
                                break;
                            case 2: // O with line
                                ctx.arc(startX, 69, 25, 0, Math.PI * 2);
                                ctx.moveTo(startX - 25, 69);
                                ctx.lineTo(startX + 25, 69);
                                break;
                            case 3: // Arrow
                                ctx.moveTo(startX, 44);
                                ctx.lineTo(startX, 94);
                                ctx.moveTo(startX - 10, 54);
                                ctx.lineTo(startX, 44);
                                ctx.lineTo(startX + 10, 54);
                                break;
                            case 4: // Wave
                                ctx.moveTo(startX - 15, 69);
                                for (let j = 0; j < 30; j++) {
                                    ctx.lineTo(startX - 15 + j, 69 + Math.sin(j * 0.3) * 15);
                                }
                                break;
                        }
                        
                        ctx.stroke();
                    }
                    break;
                    
                case 4: // Constellation
                    // Points
                    const points = [];
                    for (let i = 0; i < 7; i++) {
                        points.push({
                            x: 30 + Math.random() * 68,
                            y: 30 + Math.random() * 68,
                            r: 2 + Math.random() * 3
                        });
                    }
                    
                    // Dessiner les points
                    points.forEach(point => {
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, point.r, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Relier certains points
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) {
                        if (Math.random() < 0.7) { // 70% de chance de relier deux points
                            ctx.lineTo(points[i].x, points[i].y);
                        } else {
                            ctx.moveTo(points[i].x, points[i].y);
                        }
                    }
                    ctx.stroke();
                    break;
            }
            
            // Créer une texture à partir du canvas
            const symbolTexture = new THREE.CanvasTexture(canvas);
            
            // Créer un matériau avec cette texture
            const symbolMaterial = new THREE.MeshBasicMaterial({
                map: symbolTexture,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            
            // Remplacer le matériau de la plaque
            plate.material = symbolMaterial;
            
            // Agrandir la plaque pour le symbole
            plate.scale.set(2, 2, 1);
            
            // Stocker les données pour animation
            door.userData.symbolType = symbolType;
            door.userData.symbolTexture = symbolTexture;
        }
        
        // Ajouter des taches de sang à une porte
        function addBloodToDoor(door, doorMesh) {
            // Créer un canvas pour dessiner les taches
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Copier la couleur de base de la porte
            ctx.fillStyle = '#990000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner des taches de sang aléatoires
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 10 + Math.random() * 50;
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, 'rgba(120, 0, 0, 0.9)');
                gradient.addColorStop(0.7, 'rgba(80, 0, 0, 0.6)');
                gradient.addColorStop(1, 'rgba(80, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Dessiner des traînées de sang coulant
            for (let i = 0; i < 5; i++) {
                const startX = Math.random() * canvas.width;
                const startY = Math.random() * (canvas.height / 2); // Commencer dans la moitié supérieure
                
                ctx.strokeStyle = 'rgba(100, 0, 0, 0.8)';
                ctx.lineWidth = 3 + Math.random() * 8;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                
                let currentX = startX;
                let currentY = startY;
                
                // Créer une ligne descendante avec zigzags aléatoires
                const length = 50 + Math.random() * 200;
                for (let j = 0; j < length; j += 10) {
                    currentY += 10;
                    currentX += (Math.random() - 0.5) * 15;
                    
                    // Réduire progressivement l'épaisseur de la ligne
                    ctx.lineWidth = Math.max(1, ctx.lineWidth - 0.2);
                    
                    ctx.lineTo(currentX, currentY);
                    
                    if (currentY > canvas.height) break;
                }
                
                ctx.stroke();
            }
            
            // Créer une texture à partir du canvas
            const bloodTexture = new THREE.CanvasTexture(canvas);
            
            // Appliquer la texture à la porte
            const bloodMaterial = new THREE.MeshStandardMaterial({
                map: bloodTexture,
                color: 0x990000,
                roughness: 0.7,
                metalness: 0.2
            });
            
            doorMesh.material = bloodMaterial;
        }
        
        // Ajouter un effet lumineux à une porte
        function addGlowToDoor(door, doorMesh) {
            // Créer un matériau avec émission pour l'effet lumineux
            const glowMaterial = new THREE.MeshStandardMaterial({
                color: 0x334466,
                emissive: 0x88aaff,
                emissiveIntensity: 0.5,
                roughness: 0.4,
                metalness: 0.6
            });
            
            doorMesh.material = glowMaterial;
            
            // Ajouter une lumière pour renforcer l'effet
            const glowLight = new THREE.PointLight(0x88aaff, 0.8, 1);
            glowLight.position.set(0, 0, -0.1);
            doorMesh.add(glowLight);
            
            // Stocker la lumière pour l'animation
            door.userData.glowLight = glowLight;
            door.userData.originalIntensity = 0.8;
        }
        
        // Ajouter des taches de rouille à une porte
        function addRustToDoor(door, doorMesh) {
            // Créer un canvas pour dessiner la rouille
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Couleur de base métallique
            ctx.fillStyle = '#996633';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Ajouter une texture métallique de base
            for (let i = 0; i < 20; i++) {
                ctx.strokeStyle = `rgba(153, 122, 102, ${Math.random() * 0.3})`;
                ctx.lineWidth = 1 + Math.random() * 2;
                
                ctx.beginPath();
                ctx.moveTo(0, Math.random() * canvas.height);
                ctx.lineTo(canvas.width, Math.random() * canvas.height);
                ctx.stroke();
            }
            
            // Ajouter des taches de rouille
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 5 + Math.random() * 40;
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, 'rgba(180, 60, 20, 0.9)');
                gradient.addColorStop(0.6, 'rgba(160, 80, 30, 0.6)');
                gradient.addColorStop(1, 'rgba(153, 102, 51, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Ajouter quelques trous de rouille
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 2 + Math.random() * 6;
                
                ctx.fillStyle = 'rgba(30, 20, 10, 0.8)';
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Ajouter un halo de rouille intense autour du trou
                const holeGradient = ctx.createRadialGradient(x, y, radius, x, y, radius * 3);
                holeGradient.addColorStop(0, 'rgba(180, 60, 20, 0.9)');
                holeGradient.addColorStop(1, 'rgba(180, 60, 20, 0)');
                
                ctx.fillStyle = holeGradient;
                ctx.beginPath();
                ctx.arc(x, y, radius * 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Créer une texture à partir du canvas
            const rustTexture = new THREE.CanvasTexture(canvas);
            
            // Appliquer la texture à la porte
            const rustMaterial = new THREE.MeshStandardMaterial({
                map: rustTexture,
                roughness: 0.9,
                metalness: 0.4
            });
            
            doorMesh.material = rustMaterial;
        }
        
        // Ajouter des marques de griffes à une porte
        function addClawMarksToDoor(door, doorMesh) {
            // Créer un canvas pour dessiner les marques
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Couleur de base de la porte
            ctx.fillStyle = '#443322';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner des marques de griffes
            const clawSets = Math.floor(Math.random() * 3) + 2; // 2-4 sets de griffes
            
            for (let set = 0; set < clawSets; set++) {
                const startX = 50 + Math.random() * (canvas.width - 100);
                const startY = 50 + Math.random() * (canvas.height - 100);
                const angle = Math.random() * Math.PI / 4 - Math.PI / 8; // Angle aléatoire léger
                const length = 100 + Math.random() * 200;
                
                // 3-5 griffes par set
                const claws = Math.floor(Math.random() * 3) + 3;
                const spacing = 10 + Math.random() * 15;
                
                for (let claw = 0; claw < claws; claw++) {
                    // Calculer le décalage perpendiculaire à l'angle
                    const offsetX = Math.sin(angle) * spacing * (claw - (claws - 1) / 2);
                    const offsetY = -Math.cos(angle) * spacing * (claw - (claws - 1) / 2);
                    
                    ctx.strokeStyle = '#221100';
                    ctx.lineWidth = 3 + Math.random() * 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(startX + offsetX, startY + offsetY);
                    
                    // Ligne principale
                    const endX = startX + Math.cos(angle) * length + offsetX;
                    const endY = startY + Math.sin(angle) * length + offsetY;
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    // Ajouter une ligne plus claire pour montrer le bois exposé
                    ctx.strokeStyle = 'rgba(200, 150, 100, 0.7)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(startX + offsetX + 1, startY + offsetY + 1);
                    ctx.lineTo(endX + 1, endY + 1);
                    ctx.stroke();
                }
            }
            
            // Créer une texture à partir du canvas
            const clawTexture = new THREE.CanvasTexture(canvas);
            
            // Appliquer la texture à la porte
            const clawMaterial = new THREE.MeshStandardMaterial({
                map: clawTexture,
                roughness: 0.8,
                metalness: 0.1
            });
            
            doorMesh.material = clawMaterial;
        }
        
        // Déterminer la zone narrative en fonction de la position
        function determineNarrativeZone(zPosition) {
            // La progression narrative est déterminée par la distance parcourue
            // Plus on s'enfonce dans le tunnel, plus l'histoire avance
            const absolutePosition = Math.abs(zPosition);
            
            // Secteurs déterminés par les paliers de milestone
            if (absolutePosition < 50) return "prologue";
            if (absolutePosition < 150) return "secteur2";
            if (absolutePosition < 300) return "secteur3";
            if (absolutePosition < 500) return "secteur4";
            if (absolutePosition < 800) return "secteur5";
            if (absolutePosition < 1200) return "secteur6";
            if (absolutePosition < 1800) return "secteur7";
            return "finale";
        }
        
        // Enregistrer une porte spéciale
        function registerSpecialDoor(door) {
            const doorId = "door_" + Math.floor(Math.random() * 10000);
            window.specialDoors[doorId] = door;
            door.userData.doorId = doorId;
            
            // Si nous avons des indices non découverts, attribuer l'un d'eux à cette porte
            const availableClues = STORY_ELEMENTS.clues.filter(
                clue => !window.discoveredClues.includes(clue.id)
            );
            
            if (availableClues.length > 0 && door.userData.containsClue) {
                const randomClue = availableClues[Math.floor(Math.random() * availableClues.length)];
                door.userData.narrativeElement = {
                    type: "clue",
                    data: randomClue
                };
            }
        }
        
        // ==========================================
        // FONCTIONS D'ANIMATION ET INTERACTION
        // ==========================================
        
        // Animer une porte et révéler son contenu
        function animateDoor(door) {
            if (!door || door.userData.animating) return;
            
            door.userData.animating = true;
            const doorMesh = door.userData.doorMesh;
            const originalPosition = -0.15; // Position initiale
            
            // Incrémenter le compteur de portes activées
            window.activatedDoors++;
            
            // Si c'est une porte spéciale, la marquer comme activée
            if (door.userData.isSpecial && !door.userData.activated) {
                door.userData.activated = true;
                
                // Révéler un indice ou déclencher un événement narratif si applicable
                if (door.userData.narrativeElement) {
                    handleNarrativeElement(door.userData.narrativeElement);
                }
            }
            
            // Créer ou récupérer l'élément mystérieux derrière la porte
            let mysteryElement = null;
            
            if (!door.userData.mysteryElement) {
                // Déterminer le type d'élément mystérieux
                const entityType = door.userData.entityType || Math.floor(Math.random() * 7);
                
                // Si la porte est spéciale, plus de chance d'avoir une entité complexe
                const mysteryType = door.userData.isSpecial ? 
                    Math.min(6, Math.floor(Math.random() * 8)) : // Favorise les entités 0-6
                    Math.floor(Math.random() * 7); // Distribution uniforme
                
                mysteryElement = createMysteryElement(mysteryType, entityType);
                
                // Positionner l'élément derrière la porte
                const doorPosition = new THREE.Vector3();
                door.getWorldPosition(doorPosition);
                
                // Ajuster la position en fonction de l'orientation de la porte
                const doorDirection = new THREE.Vector3(0, 0, -1);
                doorDirection.applyQuaternion(door.quaternion);
                
                // Placer l'élément derrière la porte à une distance appropriée
                mysteryElement.position.copy(doorPosition);
                mysteryElement.position.add(doorDirection.multiplyScalar(1.5));
                
                // Attacher l'élément à la porte
                door.userData.mysteryElement = mysteryElement;
                door.userData.mysteryType = mysteryType;
                
                // Ajouter l'élément à la scène
                window.scene.add(mysteryElement);
                
                // Stocker dans la liste globale pour les mises à jour
                window.mysteryElements[mysteryElement.uuid] = mysteryElement;
            } else {
                mysteryElement = door.userData.mysteryElement;
            }
            
            // Animation d'ouverture puis de fermeture
            let openAmount = 0;
            let opening = true;
            let revealSound = false;
            let effectTriggered = false;
            
            const interval = setInterval(() => {
                if (opening) {
                    // Phase d'ouverture
                    openAmount += 0.02;
                    
                    // Jouer un son/effet à mi-ouverture
                    if (openAmount >= 0.15 && !revealSound) {
                        playMysterySound(door.userData.mysteryType || 0);
                        revealSound = true;
                    }
                    
                    // Limitation de l'ouverture maximale
                    if (openAmount >= 0.3) {
                        opening = false;
                        
                        // Déclencher un effet spécial une seule fois
                        if (!effectTriggered) {
                            triggerMysteryEffect(door.userData.mysteryType || 0, mysteryElement);
                            effectTriggered = true;
                        }
                    }
                } else {
                    // Phase de fermeture
                    openAmount -= 0.02;
                    
                    // Vérification fin de fermeture
                    if (openAmount <= 0) {
                        openAmount = 0;
                        clearInterval(interval);
                        door.userData.animating = false;
                        
                        // Ne pas supprimer l'élément mystérieux pour permettre des interactions continues
                        // avec le même élément si la porte est rouverte
                    }
                }
                
                // Appliquer le mouvement de la porte correctement
                doorMesh.position.z = originalPosition - openAmount;
            }, 50);
        }
        
        // Créer un élément mystérieux
        function createMysteryElement(type, entityVariant = 0) {
            const group = new THREE.Group();
            
            switch (type) {
                case 0: // Yeux brillants
                    const glowingEyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const glowingEyeMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
                    
                    const glowingLeftEye = new THREE.Mesh(glowingEyeGeometry, glowingEyeMaterial);
                    glowingLeftEye.position.x = 0.2;
                    group.add(glowingLeftEye);
                    
                    const glowingRightEye = new THREE.Mesh(glowingEyeGeometry, glowingEyeMaterial);
                    glowingRightEye.position.x = -0.2;
                    group.add(glowingRightEye);
                    
                    // Animation de clignotement
                    group.userData.update = (time) => {
                        const blink = Math.sin(time * 10) > 0.7;
                        glowingLeftEye.visible = glowingRightEye.visible = blink;
                    };
                    break;
                    
                case 1: // Tentacule ondulante
                    const tentacleGeometry = new THREE.CylinderGeometry(0.1, 0.02, 1.5, 8);
                    const tentacleMaterial = new THREE.MeshPhongMaterial({
                        color: 0x660066,
                        specular: 0x555555,
                        shininess: 30
                    });
                    
                    // Créer plusieurs segments pour la tentacule
                    const segments = 5;
                    const tentacleSegments = [];
                    
                    for (let i = 0; i < segments; i++) {
                        const segment = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.1 - (i * 0.02), 0.08 - (i * 0.02), 0.4, 8),
                            tentacleMaterial
                        );
                        segment.position.y = -i * 0.3;
                        if (i > 0) {
                            segment.position.z = 0.1;
                        }
                        
                        if (i > 0) {
                            tentacleSegments[i-1].add(segment);
                        } else {
                            group.add(segment);
                        }
                        
                        tentacleSegments.push(segment);
                    }
                    
                    // Animation d'ondulation
                    group.userData.update = (time) => {
                        tentacleSegments.forEach((segment, index) => {
                            segment.rotation.x = Math.sin(time * 3 + index * 0.5) * 0.3;
                            segment.rotation.z = Math.cos(time * 2 + index * 0.5) * 0.3;
                        });
                    };
                    break;
                    
                case 2: // Silhouette sombre
                    const torsoGeometry = new THREE.BoxGeometry(0.5, 0.8, 0.3);
                    const headGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                    const limbGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
                    
                    const shadowMaterial = new THREE.MeshBasicMaterial({
                        color: 0x000000,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const torso = new THREE.Mesh(torsoGeometry, shadowMaterial);
                    group.add(torso);
                    
                    const head = new THREE.Mesh(headGeometry, shadowMaterial);
                    head.position.y = 0.5;
                    group.add(head);
                    
                    // Membres
                    const arms = [];
                    for (let i = 0; i < 2; i++) {
                        const arm = new THREE.Mesh(limbGeometry, shadowMaterial);
                        arm.position.set(i === 0 ? -0.3 : 0.3, 0.1, 0);
                        arm.rotation.z = i === 0 ? Math.PI/4 : -Math.PI/4;
                        group.add(arm);
                        arms.push(arm);
                    }
                    
                    const legs = [];
                    for (let i = 0; i < 2; i++) {
                        const leg = new THREE.Mesh(limbGeometry, shadowMaterial);
                        leg.position.set(i === 0 ? -0.15 : 0.15, -0.6, 0);
                        group.add(leg);
                        legs.push(leg);
                    }
                    
                    // Animation d'agitation
                    group.userData.update = (time) => {
                        head.rotation.y = Math.sin(time * 2) * 0.5;
                        arms.forEach((arm, index) => {
                            arm.rotation.x = Math.sin(time * 3 + index) * 0.2;
                        });
                        legs.forEach((leg, index) => {
                            leg.rotation.x = Math.sin(time * 2 + index * Math.PI) * 0.1;
                        });
                        
                        group.position.y = Math.sin(time * 2) * 0.05;
                    };
                    break;
                    
                case 3: // Objet flottant lumineux
                    const coreGeometry = new THREE.OctahedronGeometry(0.2, 1);
                    const coreMaterial = new THREE.MeshBasicMaterial({
                        color: 0x88ffff,
                        wireframe: true
                    });
                    
                    const core = new THREE.Mesh(coreGeometry, coreMaterial);
                    group.add(core);
                    
                    // Lumière interne
                    const coreLight = new THREE.PointLight(0x88ffff, 1, 3);
                    core.add(coreLight);
                    
                    // Particules orbitales
                    const particles = [];
                    const particleGeometry = new THREE.SphereGeometry(0.03, 4, 4);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff
                    });
                    
                    for (let i = 0; i < 8; i++) {
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        particle.userData = {
                            orbitRadius: 0.3 + Math.random() * 0.2,
                            orbitSpeed: 0.5 + Math.random() * 2,
                            orbitOffset: Math.random() * Math.PI * 2,
                            elevation: (Math.random() - 0.5) * 0.3
                        };
                        group.add(particle);
                        particles.push(particle);
                    }
                    
                    // Animation d'orbite
                    group.userData.update = (time) => {
                        core.rotation.x = time * 0.5;
                        core.rotation.y = time * 0.8;
                        
                        particles.forEach(particle => {
                            const orbit = particle.userData;
                            particle.position.x = Math.cos(time * orbit.orbitSpeed + orbit.orbitOffset) * orbit.orbitRadius;
                            particle.position.z = Math.sin(time * orbit.orbitSpeed + orbit.orbitOffset) * orbit.orbitRadius;
                            particle.position.y = orbit.elevation + Math.sin(time * 2) * 0.1;
                        });
                        
                        coreLight.intensity = 0.7 + Math.sin(time * 5) * 0.3;
                    };
                    break;
                    
                case 4: // Visage fantomatique
                    const faceGeometry = new THREE.PlaneGeometry(0.6, 0.8);
                    
                    // Créer une texture dynamique pour le visage
                    const canvas = document.createElement('canvas');
                    canvas.width = 256;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    
                    // Fond transparent
                    ctx.fillStyle = 'rgba(0, 0, 0, 0)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Dessiner un visage de base
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(128, 120, 90, 120, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Yeux
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.ellipse(90, 100, 20, 25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.ellipse(166, 100, 20, 25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bouche
                    ctx.beginPath();
                    ctx.ellipse(128, 160, 40, 20, 0, 0, Math.PI);
                    ctx.fill();
                    
                    const faceTexture = new THREE.CanvasTexture(canvas);
                    const faceMaterial = new THREE.MeshBasicMaterial({
                        map: faceTexture,
                        transparent: true,
                        opacity: 0.7,
                        side: THREE.DoubleSide
                    });
                    
                    const face = new THREE.Mesh(faceGeometry, faceMaterial);
                    group.add(face);
                    
                    // Animation du visage
                    group.userData.canvas = canvas;
                    group.userData.texture = faceTexture;
                    group.userData.context = ctx;
                    
                    group.userData.update = (time) => {
                        const ctx = group.userData.context;
                        const canvas = group.userData.canvas;
                        
                        // Effacer et redessiner
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Visage de base
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.beginPath();
                        ctx.ellipse(128, 120, 90, 120, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Yeux animés
                        const eyeScaleY = Math.max(0.1, Math.sin(time * 4) * 0.5 + 0.5);
                        
                        ctx.fillStyle = '#000000';
                        ctx.beginPath();
                        ctx.ellipse(90, 100, 20, 25 * eyeScaleY, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.ellipse(166, 100, 20, 25 * eyeScaleY, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Bouche animée
                        const mouthOpen = 0.3 + Math.sin(time * 2) * 0.2;
                        ctx.beginPath();
                        ctx.ellipse(128, 160, 40, 20 * mouthOpen, 0, 0, Math.PI);
                        ctx.fill();
                        
                        // Mettre à jour la texture
                        group.userData.texture.needsUpdate = true;
                        
                        // Mouvement flottant
                        group.position.y = Math.sin(time * 1.5) * 0.1;
                        face.rotation.y = Math.sin(time) * 0.2;
                    };
                    break;
                    
                case 5: // Portail énergétique
                    const ringGeometry = new THREE.TorusGeometry(0.3, 0.03, 16, 32);
                    const ringMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffaa00,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    group.add(ring);
                    
                    // Ajouter des anneaux supplémentaires
                    const rings = [ring];
                    for (let i = 1; i < 3; i++) {
                        const newRing = new THREE.Mesh(
                            new THREE.TorusGeometry(0.3, 0.02, 16, 32),
                            new THREE.MeshBasicMaterial({
                                color: 0xffaa00,
                                transparent: true,
                                opacity: 0.5 - (i * 0.1)
                            })
                        );
                        rings.push(newRing);
                        group.add(newRing);
                    }
                    
                    // Centre du portail
                    const centerGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                    const centerMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.5
                    });
                    
                    const center = new THREE.Mesh(centerGeometry, centerMaterial);
                    group.add(center);
                    
                    // Lumière du portail
                    const portalLight = new THREE.PointLight(0xffaa00, 1, 3);
                    group.add(portalLight);
                    
                    // Animation du portail
                    group.userData.update = (time) => {
                        rings.forEach((ring, i) => {
                            ring.rotation.x = time * (1 + i * 0.2);
                            ring.rotation.y = time * (0.5 + i * 0.1);
                            
                            const scalePulse = 1 + Math.sin(time * (3 + i)) * 0.1;
                            ring.scale.set(scalePulse, scalePulse, 1);
                        });
                        
                        center.scale.setScalar(0.8 + Math.sin(time * 4) * 0.2);
                        portalLight.intensity = 0.7 + Math.sin(time * 5) * 0.3;
                    };
                    break;
                    
                case 6: // Créature obscure
                    // Remplacer CapsuleGeometry (non disponible en r128) par une combinaison de cylindre et sphères
                    const body = new THREE.Group();
                    
                    // Cylindre pour le corps
                    const bodyMainGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 12);
                    const bodyMaterial = new THREE.MeshPhongMaterial({
                        color: 0x330000,
                        specular: 0x111111,
                        shininess: 50
                    });
                    const bodyMain = new THREE.Mesh(bodyMainGeometry, bodyMaterial);
                    body.add(bodyMain);
                    
                    // Sphères pour arrondir les extrémités (effet capsule)
                    const topSphereGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                    const topSphere = new THREE.Mesh(topSphereGeometry, bodyMaterial);
                    topSphere.position.y = 0.2;
                    body.add(topSphere);
                    
                    const bottomSphereGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                    const bottomSphere = new THREE.Mesh(bottomSphereGeometry, bodyMaterial);
                    bottomSphere.position.y = -0.2;
                    body.add(bottomSphere);
                    
                    group.add(body);
                    
                    // Membres
                    const limbs = [];
                    const limbMaterial = new THREE.MeshPhongMaterial({
                        color: 0x220000,
                        specular: 0x111111,
                        shininess: 30
                    });
                    
                    for (let i = 0; i < 6; i++) {
                        const limbGeometry = new THREE.CylinderGeometry(0.03, 0.01, 0.5, 5);
                        const limb = new THREE.Mesh(limbGeometry, limbMaterial);
                        
                        const angle = (i / 6) * Math.PI * 2;
                        limb.position.set(
                            Math.cos(angle) * 0.2,
                            0,
                            Math.sin(angle) * 0.2
                        );
                        
                        limb.rotation.x = Math.PI / 2;
                        limb.rotation.z = angle;
                        
                        body.add(limb);
                        limbs.push(limb);
                    }
                    
                    // Yeux
                    const creatureEyeGeometry = new THREE.SphereGeometry(0.03, 8, 8);
                    const creatureEyeMaterial = new THREE.MeshBasicMaterial({
                        color: 0xff0000
                    });
                    
                    const creatureLeftEye = new THREE.Mesh(creatureEyeGeometry, creatureEyeMaterial);
                    creatureLeftEye.position.set(0.1, 0.2, 0.15);
                    body.add(creatureLeftEye);
                    
                    const creatureRightEye = new THREE.Mesh(creatureEyeGeometry, creatureEyeMaterial);
                    creatureRightEye.position.set(-0.1, 0.2, 0.15);
                    body.add(creatureRightEye);
                    
                    // Animation de la créature
                    group.userData.update = (time) => {
                        body.rotation.y = Math.sin(time) * 0.3;
                        
                        limbs.forEach((limb, i) => {
                            limb.rotation.x = Math.PI/2 + Math.sin(time * 3 + i) * 0.3;
                        });
                        
                        creatureLeftEye.scale.setScalar(0.8 + Math.sin(time * 5) * 0.2);
                        creatureRightEye.scale.setScalar(0.8 + Math.sin(time * 5 + 1) * 0.2);
                    };
                    break;
            }
            
            // Personnaliser l'entité selon sa variante
            customizeEntityByVariant(group, entityVariant);
            
            return group;
        }
        
        // Personnaliser l'entité en fonction de sa variante (pour la diversité)
        function customizeEntityByVariant(entity, variant) {
            // Appliquer des modifications selon le type de variante
            switch(variant) {
                case 1: // Variante plus grande
                    entity.scale.set(1.3, 1.3, 1.3);
                    break;
                case 2: // Variante colorée différemment
                    entity.traverse(child => {
                        if (child.isMesh && child.material) {
                            // Changer la teinte
                            if (child.material.color) {
                                const color = child.material.color;
                                color.setHSL((color.getHSL({}).h + 0.2) % 1, color.getHSL({}).s, color.getHSL({}).l);
                            }
                        }
                    });
                    break;
                case 3: // Variante déformée
                    entity.rotation.set(Math.PI/6, 0, Math.PI/8);
                    entity.scale.set(0.9, 1.2, 0.9);
                    break;
                case 4: // Variante avec lueur
                    const glow = new THREE.PointLight(0xaaccff, 0.5, 2);
                    entity.add(glow);
                    break;
                case 5: // Variante multiple (clones)
                    for (let i = 0; i < 2; i++) {
                        const clone = entity.clone();
                        clone.position.set(
                            (Math.random() - 0.5) * 0.5,
                            (Math.random() - 0.5) * 0.5,
                            (Math.random() - 0.5) * 0.5
                        );
                        clone.scale.set(0.7, 0.7, 0.7);
                        entity.add(clone);
                    }
                    break;
                case 6: // Variante plus angoissante/agressive
                    // Augmenter la vitesse d'animation
                    const originalUpdate = entity.userData.update;
                    if (originalUpdate) {
                        entity.userData.update = (time) => {
                            originalUpdate(time * 1.5); // Animation plus rapide
                        };
                    }
                    break;
                // Cas par défaut: aucune modification
            }
        }
        
        // Jouer un son mystérieux (simulation)
        function playMysterySound(type) {
            // Ici, on ne fait que simuler le son avec console.log
            // Dans une application réelle, vous utiliseriez l'API Web Audio
            const sounds = [
                "Chuchotements inquiétants",
                "Crissement humide",
                "Respiration profonde",
                "Bourdonnement électrique",
                "Gémissement spectral",
                "Vrombissement énergétique",
                "Grognement menaçant"
            ];
            
            console.log(`Son: ${sounds[Math.min(type, sounds.length - 1)]}`);
            
            // Déclencher un événement aléatoire basé sur la progression narrative
            if (Math.random() < window.storyProgress * 0.05) {
                setTimeout(() => {
                    console.log("Événement sonore spécial déclenché!");
                    // Effet supplémentaire possible ici
                }, 1000 + Math.random() * 2000);
            }
        }
        
        // Déclencher un effet spécial selon le type d'élément mystérieux
        function triggerMysteryEffect(type, element) {
            // Effets variés selon le type
            switch(type) {
                case 0: // Yeux - Flash rapide de lumière rouge
                    flashLightEffect(0xff0000);
                    break;
                case 1: // Tentacule - Secousse de caméra
                    cameraShakeEffect(0.5);
                    break;
                case 2: // Silhouette - Assombrissement temporaire
                    darkenEffect(1.5);
                    break;
                case 3: // Objet flottant - Pulse lumineux
                    pulseLightEffect(0x88ffff, 3);
                    break;
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TikTok Horror Experience - Saison 1: Les Profondeurs</title>
    <link rel="stylesheet" href="responsive.css">
    <link rel="stylesheet" href="auth_gauge.css">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
        
        #loading { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: #000; 
            color: #fff; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            z-index: 1000;
        }
        
        #debug {
            position: fixed; 
            top: 10px; 
            left: 10px; 
            z-index: 10;
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px;
            border-radius: 5px;
        }
        
        #donation-panel {
            position: fixed;
            right: 10px;
            top: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 180px;
            font-size: 11px;
            display: none; /* Hide donation panel as requested */
        }
        
        #donation-panel h3 {
            margin-top: 0;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 40px; /* Déplacé plus bas pour éviter le chevauchement */
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            max-width: 400px;
            z-index: 900;
        }
        
        .progress-bar {
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            margin-bottom: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9900);
            width: 0%;
            transition: width 1s ease-in-out;
        }
        
        #story-milestone {
            position: fixed;
            top: 80px; /* Déplacé encore plus bas */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 12px;
            z-index: 900;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
            padding: 5px 10px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            width: 40%;
            max-width: 400px;
            line-height: 1.3;
            display: none; /* Caché par défaut, sera affiché dans le journal uniquement */
        }
        
        #donor-wall {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Aligné avec le journal d'exploration */
            max-height: 130px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Caché car remplacé par top100 */
        }
        
        #top100-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* En bas de l'écran, directement sous le journal */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px;
            max-height: 150px;
            overflow: hidden;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Caché car remplacé par leaderboard-panel */
        }
        
        #top100-panel h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 13px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .top100-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
            position: relative;
        }
        
        .top100-rank {
            width: 20px;
            text-align: center;
            color: #aaa;
        }
        
        .top100-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .top100-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #narrative-display {
            position: fixed;
            top: 50%; /* Centré verticalement */
            left: 50%;
            transform: translate(-50%, -50%); /* Centrage parfait */
            z-index: 950;
            color: white;
            text-align: center;
            width: 70%;
            max-width: 600px;
            text-shadow: 0 0 3px black, 0 0 5px black;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Fond plus opaque pour meilleure lisibilité */
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none; /* Pour éviter d'interférer avec les clics */
        }
        
        #narrative-display.visible {
            opacity: 0.95;
        }
        
        #clue-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 950;
            color: #ffcc00;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 3px solid #ffcc00;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease-out;
        }
        
        #clue-notification.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #event-counter {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            color: white;
            font-size: 120px;
            text-shadow: 0 0 20px red;
            opacity: 0;
            transition: all 0.3s ease-in-out;
            pointer-events: none;
        }
        
        #event-counter.visible {
            opacity: 1;
        }
        
        button, input { 
            margin: 5px 0; 
            display: block;
            border: none;
            background: #444;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #666;
        }
        
        #sim-donation {
            margin-top: 15px;
            width: 100%;
        }
        
        #vote-panel {
            position: fixed;
            right: 10px;
            bottom: 10px; /* En bas à droite */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 160px;
            font-size: 10px;
            display: none;
        }
        
        .vote-option {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .vote-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .vote-bar {
            height: 5px;
            width: 100%;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .vote-fill {
            height: 100%;
            background: linear-gradient(90deg, #77ccff, #4488ff);
            width: 30%;
        }
        
        /* Animation pour les effects */
        @keyframes pulse {
            0% { opacity: 0.2; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.2; transform: scale(0.95); }
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        #leaderboard-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* Repositionné en bas sous le journal */
            top: auto; /* Annule la position top précédente */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 200px;
            max-height: 145px; /* Hauteur réduite pour éviter le chevauchement (était à 150px) */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #leaderboard-panel h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #aaa;
            width: 20px;
            text-align: center;
        }
        
        .leaderboard-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .leaderboard-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #story-history-panel {
            position: fixed;
            left: 10px;
            bottom: 175px; /* Remonté plus haut pour éviter le chevauchement (était à 70px) */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Élargi pour mieux afficher les messages */
            max-height: 180px; /* Légèrement plus grand */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #story-history-panel h3 {
            margin-top: 0;
            margin-bottom: 3px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .history-item {
            margin-bottom: 4px;
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .history-item-milestone {
            background-color: rgba(255, 204, 0, 0.2);
            border-left: 2px solid #ffcc00;
        }
        
        .history-item-discovery {
            background-color: rgba(119, 204, 255, 0.2);
            border-left: 2px solid #77ccff;
        }
        
        .history-item-event {
            background-color: rgba(255, 102, 102, 0.2);
            border-left: 2px solid #ff6666;
        }
        
        .history-timestamp {
            color: #aaa;
            font-size: 8px;
            margin-bottom: 2px;
            font-style: italic;
        }
        
        /* Style pour réserver l'espace pour la caméra */
        .camera-space {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 100px;
            z-index: 800;
            /* Background commenté - juste pour visualiser l'espace réservé 
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            */
        }
        
        /* Assurons-nous que tous les panneaux ont une apparence cohérente */
        #leaderboard-panel, #story-history-panel, #vote-panel, #donor-wall {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.85; /* Légèrement transparent pour voir le bateau derrière */
        }
        
        /* Animation de défilement automatique pour les panneaux */
        @keyframes autoscroll {
            0% { transform: translateY(0); }
            45% { transform: translateY(calc(-100% + 100px)); }
            55% { transform: translateY(calc(-100% + 100px)); } /* Pause au bas pendant 10% de l'animation */
            57% { transform: translateY(0); } /* Retour très rapide au début (2% de l'animation) */
            100% { transform: translateY(0); } /* Pause au début avant de recommencer */
        }
        
        .autoscroll-container {
            height: 100%;
            overflow: hidden;
            position: relative;
            max-height: inherit;
        }
        
        .autoscroll-content {
            animation: autoscroll 60s linear infinite; /* Remis à "infinite" pour boucler */
            animation-play-state: running;
            padding-bottom: 20px; /* Add space at the bottom before repeating */
        }
        
        .autoscroll-content:hover {
            animation-play-state: paused;
        }
        
        /* Objectifs sur la barre en haut */
        #objectives-panel {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            display: flex;
            gap: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .objective {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .objective-icon {
            color: #ffcc00;
            font-size: 14px;
        }
        
        .objective-text {
            white-space: nowrap;
        }
        
        /* 
        Organisation des panneaux :
        - Haut: Objectifs
        - Droite: Progression narrative 
        - À gauche milieu: Journal d'exploration
        - À gauche bas: Classement des explorateurs
        - En bas à droite: Panneau de vote
        - Centre haut (ajusté): Barre de progression
        - Centre bas: Affichage narratif
        */
        
        /* Hover effect pour rendre les panneaux plus lisibles au survol */
        #leaderboard-panel:hover, #story-history-panel:hover, #donation-panel:hover, #vote-panel:hover, #donor-wall:hover {
            opacity: 0.95;
            z-index: 950; /* Augmente le z-index au survol pour s'assurer qu'il est au-dessus des autres */
        }
        
        /* Style pour les titres des panneaux */
        #leaderboard-panel h3, #story-history-panel h3, #donor-wall h4 {
            color: #ffcc00;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        #details-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 950;
            background: rgba(0,0,0,0.7);
            color: #ffcc00;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid rgba(255, 204, 0, 0.3);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            display: none; /* Cacher le bouton des détails d'exploration */
        }
        
        #details-button:hover {
            background: rgba(50,50,0,0.7);
            border-color: rgba(255, 204, 0, 0.6);
        }
        
        /* Overlay d'authentification */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #33ff33;
            font-family: 'Courier New', monospace;
        }
        
        .auth-content {
            text-align: center;
            max-width: 500px;
            padding: 20px;
        }
        
        .auth-logo {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
        }
        
        .auth-message {
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        .auth-warning {
            color: #ff3333;
            margin-top: 20px;
            font-size: 12px;
            max-width: 80%;
            text-align: justify;
        }
        
        .donation-progress-container {
            width: 300px;
            margin: 0 auto;
        }
        
        .donation-label {
            color: #fff;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .donation-bar {
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #ff3366;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        #auth-donation-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff3366, #ff6699);
            transition: width 0.5s ease-in-out;
        }
        
        .auth-gauge {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .auth-gauge h3 {
            margin-top: 0;
            font-size: 14px;
            color: #ffcc00;
        }
        
        .tiktok-integration-notice {
            font-size: 12px;
            color: #ccc;
        }
        
        /* Notifications d'authentification */
        .auth-notification {
            position: fixed;
            right: -300px;
            top: 100px;
            background: linear-gradient(90deg, #330033, #5a0057);
            border-left: 3px solid #ff3366;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            padding: 15px;
            width: 250px;
            border-radius: 5px 0 0 5px;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .auth-notification.show {
            right: 0;
        }
        
        .auth-username {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .auth-amount {
            color: #ff3366;
            font-weight: bold;
            font-size: 18px;
        }
        
        /* Statut du système */
        .system-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #33ff33;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #ff3333;
        }
        
        .status-indicator.online {
            background-color: #33ff33;
        }
        
        /* Animation de pulsation pour la jauge */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .auth-gauge.pulse {
            animation: pulse 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
    <!-- Inclure les fichiers externes pour la gestion de l'authentification -->
    <script src="auth_gauge.js"></script>
    <script>
        /**
         * Gestion de la jauge d'authentification du système
         */
        
        // Configuration
        const REQUIRED_AMOUNT = 10; // Montant requis pour débloquer l'accès (en unités)
        let totalProgress = 0; // Variable globale pour suivre la progression
        
        /**
         * Initialisation de la jauge d'authentification
         */
        function initAuthGauge() {
            console.log("Initialisation de la jauge d'authentification");
            
            // Récupérer les éléments pour vérifier qu'ils existent
            const fillBar = document.getElementById('auth-donation-fill');
            const percentText = document.getElementById('auth-donation-percent');
            
            if (fillBar) {
                console.log("Élément 'auth-donation-fill' trouvé");
            } else {
                console.error("Élément 'auth-donation-fill' introuvable");
            }
            
            if (percentText) {
                console.log("Élément 'auth-donation-percent' trouvé");
            } else {
                console.error("Élément 'auth-donation-percent' introuvable");
            }
            
            // Mettre à jour l'affichage initial
            updateAuthGauge(0);
            
            // Écouter les messages d'authentification externes
            window.addEventListener('message', function(event) {
                console.log("Message reçu:", event.data);
                // Vérifier si le message contient des données d'authentification
                if (event.data && event.data.type === 'auth_progress') {
                    processAuthProgress(event.data.data);
                }
            });
        
            // Vérifier la progression à intervalles réguliers
            setInterval(checkAuthProgress, 5000);
            
            // Faire une vérification immédiate
            setTimeout(checkAuthProgress, 1000);
        }
        
        /**
         * Mise à jour visuelle de la jauge d'authentification
         */
        function updateAuthGauge(amount) {
            console.log("Mise à jour de la jauge d'authentification avec:", amount);
            
            // Obtenir les éléments de la jauge
            const fillBar = document.getElementById('auth-donation-fill');
            const percentText = document.getElementById('auth-donation-percent');
            
            // Calculer le pourcentage de progression
            const percentage = Math.min((amount / REQUIRED_AMOUNT) * 100, 100);
            console.log("Pourcentage calculé:", percentage);
            
            if (fillBar) {
                console.log("Mise à jour de la barre de remplissage");
                // Mettre à jour la barre de progression
                fillBar.style.width = percentage + '%';
            } else {
                console.error("Élément 'auth-donation-fill' introuvable");
            }
            
            if (percentText) {
                console.log("Mise à jour du texte de pourcentage");
                // Mettre à jour le texte du pourcentage
                percentText.textContent = Math.floor(percentage) + '%';
            } else {
                console.error("Élément 'auth-donation-percent' introuvable");
            }
            
            // Vérifier si le seuil est atteint pour débloquer
            if (amount >= REQUIRED_AMOUNT) {
                unlockAuthScreen();
            }
        }
        
        /**
         * Traitement d'une progression d'authentification
         */
        function processAuthProgress(progressData) {
            console.log("Traitement des données de progression:", progressData);
            
            // Vérifier que les données contiennent les informations nécessaires
            if (progressData && progressData.username && progressData.amount) {
                // Convertir le montant en unités si nécessaire
                const amount = parseFloat(progressData.amount);
                if (isNaN(amount)) {
                    console.error("Montant invalide:", progressData.amount);
                    return;
                }
        
                console.log("Ajout de", amount, "au total");
                // Mettre à jour le total
                totalProgress += amount;
                
                // Mettre à jour l'affichage
                updateAuthGauge(totalProgress);
                
                // Afficher une notification
                showAuthNotification(progressData.username, amount);
            } else {
                console.error("Données de progression incomplètes:", progressData);
            }
        }
        
        /**
         * Affichage d'une notification pour une progression d'authentification
         */
        function showAuthNotification(username, amount) {
            // Créer un élément de notification
            const notification = document.createElement('div');
            notification.className = 'auth-notification';
            notification.innerHTML = `
                <span class="auth-username">${username}</span>
                <span class="auth-amount">+${amount.toFixed(2)} unités</span>
            `;
            
            // Ajouter la notification au DOM
            document.body.appendChild(notification);
            
            // Animer la notification
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);
            
            // Supprimer la notification après un délai
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 500);
            }, 5000);
        }
        
        /**
         * Vérification de la progression d'authentification à intervalles réguliers
         */
        function checkAuthProgress() {
            console.log("Vérification de la progression locale");
            
            // Utiliser une méthode alternative pour lire le fichier local
            fetch('/latest_auth_progress.json')
                .then(response => {
                    console.log("Réponse du serveur pour le fichier local:", response.status);
                    if (!response.ok) {
                        throw new Error('Fichier non disponible');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log("Données locales récupérées:", data);
                    if (data && data.username && data.amount) {
                        // Traiter le don local
                        processAuthProgress(data);
                        // Réinitialiser le fichier pour éviter de traiter le même don plusieurs fois
                        resetLocalAuthProgress();
                    } else if (Object.keys(data).length === 0) {
                        console.log("Fichier local vide, pas de nouvelle progression");
                    } else {
                        console.error("Fichier local incomplet:", data);
                    }
                })
                .catch(error => {
                    // Silencieux en cas d'erreur - le fichier n'existe peut-être pas encore
                    console.log('Pas de nouveau progrès d\'authentification local:', error.message);
                });
        }
        
        /**
         * Réinitialise le fichier de progression locale après traitement
         */
        function resetLocalAuthProgress() {
            // Appel au serveur pour réinitialiser le fichier
            fetch('/api/reset-auth-progress', {
                method: 'POST'
            }).catch(error => {
                console.error('Erreur lors de la réinitialisation de la progression:', error);
            });
        }
        
        /**
         * Débloque l'écran d'authentification quand le seuil est atteint
         */
        function unlockAuthScreen() {
            const authOverlay = document.getElementById('auth-overlay');
            if (authOverlay && authOverlay.style.display !== 'none') {
                // Animation de disparition
                authOverlay.style.opacity = '0';
                setTimeout(() => {
                    authOverlay.style.display = 'none';
                    // Masquer l'écran de chargement pour afficher l'expérience 3D
                    const loadingScreen = document.getElementById('loading');
                    if (loadingScreen) {
                        loadingScreen.style.display = 'none';
                    }
                    
                    // Initialiser le jeu après l'authentification
                    if (typeof initializeAfterAuth === 'function') {
                        initializeAfterAuth();
                    } else {
                        // Initialiser ou afficher l'expérience du bateau si elle est déjà chargée
                        if (window.scene && window.camera && window.renderer) {
                            console.log("Expérience 3D déjà chargée, activation");
                            // Ajouter ici tout code nécessaire pour démarrer l'animation du bateau
                        } else {
                            console.log("Initialisation de l'expérience 3D");
                            // Initialiser la scène Three.js si pas encore fait
                            initScene();
                        }
                    }
                }, 1000);
                
                console.log("Authentification réussie, accès débloqué");
            }
        }
        
        // Initialiser la jauge d'authentification au chargement de la page
        document.addEventListener('DOMContentLoaded', initAuthGauge);
    </script>
</head>
<body>
    <!-- Overlay d'authentification -->
    <div class="auth-overlay" id="auth-overlay">
        <div class="auth-content">
            <div class="auth-logo">THE-DEPTHS v3.6.7</div>
            <div class="auth-message">
                AVERTISSEMENT: Vous êtes sur le point d'accéder à un réseau non autorisé.<br><br>
                Ce terminal sert d'interface aux communications internes du groupe THE-DEPTHS.<br>
                Toute intrusion non autorisée sera tracée et signalée aux administrateurs.<br><br>
                Cet accès est seulement destiné aux membres confirmés.
            </div>
            
            <div class="auth-gauge">
                <h3 style="text-align: center;">Progression vers l'authentification</h3>
                <div class="donation-progress-container">
                    <div class="donation-label" style="text-align: center; display: block; width: 100%;">Progression : <span id="auth-donation-percent">0%</span></div>
                    <div class="donation-bar">
                        <div id="auth-donation-fill" style="width: 0%;"></div>
                    </div>
                </div>
                <div class="tiktok-integration-notice" style="text-align: center; width: 100%;">
                    Connexion aux systèmes de sécurité en cours...
                </div>
            </div>
            
            <div style="text-align: center; width: 100%;">
                <button id="auth-accept" style="background: #111; color: #777; border: 1px solid #666; padding: 10px 20px; cursor: not-allowed; margin-top: 20px; opacity: 0.6; display: inline-block;">
                    AUTHENTIFICATION VERROUILLÉE
            </button>
            </div>
            
            <div class="auth-warning">
                SYSTÈME DE SÉCURITÉ: L'accès à cette interface est strictement contrôlé. Une authentification externe est nécessaire pour débloquer le terminal.
            </div>
        </div>
    </div>
    
    <!-- Indicateur de statut du système -->
    <div class="system-status" id="system-status">
        <div class="status-indicator" id="status-light"></div>
        <span id="status-text">SYSTÈME HORS LIGNE</span>
    </div>
    
    <div id="loading">
        <h2>Exploration des Profondeurs</h2>
            <div style="width: 200px; height: 20px; background: #333; border-radius: 10px; overflow: hidden; margin: 20px 0;">
                <div id="load-progress" style="width: 0%; height: 100%; background: linear-gradient(90deg, #ff0066, #ffcc00);"></div>
            </div>
            <div>Chargement de l'expérience...</div>
    </div>
    
    <div id="details-button" onclick="window.open('exploration_details.html', '_blank')">
        <span>📊</span>
        <span>Détails d'Exploration</span>
    </div>
    
    <div id="progress-display">
        <div style="display: flex; justify-content: space-between;">
            <span>PROGRESSION: </span>
            <span id="progress-percent">0%</span>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="story-progress"></div>
        </div>
        <div style="display: flex; justify-content: space-between;">
            <span>DÉBUT</span>
            <span>FIN</span>
        </div>
        <div style="text-align: center; font-size: 10px; color: #ffcc00; margin-top: 3px; text-shadow: 0 0 2px #000;">
            Votre participation stabilise la connexion et révèle de nouveaux mystères
        </div>
    </div>
    
    <div id="debug" style="display: none;">
        <h3>Contrôles Debug</h3>
        <button id="giftBtn">Simuler cadeau</button>
        <input id="commentInput" type="text" placeholder="Commentaire">
        <button id="commentBtn">Envoyer</button>
        <button id="likeBtn">Simuler likes</button>
        <button id="toggle-debug">Afficher contrôles avancés</button>
        <div id="advanced-debug" style="display: none; margin-top: 10px;">
            <button id="debug-milestone">Débloquer milestone</button>
            <button id="debug-entity">Invoquer entité</button>
            <button id="debug-clue">Révéler indice</button>
            <button id="debug-event">Déclencher événement</button>
            <button id="debug-vote">Lancer vote</button>
        </div>
    </div>
    
    <div id="donation-panel">
        <h3 style="margin-top: 0; text-align: center;">Les Profondeurs</h3>
        <button id="open-donation-simulator" style="width:100%; margin-bottom:5px; font-size:10px; padding:4px;">
            Ouvrir le Simulateur de Dons
        </button>
        <div style="font-size:9px; margin-bottom:5px; text-align:center;">
            Pour simuler un don, utilisez le simulateur
        </div>
        <button id="open-tiktok-config" style="width:100%; margin-bottom:10px; font-size:10px; padding:4px; background-color:#ff3366;">
            Configurer API TikTok
        </button>
        <div style="display: flex; justify-content: space-between;">
            <span>Progression narrative:</span>
            <span id="progress-percent">0%</span>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="story-progress"></div>
        </div>
        <div style="display: flex; justify-content: space-between;">
            <span>Prochain palier:</span>
            <span id="next-milestone-amount">500 unités</span>
        </div>
        <div id="story-milestone">
            "Le passage vers le secteur 2 semble bloqué. Une intervention externe est nécessaire pour rétablir l'accès..."
        </div>
        <div style="margin-top: 15px;">
            <div style="display: flex; justify-content: space-between;">
                <span>Total des contributions:</span>
                <span id="total-donations">0 unités</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
                <span>Mystères résolus:</span>
                <span id="solved-mysteries">0/13</span>
            </div>
        </div>
    </div>
    
    <div id="donor-wall">
        <h4 style="margin-top: 0;">Contributeurs Récents</h4>
        <div id="donor-list">
            <!-- Les contributeurs seront ajoutés ici dynamiquement -->
        </div>
    </div>
    
    <div id="top100-panel">
        <h4>Top 100 Explorateurs</h4>
        <div id="top100-list">
            <!-- La liste des 100 meilleurs sera ici -->
        </div>
    </div>
    
    <div id="narrative-display"></div>
    
    <div id="clue-notification">Indice trouvé: Enigme #172</div>
    
    <div id="event-counter"></div>
    
    <div id="vote-panel">
        <h4 style="margin-top: 0;">Vote Communautaire</h4>
        <p id="vote-question">Quelle porte le voyageur devrait-il ouvrir ensuite?</p>
        <div class="vote-option" data-option="1">
            <div style="display: flex; justify-content: space-between;">
                <span>Porte avec symbole spirale</span>
                <span>30%</span>
            </div>
            <div class="vote-bar">
                <div class="vote-fill" style="width: 30%"></div>
            </div>
        </div>
        <div class="vote-option" data-option="2">
            <div style="display: flex; justify-content: space-between;">
                <span>Porte rouge clignotante</span>
                <span>45%</span>
            </div>
            <div class="vote-bar">
                <div class="vote-fill" style="width: 45%"></div>
            </div>
        </div>
        <div class="vote-option" data-option="3">
            <div style="display: flex; justify-content: space-between;">
                <span>Porte avec marques de griffes</span>
                <span>25%</span>
            </div>
            <div class="vote-bar">
                <div class="vote-fill" style="width: 25%"></div>
            </div>
        </div>
        <p style="font-size: 12px; text-align: center; margin-top: 10px;">Votre interaction compte comme un vote. Fin dans <span id="vote-timer">02:45</span></p>
    </div>

    <!-- Charger Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Définir les variables globales
        window.scene = null;
        window.camera = null;
        window.renderer = null;
        window.boat = null;
        window.doors = [];
        window.segments = [];
        window.boatSpeed = 0.05;
        window.moveDirection = { x: 0, z: 1 };
        // Variable pour stocker les références aux fenêtres ouvertes
        window.detailWindows = [];
        
        // Variables pour le système de narration et de dons
        window.totalDonations = 0;
        window.currentSeason = 1;
        window.currentEpisode = 1;
        window.currentMilestoneIndex = 0;
        window.storyProgress = 0;
        window.mysteryElements = {};
        window.discoveredClues = [];
        window.solvedMysteries = 0;
        window.activatedDoors = 0;
        window.specialDoors = {};
        window.activeVote = null;
        
        // Constantes
        const TUNNEL_RADIUS = 5;
        const TUNNEL_LENGTH = 20;
        const WATER_LEVEL = -2;
        
        // Définition des paliers de donation pour le progrès narratif
        const STORY_MILESTONES = [
            { amount: 100, title: "Prologue: L'entrée", description: "Les premières portes commencent à révéler d'étranges phénomènes...", unlocksFunction: unlockPrologue },
            { amount: 500, title: "Secteur 2: Murmures", description: "Des voix lointaines résonnent dans l'eau. Elles semblent raconter des fragments d'histoires...", unlocksFunction: unlockSector2 },
            { amount: 1500, title: "Secteur 3: Mémoires", description: "Des symboles apparaissent sur certaines portes. Ils semblent former un code à déchiffrer...", unlocksFunction: unlockSector3 },
            { amount: 3000, title: "Secteur 4: Résonance", description: "L'eau commence à vibrer à intervalles réguliers. Une présence se fait sentir dans les profondeurs...", unlocksFunction: unlockSector4 },
            { amount: 5000, title: "Confrontation Mineure: L'Observateur", description: "Une entité mystérieuse semble suivre le bateau. Ses intentions sont inconnues...", unlocksFunction: unlockMinorEntity },
            { amount: 8000, title: "Secteur 5: Distorsion", description: "La réalité semble se plier. Certaines portes mènent à des lieux impossibles...", unlocksFunction: unlockSector5 },
            { amount: 12000, title: "Secteur 6: Convergence", description: "Les indices commencent à converger. Un schéma plus large se dessine...", unlocksFunction: unlockSector6 },
            { amount: 18000, title: "Confrontation Majeure: Le Gardien", description: "Une présence ancienne bloque le chemin. Elle doit être confrontée pour continuer...", unlocksFunction: unlockMajorEntity },
            { amount: 25000, title: "Secteur 7: Vérité", description: "Les derniers fragments du mystère se dévoilent. La vérité est presque à portée...", unlocksFunction: unlockSector7 },
            { amount: 35000, title: "Finale: Révélation", description: "Le mystère final des Profondeurs est sur le point d'être révélé...", unlocksFunction: unlockFinale }
        ];
        
        // Définition des niveaux de contributeurs
        const DONOR_TIERS = [
            { min: 1, max: 49, name: "Explorateur", class: "donor-common" },
            { min: 50, max: 199, name: "Chercheur", class: "donor-rare" },
            { min: 200, max: 999, name: "Éclaireur", class: "donor-epic" },
            { min: 1000, max: Infinity, name: "Illuminé", class: "donor-legendary" }
        ];
        
        // Base de données des éléments narratifs
        const STORY_ELEMENTS = {
            clues: [
                { id: "C001", text: "Numéro gravé: 7-3-9-4-2", category: "sequence", linkedMystery: "M003" },
                { id: "C002", text: "Inscription: 'Le cercle s'élargit mais revient toujours au centre'", category: "phrase", linkedMystery: "M001" },
                { id: "C003", text: "Symbole récurrent: œil traversé par une ligne verticale", category: "symbol", linkedMystery: "M002" },
                { id: "C004", text: "Date répétitive: 22.07.1976", category: "date", linkedMystery: "M005" },
                { id: "C005", text: "Coordonnées fragmentées: 47°N 13...", category: "location", linkedMystery: "M004" },
                { id: "C006", text: "Mot inversé: RUEGREMBUS", category: "word", linkedMystery: "M002" },
                { id: "C007", text: "Schéma circulaire avec 9 points", category: "pattern", linkedMystery: "M001" },
                { id: "C008", text: "Référence: 'Projet Abyssus'", category: "name", linkedMystery: "M007" },
                { id: "C009", text: "Équation: 2x² + 3x - √(4) = 0", category: "math", linkedMystery: "M003" },
                { id: "C010", text: "Fragment audio: voix distordue répétant 'le sixième cycle'", category: "audio", linkedMystery: "M006" },
                { id: "C011", text: "Phrase codée: VGSPJVYMREGIVPIVW", category: "cipher", linkedMystery: "M005" },
                { id: "C012", text: "Motif de lumières: court-court-long-long-court", category: "pattern", linkedMystery: "M004" }
            ],
            mysteries: [
                { id: "M001", title: "Le Motif Circulaire", requiredClues: ["C002", "C007"], solved: false, reward: "Révèle l'origine du tunnel" },
                { id: "M002", title: "L'Entité Observatrice", requiredClues: ["C003", "C006"], solved: false, reward: "Débloque une porte spéciale" },
                { id: "M003", title: "La Séquence Mathématique", requiredClues: ["C001", "C009"], solved: false, reward: "Permet de prévoir certains événements" },
                { id: "M004", title: "Les Signaux", requiredClues: ["C005", "C012"], solved: false, reward: "Révèle un mode de communication" },
                { id: "M005", title: "L'Incident Initial", requiredClues: ["C004", "C011"], solved: false, reward: "Explique pourquoi le tunnel existe" },
                { id: "M006", title: "Les Cycles Temporels", requiredClues: ["C010"], solved: false, reward: "Débloque une vision du passé/futur" },
                { id: "M007", title: "Les Origines du Projet", requiredClues: ["C008"], solved: false, reward: "Révèle qui a créé cette expérience" }
            ],
            narrativeFragments: [
                "Les enregistrements indiquent que le projet a été abandonné suite à une 'contamination'.",
                "Le tunnel n'a pas été construit. Il est apparu spontanément le 22 juillet 1976.",
                "Certains chercheurs affirment avoir vu leur propre reflet vieilli de plusieurs décennies.",
                "L'eau n'est pas réellement de l'eau. Sa composition moléculaire est inconnue.",
                "Les portes apparaissaient et disparaissaient même avant notre arrivée.",
                "Les tests ont révélé que le temps s'écoule différemment à diverses profondeurs.",
                "Équipe d'exploration #7: 4 entrés, 5 revenus. Anomalie consignée.",
                "Les manifestations semblent réagir aux émotions collectives des observateurs.",
                "Théorie: nous ne sommes pas dans un lieu physique mais dans une projection mentale collective.",
                "Le sixième cycle s'achèvera quand le témoin final comprendra sa fonction."
            ]
        };
        
        // ==========================================
        // FONCTIONS D'INITIALISATION
        // ==========================================
        
        // Gestion du redimensionnement de la fenêtre
        function onWindowResize() {
            // Mettre à jour la caméra
            window.camera.aspect = window.innerWidth / window.innerHeight;
            window.camera.updateProjectionMatrix();
            
            // Mettre à jour le renderer
            window.renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Initialisation de l'application
        function init() {
            // Créer la scène Three.js
            window.scene = new THREE.Scene();
            
            // Créer la caméra
            window.camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            window.camera.position.set(0, 1, -5);
            
            // Créer le renderer
            window.renderer = new THREE.WebGLRenderer({ antialias: false });
            window.renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(window.renderer.domElement);
            
            // Ajouter une lumière ambiante
            const light = new THREE.AmbientLight(0x444444);
            window.scene.add(light);
            
            // Effet de brouillard pour l'atmosphère
            window.scene.fog = new THREE.FogExp2(0x000000, 0.035);
            
            // Créer le bateau
            window.boat = createBoat();
            
            // Créer le tunnel initial
            for (let i = 0; i < 3; i++) {
                createSegment(i * TUNNEL_LENGTH);
            }
            
            // Gérer le redimensionnement
            window.addEventListener('resize', onWindowResize);
            
            // Configurer le debug et les contrôles de simulation
            setupDebug();
            setupDonationSystem();
            setupVoteSystem();
            
            // Masquer l'écran de chargement
            const loadingScreen = document.getElementById('loading');
            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 500);
            }, 2000);
            
            // Afficher le message d'introduction après un délai
            setTimeout(showNarrativeMessage, 3000, "Bienvenue dans Les Profondeurs. Les portes cachent des secrets. À vous de les découvrir...", 8000);
            
            // Initialiser les variables de narration
            updateMilestoneDisplay();
            
            // Créer le panneau d'objectifs
            createObjectivesPanel();
            
            // Initialiser les panneaux avec défilement automatique (activation directe)
            const historyList = document.getElementById('story-history-list');
            const leaderboardList = document.getElementById('leaderboard-list');
            const top100List = document.getElementById('top100-list');
            
            // Activer l'auto-défilement pour l'historique
            if (historyList) {
                const historyPanel = document.getElementById('story-history-panel');
                if (historyPanel) historyPanel.style.display = 'block';
            }
            
            // Activer l'auto-défilement pour le leaderboard
            if (leaderboardList) {
                const leaderboardPanel = document.getElementById('leaderboard-panel');
                if (leaderboardPanel) leaderboardPanel.style.display = 'block';
            }
            
            // Activer l'auto-défilement pour le top100
            if (top100List) {
                const top100Panel = document.getElementById('top100-panel');
                if (top100Panel) top100Panel.style.display = 'block';
            }
            
            // Ajouter quelques entrées initiales dans l'historique si vide
            if (!window.storyHistory || window.storyHistory.length === 0) {
                addToStoryHistory('milestone', 'Bienvenue dans Les Profondeurs');
                addToStoryHistory('discovery', 'Explorez les tunnels à la recherche d\'indices');
                addToStoryHistory('event', 'Attention aux entités mystérieuses');
            }
            
            // Démarrer l'animation
            animate();
            
            // Ajouter un gestionnaire pour le bouton détails d'exploration
            const detailsButton = document.getElementById('details-button');
            if (detailsButton) {
                detailsButton.addEventListener('click', function() {
                    const detailWindow = window.open('exploration_details.html', '_blank');
                    if (detailWindow) {
                        window.detailWindows.push(detailWindow);
                    }
                });
            }
        }
        
        // Animation de chargement
        function simulateLoading() {
                let progress = 5;
                const loadProgressBar = document.getElementById('load-progress');
                
                const interval = setInterval(() => {
                    progress += Math.floor(Math.random() * 8) + 3;
                    if (progress >= 100) {
                        progress = 100;
                        clearInterval(interval);
                    }
                    loadProgressBar.style.width = progress + '%';
                }, 300);
        }
        
        // Configuration du panneau de debug
        function setupDebug() {
            if (window.location.search.includes('debug=true')) {
                const debugPanel = document.getElementById('debug');
                debugPanel.style.display = 'block';
                
                // Toggle des contrôles avancés
                document.getElementById('toggle-debug').addEventListener('click', () => {
                    const advancedDebug = document.getElementById('advanced-debug');
                    advancedDebug.style.display = advancedDebug.style.display === 'none' ? 'block' : 'none';
                });
                
                // Bouton pour simuler un cadeau/don
                document.getElementById('giftBtn').addEventListener('click', () => {
                    const randomAmount = Math.floor(Math.random() * 100) + 5;
                    simulateDonation("Viewer" + Math.floor(Math.random() * 1000), randomAmount);
                });
                
                // Bouton pour envoyer un commentaire
                document.getElementById('commentBtn').addEventListener('click', () => {
                    const text = document.getElementById('commentInput').value.toLowerCase();
                    handleComment(text);
                    document.getElementById('commentInput').value = '';
                });
                
                // Bouton pour simuler des likes
                document.getElementById('likeBtn').addEventListener('click', () => {
                    // Petit effet visuel
                    window.camera.position.x += (Math.random() - 0.5) * 0.1;
                    window.camera.position.y += (Math.random() - 0.5) * 0.1;
                });
                
                // Contrôles avancés
                document.getElementById('debug-milestone').addEventListener('click', () => {
                    unlockNextMilestone("Debug");
                });
                
                document.getElementById('debug-entity').addEventListener('click', () => {
                    spawnSpecialEntity();
                });
                
                document.getElementById('debug-clue').addEventListener('click', () => {
                    revealRandomClue();
                });
                
                document.getElementById('debug-event').addEventListener('click', () => {
                    triggerSpecialEvent();
                });
                
                document.getElementById('debug-vote').addEventListener('click', () => {
                    startVote();
                });
            }
        }
        
        // Configuration du système de dons
        function setupDonationSystem() {
            // Vérifier si le bouton de simulation de dons existe avant d'ajouter l'écouteur
            const simDonationBtn = document.getElementById('sim-donation');
            if (simDonationBtn) {
                simDonationBtn.addEventListener('click', () => {
                    const amountInput = document.getElementById('donation-amount');
                    const amount = parseInt(amountInput.value);
                    
                    if (amount && amount > 0) {
                        const username = "Viewer" + Math.floor(Math.random() * 10000);
                        simulateDonation(username, amount);
                        amountInput.value = '';
                    }
                });
            }
            
            // Configuration du bouton d'ouverture du simulateur de dons
            const openDonationSimBtn = document.getElementById('open-donation-simulator');
            if (openDonationSimBtn) {
                openDonationSimBtn.addEventListener('click', () => {
                    openDonationSimulator();
                });
            }
            
            // Configuration du bouton d'ouverture de la configuration TikTok
            const openTikTokConfigBtn = document.getElementById('open-tiktok-config');
            if (openTikTokConfigBtn) {
                openTikTokConfigBtn.addEventListener('click', () => {
                    openTikTokConfig();
                });
            }
            
            // Initialisation des valeurs
            updateDonationDisplay();
            
            // Charger la configuration TikTok s'il y en a une
            loadTikTokConfig();
        }
        
        // Fonction pour ouvrir le simulateur de dons (sans créer de fenêtre popup)
        function openDonationSimulator() {
            // Vérifier si un panneau de simulation existe déjà et le supprimer s'il est déjà affiché
            const existingPanel = document.getElementById('inline-donation-panel');
            if (existingPanel) {
                existingPanel.remove();
                return;
            }
            
            // Créer un panneau flottant pour le simulateur de dons intégré
            const panel = document.createElement('div');
            panel.id = 'inline-donation-panel';
            panel.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 300px;
                background: rgba(0, 0, 0, 0.9);
                border: 1px solid #ff3366;
                z-index: 1000;
                padding: 15px;
                color: white;
                border-radius: 5px;
                box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            `;
            
            // Ajouter le contenu du simulateur
            panel.innerHTML = `
                <h3 style="text-align: center; margin-top: 0;">Simulateur de Dons</h3>
                <button id="close-simulator" style="position: absolute; top: 5px; right: 5px; background: none; border: none; color: #fff; cursor: pointer; font-size: 16px;">×</button>
                <div style="margin-bottom: 15px;">
                    <label>Nom d'utilisateur:</label>
                    <input type="text" id="sim-username" value="Utilisateur${Math.floor(Math.random() * 1000)}" style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label>Montant:</label>
                    <input type="number" id="sim-amount" value="5" min="1" max="1000" style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label>Message (optionnel):</label>
                    <input type="text" id="sim-message" placeholder="Message avec votre don..." style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <button id="donate-2" style="flex: 1; margin-right: 5px; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+2€</button>
                    <button id="donate-5" style="flex: 1; margin-right: 5px; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+5€</button>
                    <button id="donate-10" style="flex: 1; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+10€</button>
                </div>
                <button id="send-donation" style="width: 100%; margin-top: 15px; background: #ff3366; border: none; color: white; padding: 10px; cursor: pointer;">Simuler le Don</button>
            `;
            
            // Ajouter le panneau au document
            document.body.appendChild(panel);
            
            // Gérer la fermeture du panneau
            document.getElementById('close-simulator').addEventListener('click', () => {
                panel.remove();
            });
            
            // Gérer les boutons de montant prédéfinis
            document.getElementById('donate-2').addEventListener('click', () => {
                document.getElementById('sim-amount').value = "2";
            });
            
            document.getElementById('donate-5').addEventListener('click', () => {
                document.getElementById('sim-amount').value = "5";
            });
            
            document.getElementById('donate-10').addEventListener('click', () => {
                document.getElementById('sim-amount').value = "10";
            });
            
            // Gérer l'envoi du don
            document.getElementById('send-donation').addEventListener('click', async () => {
                const username = document.getElementById('sim-username').value || `Utilisateur${Math.floor(Math.random() * 1000)}`;
                const amount = parseFloat(document.getElementById('sim-amount').value) || 5;
                const message = document.getElementById('sim-message').value || '';
                
                if (amount <= 0) {
                    alert('Veuillez entrer un montant positif.');
                    return;
                }
                
                try {
                    // Simuler le don via l'API
                    const response = await fetch('/api/simulate/donation', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ username, amount, message })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        // Fermer le panneau après un don réussi
                        panel.remove();
                        
                        // Appliquer directement le don à l'interface actuelle
                        simulateDonation(username, amount);
                    } else {
                        console.error('Erreur lors de la simulation du don:', data.message);
                        alert('Erreur lors de la simulation du don: ' + data.message);
                    }
                } catch (error) {
                    console.error('Erreur lors de la simulation du don:', error);
                    alert('Erreur lors de la simulation du don.');
                }
            });
        }
        
        // Ouvrir la page de configuration de l'API TikTok
        function openTikTokConfig() {
            const width = 800;
            const height = 700;
            const left = (window.innerWidth - width) / 2;
            const top = (window.innerHeight - height) / 2;
            
            const popup = window.open('tiktok_api_config.html', 'TikTokConfig', 
                `width=${width},height=${height},left=${left},top=${top},resizable=yes`);
            
            if (popup) {
                window.tikTokConfigPopup = popup;
            }
        }
        
        // Charger la configuration TikTok depuis localStorage
        function loadTikTokConfig() {
            const savedConfig = localStorage.getItem('tiktokApiConfig');
            
            if (savedConfig) {
                try {
                    window.tikTokConfig = JSON.parse(savedConfig);
                    console.log('Configuration TikTok chargée:', window.tikTokConfig);
                } catch (error) {
                    console.error('Erreur lors du chargement de la configuration TikTok:', error);
                }
            }
        }
        
        // Mettre à jour la configuration TikTok (appelé depuis la page de configuration)
        function updateTikTokConfig(config) {
            window.tikTokConfig = config;
            console.log('Configuration TikTok mise à jour:', config);
        }
        
        // Traiter un événement TikTok (appelé depuis la page de configuration ou par l'API)
        function processTikTokEvent(event) {
            console.log('Événement TikTok reçu:', event);
            
            switch (event.type) {
                case 'donation':
                    // Convertir le montant en pièces/diamants en euros
                    const convertedAmount = event.convertedAmount || 
                        (event.amount * (window.tikTokConfig?.donationConversion || 0.01));
                    
                    // Simuler un don avec le montant converti
                    simulateDonation(event.username, convertedAmount, event.giftName || 'Don TikTok');
                    
                    // Amélioration: Vérifier si c'est un don majeur pour des effets spéciaux
                    if (convertedAmount >= 50) {
                        triggerSpecialEvent(event.username);
                    } else if (convertedAmount >= 20) {
                        spawnSpecialEntity();
                    }
                    break;
                    
                case 'subscription':
                    // Traiter l'abonnement comme un don avec un montant fixe
                    const subValue = event.value || 
                        (window.tikTokConfig?.subscriptionValue || 4.99);
                    
                    simulateDonation(event.username, subValue, 'Abonnement');
                    
                    // Amélioration: Ajouter un indice spécial pour les abonnés
                    revealSpecialClue(event.username);
                    break;
                    
                case 'comment':
                    // Traiter les commentaires pour détecter les mots-clés
                    if (window.tikTokConfig?.enableComments) {
                        handleComment(event.comment, event.username);
                    }
                    break;
                    
                case 'follow':
                    // Ajouter au journal d'exploration
                    addToStoryHistory('event', `${event.username} suit maintenant le stream!`);
                    break;
                    
                case 'share':
                    // Récompenser le partage avec un petit don virtuel
                    simulateDonation(event.username, 1, 'Partage');
                    
                    // Ajouter au journal d'exploration
                    addToStoryHistory('event', `${event.username} a partagé le stream!`);
                    break;
                    
                case 'like':
                    // Reconnaître les likes en masse
                    if (event.likeCount && event.likeCount > 5) {
                        // Déclencher des effets mineurs d'ambiance
                        triggerAmbientEffect(event.likeCount);
                        
                        // Ajouter au journal d'exploration pour les likes importants
                        addToStoryHistory('event', `${event.username} a envoyé ${event.likeCount} likes!`);
                    }
                    break;
                    
                case 'importantComment':
                    // Traiter les commentaires importants spécifiquement
                    handleImportantComment(event.comment, event.username);
                    break;
                    
                case 'memberJoin':
                    // Membre rejoignant le stream
                    addToStoryHistory('discovery', `${event.username} a rejoint l'exploration!`);
                    break;
            }
        }
        
        // Fonction pour révéler un indice spécial aux abonnés
        function revealSpecialClue(username) {
            // Sélectionner un indice pas encore découvert
            const unrevealedClues = STORY_ELEMENTS.clues.filter(clue => !window.discoveredClues.includes(clue.id));
            
            if (unrevealedClues.length > 0) {
                const randomIndex = Math.floor(Math.random() * unrevealedClues.length);
                const clue = unrevealedClues[randomIndex];
                
                // Révéler un indice pour l'utilisateur
                revealClue(clue.id, username);
                
                // Ajouter un message spécial dans le journal
                addToStoryHistory('discovery', `Indice spécial révélé à ${username}: "${clue.text}"`);
            }
        }
        
        // Fonction pour gérer les commentaires importants
        function handleImportantComment(comment, username) {
            // Évaluer si le commentaire contient des mots-clés liés à l'histoire
            const storyKeywords = [
                'mystère', 'créature', 'secret', 'porte', 'symbole', 'code', 
                'énigme', 'indice', 'lumière', 'ombre', 'profondeur',
                'abîme', 'portail', 'anciens', 'artefact', 'clé'
            ];
            
            const lowerComment = comment.toLowerCase();
            const matchedKeywords = storyKeywords.filter(keyword => lowerComment.includes(keyword));
            
            if (matchedKeywords.length >= 2) {
                // Commentaire très pertinent pour l'histoire
                addToStoryHistory('discovery', `Observation de ${username}: "${comment}"`);
                
                // Potentiellement révéler un indice basé sur ce commentaire
                if (Math.random() < 0.3) {
                    // 30% de chance de révéler un indice
                    setTimeout(() => {
                        revealRandomClue(username);
                    }, 3000 + Math.random() * 5000);
                }
                
                // Pour les commentaires très pertinents, ajouter un effet visuel subtil
                flashCameraEffect(0.3);
            }
        }
        
        // Fonction pour déclencher des effets d'ambiance basés sur l'activité TikTok
        function triggerAmbientEffect(intensity) {
            // L'intensité représente combien l'effet doit être prononcé, basé sur les likes/interactions
            intensity = Math.min(intensity / 10, 1.0); // Normaliser entre 0 et 1
            
            // Types d'effets d'ambiance
            const effects = [
                'flicker', // Effet de vacillement des lumières
                'ripple',  // Effet d'ondulation sur l'eau
                'mist',    // Effet de brume temporaire
                'whisper'  // Sons subtils d'ambiance
            ];
            
            // Sélectionner un effet aléatoire
            const effect = effects[Math.floor(Math.random() * effects.length)];
            
            // Appliquer l'effet selon le type
            switch (effect) {
                case 'flicker':
                    // Faire vaciller les lumières dans le tunnel
                    flickerLights(intensity);
                    break;
                case 'ripple':
                    // Créer des ondulations sur l'eau
                    createWaterRipple(intensity);
                    break;
                case 'mist':
                    // Ajouter une brume temporaire
                    addTemporaryMist(intensity);
                    break;
                case 'whisper':
                    // Jouer des sons d'ambiance
                    playAmbientSound(intensity);
                    break;
            }
        }
        
        // Faire vaciller les lumières du tunnel
        function flickerLights(intensity) {
            // Trouver toutes les lumières dans la scène
            const lights = [];
            window.scene.traverse(function(object) {
                if (object.userData && object.userData.light) {
                    lights.push(object.userData.light);
                }
            });
            
            // Aucune lumière trouvée
            if (lights.length === 0) return;
            
            // Sauvegarder les intensités d'origine
            const originalIntensities = lights.map(light => light.intensity);
            
            // Nombre de vacillements
            const flickerCount = Math.floor(3 + intensity * 7);
            
            // Fonction pour un vacillement aléatoire
            function singleFlicker(index) {
                if (index >= flickerCount) {
                    // Restaurer les intensités d'origine
                    lights.forEach((light, i) => { 
                        if (light) light.intensity = originalIntensities[i]; 
                    });
                    return;
                }
                
                // Appliquer un vacillement aléatoire à chaque lumière
                lights.forEach((light, i) => {
                    if (light) {
                        const randomFactor = 0.3 + Math.random() * 0.7;
                        light.intensity = originalIntensities[i] * randomFactor;
                    }
                });
                
                // Planifier le prochain vacillement
                setTimeout(() => singleFlicker(index + 1), 50 + Math.random() * 150);
            }
            
            // Démarrer la séquence de vacillement
            singleFlicker(0);
        }
        
        // Créer des ondulations sur l'eau
        function createWaterRipple(intensity) {
            if (!window.waterMesh) return;
            
            // Créer un effet d'ondulation sur l'eau
            const rippleDuration = 2000 + intensity * 3000; // 2-5 secondes selon l'intensité
            const startTime = Date.now();
            const originalY = window.waterMesh.position.y;
            
            // Fonction d'animation pour l'ondulation
            function animateRipple() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / rippleDuration;
                
                if (progress >= 1) {
                    // Restaurer la position de l'eau
                    window.waterMesh.position.y = originalY;
                    return;
                }
                
                // Calcul de l'ondulation
                const amplitude = 0.05 * intensity;
                const frequency = 6 + intensity * 4;
                const ripple = amplitude * Math.sin(frequency * progress * Math.PI) * (1 - progress);
                
                // Appliquer l'ondulation
                window.waterMesh.position.y = originalY + ripple;
                
                // Continuer l'animation
                requestAnimationFrame(animateRipple);
            }
            
            // Démarrer l'animation
            animateRipple();
        }
        
        // Ajouter de la brume temporaire
        function addTemporaryMist(intensity) {
            // Vérifier si la brume existe déjà
            if (window.mistMesh) return;
            
            // Créer une sphère de brume semi-transparente
            const mistGeometry = new THREE.SphereGeometry(10, 16, 16);
            const mistMaterial = new THREE.MeshBasicMaterial({
                color: 0xccccff,
                transparent: true,
                opacity: 0
            });
            
            const mistMesh = new THREE.Mesh(mistGeometry, mistMaterial);
            mistMesh.position.set(window.boat.position.x, 0, window.boat.position.z);
            window.scene.add(mistMesh);
            window.mistMesh = mistMesh;
            
            // Durée de la brume
            const mistDuration = 3000 + intensity * 4000; // 3-7 secondes
            const startTime = Date.now();
            
            // Fonction d'animation pour la brume
            function animateMist() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / mistDuration;
                
                if (progress >= 1) {
                    // Supprimer la brume
                    window.scene.remove(mistMesh);
                    window.mistMesh = null;
                    return;
                }
                
                // Animation de l'opacité (apparition puis disparition)
                let opacity;
                if (progress < 0.3) {
                    // Apparition
                    opacity = (progress / 0.3) * 0.3 * intensity;
                } else if (progress > 0.7) {
                    // Disparition
                    opacity = ((1 - progress) / 0.3) * 0.3 * intensity;
                } else {
                    // Plateau
                    opacity = 0.3 * intensity;
                }
                
                // Appliquer l'opacité
                mistMaterial.opacity = opacity;
                
                // Continuer l'animation
                requestAnimationFrame(animateMist);
            }
            
            // Démarrer l'animation
            animateMist();
        }
        
        // Jouer un son d'ambiance
        function playAmbientSound(intensity) {
            // Si le son est désactivé, ne rien faire
            if (!window.audioEnabled) return;
            
            // Sélectionner un son d'ambiance aléatoire
            const ambientSounds = [
                'whisper', 'creak', 'drip', 'distant_echo'
            ];
            
            const sound = ambientSounds[Math.floor(Math.random() * ambientSounds.length)];
            const volume = 0.1 + intensity * 0.2; // Volume entre 0.1 et 0.3
            
            // Créer un élément audio
            const audio = new Audio();
            audio.volume = volume;
            
            // Définir la source du son
            switch (sound) {
                case 'whisper':
                    audio.src = 'sounds/whisper.mp3';
                    break;
                case 'creak':
                    audio.src = 'sounds/creak.mp3';
                    break;
                case 'drip':
                    audio.src = 'sounds/drip.mp3';
                    break;
                case 'distant_echo':
                    audio.src = 'sounds/echo.mp3';
                    break;
            }
            
            // Jouer le son
            try {
                audio.play().catch(error => {
                    console.warn('Impossible de jouer le son:', error);
                });
            } catch (error) {
                console.warn('Erreur lors de la lecture du son:', error);
            }
        }
        
        // Configuration du système de vote
        function setupVoteSystem() {
            // Gestion des clics sur les options de vote
            document.querySelectorAll('.vote-option').forEach(option => {
                option.addEventListener('click', (e) => {
                    const optionIndex = e.currentTarget.getAttribute('data-option');
                    voteForOption(optionIndex);
                });
            });
        }
        
        // ==========================================
        // FONCTIONS DE CRÉATION D'OBJETS 3D
        // ==========================================
        
        // Créer une barque avec un modèle Three.js détaillé
        function createBoat() {
            const boat = new THREE.Group();
            
            // Coque principale - forme d'une barque traditionnelle
            const hullShape = new THREE.Shape();
            // Définir un contour en forme de barque vue de dessus
            hullShape.moveTo(-0.7, -1.2);
            hullShape.quadraticCurveTo(-0.2, -1.5, 0, -1.5);
            hullShape.quadraticCurveTo(0.2, -1.5, 0.7, -1.2);
            hullShape.quadraticCurveTo(0.9, -0.8, 0.9, 0);
            hullShape.quadraticCurveTo(0.9, 0.8, 0.7, 1.2);
            hullShape.quadraticCurveTo(0.2, 1.5, 0, 1.5);
            hullShape.quadraticCurveTo(-0.2, 1.5, -0.7, 1.2);
            hullShape.quadraticCurveTo(-0.9, 0.8, -0.9, 0);
            hullShape.quadraticCurveTo(-0.9, -0.8, -0.7, -1.2);
            
            // Extruder la forme pour créer la coque 3D
            const extrudeSettings = {
                steps: 2,
                depth: 0.5,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.1,
                bevelOffset: 0,
                bevelSegments: 3
            };
            
            const hullGeometry = new THREE.ExtrudeGeometry(hullShape, extrudeSettings);
            
            // Créer un matériau pour la coque avec texture de bois
            const hullMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.7,
                metalness: 0.2
            });
            
            // Créer un effet de veine de bois (procédural)
            const woodTexture = createWoodTexture();
            hullMaterial.map = woodTexture;
            
            const hull = new THREE.Mesh(hullGeometry, hullMaterial);
            hull.rotation.x = Math.PI / 2; // Orienter correctement la barque
            boat.add(hull);
            
            // Ajouter des bancs transversaux
            const benchMaterial = new THREE.MeshStandardMaterial({
                color: 0x964B00,
                roughness: 0.8,
                metalness: 0.1
            });
            
            // Banc avant
            const frontBenchGeometry = new THREE.BoxGeometry(1.4, 0.1, 0.25);
            const frontBench = new THREE.Mesh(frontBenchGeometry, benchMaterial);
            frontBench.position.set(0, 0.3, 0.9);
            boat.add(frontBench);
            
            // Banc arrière
            const backBenchGeometry = new THREE.BoxGeometry(1.4, 0.1, 0.25);
            const backBench = new THREE.Mesh(backBenchGeometry, benchMaterial);
            backBench.position.set(0, 0.3, -0.9);
            boat.add(backBench);
            
            // Banc milieu
            const middleBenchGeometry = new THREE.BoxGeometry(1.4, 0.1, 0.25);
            const middleBench = new THREE.Mesh(middleBenchGeometry, benchMaterial);
            middleBench.position.set(0, 0.3, 0);
            boat.add(middleBench);
            
            // Ajouter une lanterne pour l'ambiance
            const lanternBase = new THREE.CylinderGeometry(0.05, 0.05, 0.2, 8);
            const lanternGlobe = new THREE.SphereGeometry(0.1, 8, 8);
            const lanternMaterial = new THREE.MeshStandardMaterial({
                color: 0x553311,
                roughness: 0.5
            });
            const lanternGlassMaterial = new THREE.MeshStandardMaterial({
                color: 0xffaa55,
                emissive: 0xff6622,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.7
            });
            
            const lanternBaseObj = new THREE.Mesh(lanternBase, lanternMaterial);
            const lanternGlobeObj = new THREE.Mesh(lanternGlobe, lanternGlassMaterial);
            lanternGlobeObj.position.y = 0.15;
            
            const lantern = new THREE.Group();
            lantern.add(lanternBaseObj);
            lantern.add(lanternGlobeObj);
            lantern.position.set(0, 0.4, 0.9);
            boat.add(lantern);
            
            // Ajouter une lumière dans la lanterne
            const lanternLight = new THREE.PointLight(0xff6622, 1, 3);
            lanternLight.position.set(0, 0.15, 0);
            lantern.add(lanternLight);
            
            // Position et échelle finale de la barque
            boat.scale.set(0.7, 0.7, 0.7);
            boat.position.y = WATER_LEVEL + 0.4;
            window.scene.add(boat);
            
            // Variables pour l'animation narrative de la barque
            boat.userData = {
                lanternLight: lanternLight,
                lanternOriginalIntensity: 1,
                narrativeState: "normal"
            };
            
            return boat;
        }
        
        // Fonction pour créer une texture de bois
        function createWoodTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            
            // Fond
            context.fillStyle = "#8B4513";
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Veines de bois
            for (let i = 0; i < 30; i++) {
                // Position et épaisseur variables
                const y = Math.random() * canvas.height;
                const width = 1 + Math.random() * 3;
                
                // Couleur de veine légèrement variable
                const brightness = 100 + Math.floor(Math.random() * 50);
                const color = `rgb(${brightness}, ${brightness * 0.6}, ${brightness * 0.4})`;
                
                context.beginPath();
                context.moveTo(0, y);
                
                // Créer une ligne ondulée
                for (let x = 0; x < canvas.width; x += canvas.width/20) {
                    const newY = y + (Math.random() - 0.5) * 15;
                    context.lineTo(x, newY);
                }
                
                context.strokeStyle = color;
                context.lineWidth = width;
                context.stroke();
            }
            
            // Noeuds du bois
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 3 + Math.random() * 8;
                
                const gradient = context.createRadialGradient(x, y, 1, x, y, radius);
                gradient.addColorStop(0, "#4B2809");
                gradient.addColorStop(1, "#8B4513");
                
                context.beginPath();
                context.arc(x, y, radius, 0, Math.PI * 2);
                context.fillStyle = gradient;
                context.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }
        
        // Créer un segment de tunnel avec rebords et portes
        function createSegment(zPosition) {
            const segment = new THREE.Group();
            segment.position.z = zPosition;
            
            // Tunnel principal
            const tunnelGeometry = new THREE.CylinderGeometry(
                TUNNEL_RADIUS, TUNNEL_RADIUS, TUNNEL_LENGTH, 16, 1, true
            );
            const tunnelMaterial = new THREE.MeshPhongMaterial({
                color: 0x333333, 
                side: THREE.BackSide
            });
            const tunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
            tunnel.rotation.x = Math.PI / 2;
            segment.add(tunnel);
            
            // Sol/eau au centre
            const waterWidth = TUNNEL_RADIUS * 1.2; // Réduire pour laisser de la place aux rebords
            const floorGeometry = new THREE.PlaneGeometry(
                waterWidth, TUNNEL_LENGTH
            );
            const waterMaterial = new THREE.MeshPhongMaterial({
                color: 0x006666,
                transparent: true,
                opacity: 0.7
            });
            const floor = new THREE.Mesh(floorGeometry, waterMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = WATER_LEVEL;
            segment.add(floor);
            
            // Ajouter un effet de miroitement à l'eau
            segment.userData.water = floor;
            segment.userData.waterBaseColor = new THREE.Color(0x006666);
            
            // Ajouter des rebords et des portes régulièrement
            for (let z = 0; z < TUNNEL_LENGTH; z += 5) {
                // Position en z
                const doorZ = z - TUNNEL_LENGTH / 2;
                
                // Déterminer si cette porte est spéciale (narrative)
                const isSpecialDoor = Math.random() < 0.05 + (window.storyProgress * 0.02);
                
                // Porte gauche
                const leftDoor = createDoor(isSpecialDoor);
                leftDoor.position.set(-TUNNEL_RADIUS + 0.2, WATER_LEVEL + 1.5, doorZ);
                leftDoor.rotation.y = Math.PI/2; // Rotation pour que la porte soit perpendiculaire à la paroi du tunnel
                leftDoor.rotation.z = 0; // Assurer que la porte est verticale
                segment.add(leftDoor);
                
                if (isSpecialDoor) {
                    registerSpecialDoor(leftDoor);
                }
                
                window.doors.push(leftDoor);
                
                // Porte droite - perpendiculaire à la paroi et verticale
                const rightDoor = createDoor(isSpecialDoor);
                rightDoor.position.set(TUNNEL_RADIUS - 0.2, WATER_LEVEL + 1.5, doorZ);
                rightDoor.rotation.y = -Math.PI/2; // Rotation pour que la porte soit perpendiculaire à la paroi du tunnel
                rightDoor.rotation.z = 0; // Assurer que la porte est verticale
                segment.add(rightDoor);
                
                if (isSpecialDoor) {
                    registerSpecialDoor(rightDoor);
                }
                
                window.doors.push(rightDoor);
                
                // Rebords pour marcher (gauche et droite)
                createWalkway(segment, -TUNNEL_RADIUS + 0.6, WATER_LEVEL + 0.1, doorZ - 2.5, 5);
                createWalkway(segment, TUNNEL_RADIUS - 0.6, WATER_LEVEL + 0.1, doorZ - 2.5, 5);
                
                // Lumières murales
                createWallLight(segment, -TUNNEL_RADIUS + 0.1, WATER_LEVEL + 2, doorZ - 1.5);
                createWallLight(segment, TUNNEL_RADIUS - 0.1, WATER_LEVEL + 2, doorZ - 1.5);
            }
            
            // Lumière générale du tunnel (faible)
            const ambientLight = new THREE.PointLight(0x333333, 0.3, TUNNEL_RADIUS * 2);
            ambientLight.position.set(0, 0, 0);
            segment.add(ambientLight);
            
            // Stocker la position et les données supplémentaires
            segment.userData = { 
                ...segment.userData,
                zPosition: zPosition,
                narrativeZone: determineNarrativeZone(zPosition),
                ambientLight: ambientLight
            };
            
            window.scene.add(segment);
            window.segments.push(segment);
            return segment;
        }
        
        // Créer un rebord pour marcher
        function createWalkway(parent, x, y, z, length) {
            // Plateforme pour marcher
            const walkwayGeometry = new THREE.BoxGeometry(1, 0.2, length);
            const walkwayMaterial = new THREE.MeshPhongMaterial({color: 0x555555});
            const walkway = new THREE.Mesh(walkwayGeometry, walkwayMaterial);
            walkway.position.set(x, y, z + length/2);
            parent.add(walkway);
            
            // Support métallique
            for (let i = 0; i < length; i += 1.5) {
                const supportGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 6);
                const supportMaterial = new THREE.MeshPhongMaterial({color: 0x777777});
                const support = new THREE.Mesh(supportGeometry, supportMaterial);
                support.position.set(x, y - 0.35, z + i);
                parent.add(support);
            }
            
            return walkway;
        }
        
        // Créer une lumière murale
        function createWallLight(parent, x, y, z) {
            // Groupe pour la lumière
            const lightGroup = new THREE.Group();
            lightGroup.position.set(x, y, z);
            
            // Support mural
            const baseGeometry = new THREE.BoxGeometry(0.1, 0.3, 0.3);
            const baseMaterial = new THREE.MeshPhongMaterial({color: 0x333333});
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            
            // Orientation selon le côté
            if (x < 0) { // Côté gauche
                base.rotation.y = 0;
                lightGroup.rotation.y = 0;
            } else { // Côté droit
                base.rotation.y = Math.PI;
                lightGroup.rotation.y = Math.PI;
            }
            
            lightGroup.add(base);
            
            // Ampoule/Globe
            const bulbGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            
            // La couleur varie en fonction de la progression de l'histoire
            const colorProgress = Math.min(window.storyProgress, 1);
            const bulbColor = new THREE.Color().setHSL(
                0.1 - (colorProgress * 0.1), // De jaune vers rouge
                0.7,
                0.5 + (colorProgress * 0.2) // Devient plus brillant
            );
            
            const bulbMaterial = new THREE.MeshBasicMaterial({
                color: bulbColor
                // emissive et emissiveIntensity sont retirés car non supportés par MeshBasicMaterial
            });
            
            const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
            bulb.position.x = (x < 0) ? 0.1 : -0.1; // Position selon le côté
            lightGroup.add(bulb);
            
            // Lumière
            const intensity = 0.5 + Math.random() * 0.5;
            const light = new THREE.PointLight(bulbColor, intensity, 3);
            light.position.copy(bulb.position);
            lightGroup.add(light);
            
            // Ajouter des données pour les animations
            lightGroup.userData = {
                bulb: bulb,
                light: light,
                originalIntensity: intensity,
                flicker: Math.random() < 0.3, // 30% de chance de scintillement
                flickerSpeed: 0.5 + Math.random() * 2,
                originalColor: bulbColor.clone()
            };
            
            parent.add(lightGroup);
            return lightGroup;
        }
        
        // Créer une porte avec une orientation correcte et thématique
        function createDoor(isSpecial = false) {
            const door = new THREE.Group();
            
            // Couleurs différentes selon le type de porte
            let doorColor, frameColor, detailsColor;
            let doorSymbol = null;
            
            if (isSpecial) {
                // Porte spéciale avec couleur et caractéristiques uniques
                const specialType = Math.floor(Math.random() * 5);
                
                switch(specialType) {
                    case 0: // Porte mystérieuse avec symboles
                        frameColor = 0x443322;
                        doorColor = 0x221100;
                        detailsColor = 0xaa8866;
                        doorSymbol = "symbol";
                        break;
                    case 1: // Porte rouge sang
                        frameColor = 0x662222;
                        doorColor = 0x990000;
                        detailsColor = 0xaa3333;
                        doorSymbol = "blood";
                        break;
                    case 2: // Porte luminescente
                        frameColor = 0x443355;
                        doorColor = 0x334466;
                        detailsColor = 0x88aaff;
                        doorSymbol = "glow";
                        break;
                    case 3: // Porte métallique rouillée
                        frameColor = 0x775533;
                        doorColor = 0x996633;
                        detailsColor = 0xcc8844;
                        doorSymbol = "rust";
                        break;
                    case 4: // Porte avec marques de griffes
                        frameColor = 0x554433;
                        doorColor = 0x443322;
                        detailsColor = 0x333333;
                        doorSymbol = "claw";
                        break;
                }
            } else {
                // Porte standard
                frameColor = 0x553322;
                doorColor = 0x332211;
                detailsColor = 0x888888;
            }
            
            // Cadre de porte
            const frameGeometry = new THREE.BoxGeometry(2, 3, 0.2);
            const frameMaterial = new THREE.MeshPhongMaterial({color: frameColor});
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            door.add(frame);
            
            // La porte elle-même (panneau)
            const doorGeometry = new THREE.BoxGeometry(1.8, 2.8, 0.1);
            const doorMaterial = new THREE.MeshPhongMaterial({color: doorColor});
            const doorMesh = new THREE.Mesh(doorGeometry, doorMaterial);
            // Positionner la porte correctement pour l'animation
            doorMesh.position.z = -0.15; 
            door.add(doorMesh);
            
            // Poignée de porte
            const handleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const handleMaterial = new THREE.MeshPhongMaterial({color: detailsColor});
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.set(0.5, 0, -0.15); // À droite de la porte vue de face
            door.add(handle);
            
            // Ajout de numéro ou symbole de porte
            const doorNumber = Math.floor(Math.random() * 900) + 100;
            
            // Plaque de numéro/symbole
            const plateGeometry = new THREE.PlaneGeometry(0.4, 0.2);
            const plateMaterial = new THREE.MeshPhongMaterial({
                color: detailsColor,
                side: THREE.DoubleSide
            });
            const plate = new THREE.Mesh(plateGeometry, plateMaterial);
            plate.position.set(0, 1, -0.11);
            door.add(plate);
            
            // Ajouter un symbole spécial si c'est une porte spéciale
            if (isSpecial && doorSymbol) {
                // Créer le symbole selon le type
                switch(doorSymbol) {
                    case "symbol":
                        // Ajouter un symbole ésotérique
                        addSymbolToDoor(door, plate);
                        break;
                    case "blood":
                        // Ajouter des taches de sang
                        addBloodToDoor(door, doorMesh);
                        break;
                    case "glow":
                        // Ajouter un effet lumineux
                        addGlowToDoor(door, doorMesh);
                        break;
                    case "rust":
                        // Ajouter des taches de rouille
                        addRustToDoor(door, doorMesh);
                        break;
                    case "claw":
                        // Ajouter des marques de griffes
                        addClawMarksToDoor(door, doorMesh);
                        break;
                }
            }
            
            // Données pour l'animation et statut narratif
            door.userData = {
                doorMesh: doorMesh,
                animating: false,
                doorNumber: doorNumber,
                isSpecial: isSpecial,
                doorSymbol: doorSymbol,
                activated: false,
                containsClue: isSpecial && (Math.random() < 0.6), // 60% des portes spéciales contiennent un indice
                containsEntity: isSpecial && (Math.random() < 0.3), // 30% des portes spéciales contiennent une entité
                entityType: isSpecial ? Math.floor(Math.random() * 7) : null,
                narrativeElement: null
            };
            
            return door;
        }
        
        // Ajouter un symbole ésotérique à une porte
        function addSymbolToDoor(door, plate) {
            // Créer un canvas pour dessiner le symbole
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Fond transparent
            ctx.fillStyle = 'rgba(0, 0, 0, 0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Choisir un symbole aléatoire
            const symbolType = Math.floor(Math.random() * 5);
            
            // Dessiner le symbole en blanc
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.fillStyle = 'white';
            
            switch(symbolType) {
                case 0: // Cercle avec triangle
                    ctx.beginPath();
                    ctx.arc(64, 64, 40, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(64, 34);
                    ctx.lineTo(94, 94);
                    ctx.lineTo(34, 94);
                    ctx.closePath();
                    ctx.stroke();
                    break;
                    
                case 1: // Spirale
                    ctx.beginPath();
                    let radius = 5;
                    let angle = 0;
                    let x = 64;
                    let y = 64;
                    
                    for (let i = 0; i < 200; i++) {
                        angle += 0.1;
                        radius += 0.2;
                        const newX = 64 + Math.cos(angle) * radius;
                        const newY = 64 + Math.sin(angle) * radius;
                        ctx.lineTo(newX, newY);
                        x = newX;
                        y = newY;
                        
                        if (radius > 40) break;
                    }
                    ctx.stroke();
                    break;
                    
                case 2: // Œil
                    ctx.beginPath();
                    ctx.ellipse(64, 64, 45, 25, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(64, 64, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(64, 39);
                    ctx.lineTo(64, 89);
                    ctx.stroke();
                    break;
                    
                case 3: // Runes
                    for (let i = 0; i < 3; i++) {
                        const startX = 34 + i * 30;
                        ctx.beginPath();
                        
                        // Runes aléatoires
                        switch(Math.floor(Math.random() * 5)) {
                            case 0: // F-like
                                ctx.moveTo(startX, 44);
                                ctx.lineTo(startX, 94);
                                ctx.moveTo(startX, 44);
                                ctx.lineTo(startX + 20, 44);
                                ctx.moveTo(startX, 69);
                                ctx.lineTo(startX + 15, 69);
                                break;
                            case 1: // X-like
                                ctx.moveTo(startX - 10, 44);
                                ctx.lineTo(startX + 10, 94);
                                ctx.moveTo(startX + 10, 44);
                                ctx.lineTo(startX - 10, 94);
                                break;
                            case 2: // O with line
                                ctx.arc(startX, 69, 25, 0, Math.PI * 2);
                                ctx.moveTo(startX - 25, 69);
                                ctx.lineTo(startX + 25, 69);
                                break;
                            case 3: // Arrow
                                ctx.moveTo(startX, 44);
                                ctx.lineTo(startX, 94);
                                ctx.moveTo(startX - 10, 54);
                                ctx.lineTo(startX, 44);
                                ctx.lineTo(startX + 10, 54);
                                break;
                            case 4: // Wave
                                ctx.moveTo(startX - 15, 69);
                                for (let j = 0; j < 30; j++) {
                                    ctx.lineTo(startX - 15 + j, 69 + Math.sin(j * 0.3) * 15);
                                }
                                break;
                        }
                        
                        ctx.stroke();
                    }
                    break;
                    
                case 4: // Constellation
                    // Points
                    const points = [];
                    for (let i = 0; i < 7; i++) {
                        points.push({
                            x: 30 + Math.random() * 68,
                            y: 30 + Math.random() * 68,
                            r: 2 + Math.random() * 3
                        });
                    }
                    
                    // Dessiner les points
                    points.forEach(point => {
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, point.r, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Relier certains points
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) {
                        if (Math.random() < 0.7) { // 70% de chance de relier deux points
                            ctx.lineTo(points[i].x, points[i].y);
                        } else {
                            ctx.moveTo(points[i].x, points[i].y);
                        }
                    }
                    ctx.stroke();
                    break;
            }
            
            // Créer une texture à partir du canvas
            const symbolTexture = new THREE.CanvasTexture(canvas);
            
            // Créer un matériau avec cette texture
            const symbolMaterial = new THREE.MeshBasicMaterial({
                map: symbolTexture,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            
            // Remplacer le matériau de la plaque
            plate.material = symbolMaterial;
            
            // Agrandir la plaque pour le symbole
            plate.scale.set(2, 2, 1);
            
            // Stocker les données pour animation
            door.userData.symbolType = symbolType;
            door.userData.symbolTexture = symbolTexture;
        }
        
        // Ajouter des taches de sang à une porte
        function addBloodToDoor(door, doorMesh) {
            // Créer un canvas pour dessiner les taches
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Copier la couleur de base de la porte
            ctx.fillStyle = '#990000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner des taches de sang aléatoires
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 10 + Math.random() * 50;
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, 'rgba(120, 0, 0, 0.9)');
                gradient.addColorStop(0.7, 'rgba(80, 0, 0, 0.6)');
                gradient.addColorStop(1, 'rgba(80, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Dessiner des traînées de sang coulant
            for (let i = 0; i < 5; i++) {
                const startX = Math.random() * canvas.width;
                const startY = Math.random() * (canvas.height / 2); // Commencer dans la moitié supérieure
                
                ctx.strokeStyle = 'rgba(100, 0, 0, 0.8)';
                ctx.lineWidth = 3 + Math.random() * 8;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                
                let currentX = startX;
                let currentY = startY;
                
                // Créer une ligne descendante avec zigzags aléatoires
                const length = 50 + Math.random() * 200;
                for (let j = 0; j < length; j += 10) {
                    currentY += 10;
                    currentX += (Math.random() - 0.5) * 15;
                    
                    // Réduire progressivement l'épaisseur de la ligne
                    ctx.lineWidth = Math.max(1, ctx.lineWidth - 0.2);
                    
                    ctx.lineTo(currentX, currentY);
                    
                    if (currentY > canvas.height) break;
                }
                
                ctx.stroke();
            }
            
            // Créer une texture à partir du canvas
            const bloodTexture = new THREE.CanvasTexture(canvas);
            
            // Appliquer la texture à la porte
            const bloodMaterial = new THREE.MeshStandardMaterial({
                map: bloodTexture,
                color: 0x990000,
                roughness: 0.7,
                metalness: 0.2
            });
            
            doorMesh.material = bloodMaterial;
        }
        
        // Ajouter un effet lumineux à une porte
        function addGlowToDoor(door, doorMesh) {
            // Créer un matériau avec émission pour l'effet lumineux
            const glowMaterial = new THREE.MeshStandardMaterial({
                color: 0x334466,
                emissive: 0x88aaff,
                emissiveIntensity: 0.5,
                roughness: 0.4,
                metalness: 0.6
            });
            
            doorMesh.material = glowMaterial;
            
            // Ajouter une lumière pour renforcer l'effet
            const glowLight = new THREE.PointLight(0x88aaff, 0.8, 1);
            glowLight.position.set(0, 0, -0.1);
            doorMesh.add(glowLight);
            
            // Stocker la lumière pour l'animation
            door.userData.glowLight = glowLight;
            door.userData.originalIntensity = 0.8;
        }
        
        // Ajouter des taches de rouille à une porte
        function addRustToDoor(door, doorMesh) {
            // Créer un canvas pour dessiner la rouille
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Couleur de base métallique
            ctx.fillStyle = '#996633';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Ajouter une texture métallique de base
            for (let i = 0; i < 20; i++) {
                ctx.strokeStyle = `rgba(153, 122, 102, ${Math.random() * 0.3})`;
                ctx.lineWidth = 1 + Math.random() * 2;
                
                ctx.beginPath();
                ctx.moveTo(0, Math.random() * canvas.height);
                ctx.lineTo(canvas.width, Math.random() * canvas.height);
                ctx.stroke();
            }
            
            // Ajouter des taches de rouille
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 5 + Math.random() * 40;
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, 'rgba(180, 60, 20, 0.9)');
                gradient.addColorStop(0.6, 'rgba(160, 80, 30, 0.6)');
                gradient.addColorStop(1, 'rgba(153, 102, 51, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Ajouter quelques trous de rouille
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 2 + Math.random() * 6;
                
                ctx.fillStyle = 'rgba(30, 20, 10, 0.8)';
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Ajouter un halo de rouille intense autour du trou
                const holeGradient = ctx.createRadialGradient(x, y, radius, x, y, radius * 3);
                holeGradient.addColorStop(0, 'rgba(180, 60, 20, 0.9)');
                holeGradient.addColorStop(1, 'rgba(180, 60, 20, 0)');
                
                ctx.fillStyle = holeGradient;
                ctx.beginPath();
                ctx.arc(x, y, radius * 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Créer une texture à partir du canvas
            const rustTexture = new THREE.CanvasTexture(canvas);
            
            // Appliquer la texture à la porte
            const rustMaterial = new THREE.MeshStandardMaterial({
                map: rustTexture,
                roughness: 0.9,
                metalness: 0.4
            });
            
            doorMesh.material = rustMaterial;
        }
        
        // Ajouter des marques de griffes à une porte
        function addClawMarksToDoor(door, doorMesh) {
            // Créer un canvas pour dessiner les marques
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Couleur de base de la porte
            ctx.fillStyle = '#443322';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner des marques de griffes
            const clawSets = Math.floor(Math.random() * 3) + 2; // 2-4 sets de griffes
            
            for (let set = 0; set < clawSets; set++) {
                const startX = 50 + Math.random() * (canvas.width - 100);
                const startY = 50 + Math.random() * (canvas.height - 100);
                const angle = Math.random() * Math.PI / 4 - Math.PI / 8; // Angle aléatoire léger
                const length = 100 + Math.random() * 200;
                
                // 3-5 griffes par set
                const claws = Math.floor(Math.random() * 3) + 3;
                const spacing = 10 + Math.random() * 15;
                
                for (let claw = 0; claw < claws; claw++) {
                    // Calculer le décalage perpendiculaire à l'angle
                    const offsetX = Math.sin(angle) * spacing * (claw - (claws - 1) / 2);
                    const offsetY = -Math.cos(angle) * spacing * (claw - (claws - 1) / 2);
                    
                    ctx.strokeStyle = '#221100';
                    ctx.lineWidth = 3 + Math.random() * 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(startX + offsetX, startY + offsetY);
                    
                    // Ligne principale
                    const endX = startX + Math.cos(angle) * length + offsetX;
                    const endY = startY + Math.sin(angle) * length + offsetY;
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    // Ajouter une ligne plus claire pour montrer le bois exposé
                    ctx.strokeStyle = 'rgba(200, 150, 100, 0.7)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(startX + offsetX + 1, startY + offsetY + 1);
                    ctx.lineTo(endX + 1, endY + 1);
                    ctx.stroke();
                }
            }
            
            // Créer une texture à partir du canvas
            const clawTexture = new THREE.CanvasTexture(canvas);
            
            // Appliquer la texture à la porte
            const clawMaterial = new THREE.MeshStandardMaterial({
                map: clawTexture,
                roughness: 0.8,
                metalness: 0.1
            });
            
            doorMesh.material = clawMaterial;
        }
        
        // Déterminer la zone narrative en fonction de la position
        function determineNarrativeZone(zPosition) {
            // La progression narrative est déterminée par la distance parcourue
            // Plus on s'enfonce dans le tunnel, plus l'histoire avance
            const absolutePosition = Math.abs(zPosition);
            
            // Secteurs déterminés par les paliers de milestone
            if (absolutePosition < 50) return "prologue";
            if (absolutePosition < 150) return "secteur2";
            if (absolutePosition < 300) return "secteur3";
            if (absolutePosition < 500) return "secteur4";
            if (absolutePosition < 800) return "secteur5";
            if (absolutePosition < 1200) return "secteur6";
            if (absolutePosition < 1800) return "secteur7";
            return "finale";
        }
        
        // Enregistrer une porte spéciale
        function registerSpecialDoor(door) {
            const doorId = "door_" + Math.floor(Math.random() * 10000);
            window.specialDoors[doorId] = door;
            door.userData.doorId = doorId;
            
            // Si nous avons des indices non découverts, attribuer l'un d'eux à cette porte
            const availableClues = STORY_ELEMENTS.clues.filter(
                clue => !window.discoveredClues.includes(clue.id)
            );
            
            if (availableClues.length > 0 && door.userData.containsClue) {
                const randomClue = availableClues[Math.floor(Math.random() * availableClues.length)];
                door.userData.narrativeElement = {
                    type: "clue",
                    data: randomClue
                };
            }
        }
        
        // ==========================================
        // FONCTIONS D'ANIMATION ET INTERACTION
        // ==========================================
        
        // Animer une porte et révéler son contenu
        function animateDoor(door) {
            if (!door || door.userData.animating) return;
            
            door.userData.animating = true;
            const doorMesh = door.userData.doorMesh;
            const originalPosition = -0.15; // Position initiale
            
            // Incrémenter le compteur de portes activées
            window.activatedDoors++;
            
            // Si c'est une porte spéciale, la marquer comme activée
            if (door.userData.isSpecial && !door.userData.activated) {
                door.userData.activated = true;
                
                // Révéler un indice ou déclencher un événement narratif si applicable
                if (door.userData.narrativeElement) {
                    handleNarrativeElement(door.userData.narrativeElement);
                }
            }
            
            // Créer ou récupérer l'élément mystérieux derrière la porte
            let mysteryElement = null;
            
            if (!door.userData.mysteryElement) {
                // Déterminer le type d'élément mystérieux
                const entityType = door.userData.entityType || Math.floor(Math.random() * 7);
                
                // Si la porte est spéciale, plus de chance d'avoir une entité complexe
                const mysteryType = door.userData.isSpecial ? 
                    Math.min(6, Math.floor(Math.random() * 8)) : // Favorise les entités 0-6
                    Math.floor(Math.random() * 7); // Distribution uniforme
                
                mysteryElement = createMysteryElement(mysteryType, entityType);
                
                // Positionner l'élément derrière la porte
                const doorPosition = new THREE.Vector3();
                door.getWorldPosition(doorPosition);
                
                // Ajuster la position en fonction de l'orientation de la porte
                const doorDirection = new THREE.Vector3(0, 0, -1);
                doorDirection.applyQuaternion(door.quaternion);
                
                // Placer l'élément derrière la porte à une distance appropriée
                mysteryElement.position.copy(doorPosition);
                mysteryElement.position.add(doorDirection.multiplyScalar(1.5));
                
                // Attacher l'élément à la porte
                door.userData.mysteryElement = mysteryElement;
                door.userData.mysteryType = mysteryType;
                
                // Ajouter l'élément à la scène
                window.scene.add(mysteryElement);
                
                // Stocker dans la liste globale pour les mises à jour
                window.mysteryElements[mysteryElement.uuid] = mysteryElement;
            } else {
                mysteryElement = door.userData.mysteryElement;
            }
            
            // Animation d'ouverture puis de fermeture
            let openAmount = 0;
            let opening = true;
            let revealSound = false;
            let effectTriggered = false;
            
            const interval = setInterval(() => {
                if (opening) {
                    // Phase d'ouverture
                    openAmount += 0.02;
                    
                    // Jouer un son/effet à mi-ouverture
                    if (openAmount >= 0.15 && !revealSound) {
                        playMysterySound(door.userData.mysteryType || 0);
                        revealSound = true;
                    }
                    
                    // Limitation de l'ouverture maximale
                    if (openAmount >= 0.3) {
                        opening = false;
                        
                        // Déclencher un effet spécial une seule fois
                        if (!effectTriggered) {
                            triggerMysteryEffect(door.userData.mysteryType || 0, mysteryElement);
                            effectTriggered = true;
                        }
                    }
                } else {
                    // Phase de fermeture
                    openAmount -= 0.02;
                    
                    // Vérification fin de fermeture
                    if (openAmount <= 0) {
                        openAmount = 0;
                        clearInterval(interval);
                        door.userData.animating = false;
                        
                        // Ne pas supprimer l'élément mystérieux pour permettre des interactions continues
                        // avec le même élément si la porte est rouverte
                    }
                }
                
                // Appliquer le mouvement de la porte correctement
                doorMesh.position.z = originalPosition - openAmount;
            }, 50);
        }
        
        // Créer un élément mystérieux
        function createMysteryElement(type, entityVariant = 0) {
            const group = new THREE.Group();
            
            switch (type) {
                case 0: // Yeux brillants
                    const glowingEyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const glowingEyeMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
                    
                    const glowingLeftEye = new THREE.Mesh(glowingEyeGeometry, glowingEyeMaterial);
                    glowingLeftEye.position.x = 0.2;
                    group.add(glowingLeftEye);
                    
                    const glowingRightEye = new THREE.Mesh(glowingEyeGeometry, glowingEyeMaterial);
                    glowingRightEye.position.x = -0.2;
                    group.add(glowingRightEye);
                    
                    // Animation de clignotement
                    group.userData.update = (time) => {
                        const blink = Math.sin(time * 10) > 0.7;
                        glowingLeftEye.visible = glowingRightEye.visible = blink;
                    };
                    break;
                    
                case 1: // Tentacule ondulante
                    const tentacleGeometry = new THREE.CylinderGeometry(0.1, 0.02, 1.5, 8);
                    const tentacleMaterial = new THREE.MeshPhongMaterial({
                        color: 0x660066,
                        specular: 0x555555,
                        shininess: 30
                    });
                    
                    // Créer plusieurs segments pour la tentacule
                    const segments = 5;
                    const tentacleSegments = [];
                    
                    for (let i = 0; i < segments; i++) {
                        const segment = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.1 - (i * 0.02), 0.08 - (i * 0.02), 0.4, 8),
                            tentacleMaterial
                        );
                        segment.position.y = -i * 0.3;
                        if (i > 0) {
                            segment.position.z = 0.1;
                        }
                        
                        if (i > 0) {
                            tentacleSegments[i-1].add(segment);
                        } else {
                            group.add(segment);
                        }
                        
                        tentacleSegments.push(segment);
                    }
                    
                    // Animation d'ondulation
                    group.userData.update = (time) => {
                        tentacleSegments.forEach((segment, index) => {
                            segment.rotation.x = Math.sin(time * 3 + index * 0.5) * 0.3;
                            segment.rotation.z = Math.cos(time * 2 + index * 0.5) * 0.3;
                        });
                    };
                    break;
                    
                case 2: // Silhouette sombre
                    const torsoGeometry = new THREE.BoxGeometry(0.5, 0.8, 0.3);
                    const headGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                    const limbGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
                    
                    const shadowMaterial = new THREE.MeshBasicMaterial({
                        color: 0x000000,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const torso = new THREE.Mesh(torsoGeometry, shadowMaterial);
                    group.add(torso);
                    
                    const head = new THREE.Mesh(headGeometry, shadowMaterial);
                    head.position.y = 0.5;
                    group.add(head);
                    
                    // Membres
                    const arms = [];
                    for (let i = 0; i < 2; i++) {
                        const arm = new THREE.Mesh(limbGeometry, shadowMaterial);
                        arm.position.set(i === 0 ? -0.3 : 0.3, 0.1, 0);
                        arm.rotation.z = i === 0 ? Math.PI/4 : -Math.PI/4;
                        group.add(arm);
                        arms.push(arm);
                    }
                    
                    const legs = [];
                    for (let i = 0; i < 2; i++) {
                        const leg = new THREE.Mesh(limbGeometry, shadowMaterial);
                        leg.position.set(i === 0 ? -0.15 : 0.15, -0.6, 0);
                        group.add(leg);
                        legs.push(leg);
                    }
                    
                    // Animation d'agitation
                    group.userData.update = (time) => {
                        head.rotation.y = Math.sin(time * 2) * 0.5;
                        arms.forEach((arm, index) => {
                            arm.rotation.x = Math.sin(time * 3 + index) * 0.2;
                        });
                        legs.forEach((leg, index) => {
                            leg.rotation.x = Math.sin(time * 2 + index * Math.PI) * 0.1;
                        });
                        
                        group.position.y = Math.sin(time * 2) * 0.05;
                    };
                    break;
                    
                case 3: // Objet flottant lumineux
                    const coreGeometry = new THREE.OctahedronGeometry(0.2, 1);
                    const coreMaterial = new THREE.MeshBasicMaterial({
                        color: 0x88ffff,
                        wireframe: true
                    });
                    
                    const core = new THREE.Mesh(coreGeometry, coreMaterial);
                    group.add(core);
                    
                    // Lumière interne
                    const coreLight = new THREE.PointLight(0x88ffff, 1, 3);
                    core.add(coreLight);
                    
                    // Particules orbitales
                    const particles = [];
                    const particleGeometry = new THREE.SphereGeometry(0.03, 4, 4);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff
                    });
                    
                    for (let i = 0; i < 8; i++) {
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        particle.userData = {
                            orbitRadius: 0.3 + Math.random() * 0.2,
                            orbitSpeed: 0.5 + Math.random() * 2,
                            orbitOffset: Math.random() * Math.PI * 2,
                            elevation: (Math.random() - 0.5) * 0.3
                        };
                        group.add(particle);
                        particles.push(particle);
                    }
                    
                    // Animation d'orbite
                    group.userData.update = (time) => {
                        core.rotation.x = time * 0.5;
                        core.rotation.y = time * 0.8;
                        
                        particles.forEach(particle => {
                            const orbit = particle.userData;
                            particle.position.x = Math.cos(time * orbit.orbitSpeed + orbit.orbitOffset) * orbit.orbitRadius;
                            particle.position.z = Math.sin(time * orbit.orbitSpeed + orbit.orbitOffset) * orbit.orbitRadius;
                            particle.position.y = orbit.elevation + Math.sin(time * 2) * 0.1;
                        });
                        
                        coreLight.intensity = 0.7 + Math.sin(time * 5) * 0.3;
                    };
                    break;
                    
                case 4: // Visage fantomatique
                    const faceGeometry = new THREE.PlaneGeometry(0.6, 0.8);
                    
                    // Créer une texture dynamique pour le visage
                    const canvas = document.createElement('canvas');
                    canvas.width = 256;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    
                    // Fond transparent
                    ctx.fillStyle = 'rgba(0, 0, 0, 0)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Dessiner un visage de base
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(128, 120, 90, 120, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Yeux
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.ellipse(90, 100, 20, 25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.ellipse(166, 100, 20, 25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bouche
                    ctx.beginPath();
                    ctx.ellipse(128, 160, 40, 20, 0, 0, Math.PI);
                    ctx.fill();
                    
                    const faceTexture = new THREE.CanvasTexture(canvas);
                    const faceMaterial = new THREE.MeshBasicMaterial({
                        map: faceTexture,
                        transparent: true,
                        opacity: 0.7,
                        side: THREE.DoubleSide
                    });
                    
                    const face = new THREE.Mesh(faceGeometry, faceMaterial);
                    group.add(face);
                    
                    // Animation du visage
                    group.userData.canvas = canvas;
                    group.userData.texture = faceTexture;
                    group.userData.context = ctx;
                    
                    group.userData.update = (time) => {
                        const ctx = group.userData.context;
                        const canvas = group.userData.canvas;
                        
                        // Effacer et redessiner
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Visage de base
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.beginPath();
                        ctx.ellipse(128, 120, 90, 120, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Yeux animés
                        const eyeScaleY = Math.max(0.1, Math.sin(time * 4) * 0.5 + 0.5);
                        
                        ctx.fillStyle = '#000000';
                        ctx.beginPath();
                        ctx.ellipse(90, 100, 20, 25 * eyeScaleY, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.ellipse(166, 100, 20, 25 * eyeScaleY, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Bouche animée
                        const mouthOpen = 0.3 + Math.sin(time * 2) * 0.2;
                        ctx.beginPath();
                        ctx.ellipse(128, 160, 40, 20 * mouthOpen, 0, 0, Math.PI);
                        ctx.fill();
                        
                        // Mettre à jour la texture
                        group.userData.texture.needsUpdate = true;
                        
                        // Mouvement flottant
                        group.position.y = Math.sin(time * 1.5) * 0.1;
                        face.rotation.y = Math.sin(time) * 0.2;
                    };
                    break;
                    
                case 5: // Portail énergétique
                    const ringGeometry = new THREE.TorusGeometry(0.3, 0.03, 16, 32);
                    const ringMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffaa00,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    group.add(ring);
                    
                    // Ajouter des anneaux supplémentaires
                    const rings = [ring];
                    for (let i = 1; i < 3; i++) {
                        const newRing = new THREE.Mesh(
                            new THREE.TorusGeometry(0.3, 0.02, 16, 32),
                            new THREE.MeshBasicMaterial({
                                color: 0xffaa00,
                                transparent: true,
                                opacity: 0.5 - (i * 0.1)
                            })
                        );
                        rings.push(newRing);
                        group.add(newRing);
                    }
                    
                    // Centre du portail
                    const centerGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                    const centerMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.5
                    });
                    
                    const center = new THREE.Mesh(centerGeometry, centerMaterial);
                    group.add(center);
                    
                    // Lumière du portail
                    const portalLight = new THREE.PointLight(0xffaa00, 1, 3);
                    group.add(portalLight);
                    
                    // Animation du portail
                    group.userData.update = (time) => {
                        rings.forEach((ring, i) => {
                            ring.rotation.x = time * (1 + i * 0.2);
                            ring.rotation.y = time * (0.5 + i * 0.1);
                            
                            const scalePulse = 1 + Math.sin(time * (3 + i)) * 0.1;
                            ring.scale.set(scalePulse, scalePulse, 1);
                        });
                        
                        center.scale.setScalar(0.8 + Math.sin(time * 4) * 0.2);
                        portalLight.intensity = 0.7 + Math.sin(time * 5) * 0.3;
                    };
                    break;
                    
                case 6: // Créature obscure
                    // Remplacer CapsuleGeometry (non disponible en r128) par une combinaison de cylindre et sphères
                    const body = new THREE.Group();
                    
                    // Cylindre pour le corps
                    const bodyMainGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 12);
                    const bodyMaterial = new THREE.MeshPhongMaterial({
                        color: 0x330000,
                        specular: 0x111111,
                        shininess: 50
                    });
                    const bodyMain = new THREE.Mesh(bodyMainGeometry, bodyMaterial);
                    body.add(bodyMain);
                    
                    // Sphères pour arrondir les extrémités (effet capsule)
                    const topSphereGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                    const topSphere = new THREE.Mesh(topSphereGeometry, bodyMaterial);
                    topSphere.position.y = 0.2;
                    body.add(topSphere);
                    
                    const bottomSphereGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                    const bottomSphere = new THREE.Mesh(bottomSphereGeometry, bodyMaterial);
                    bottomSphere.position.y = -0.2;
                    body.add(bottomSphere);
                    
                    group.add(body);
                    
                    // Membres
                    const limbs = [];
                    const limbMaterial = new THREE.MeshPhongMaterial({
                        color: 0x220000,
                        specular: 0x111111,
                        shininess: 30
                    });
                    
                    for (let i = 0; i < 6; i++) {
                        const limbGeometry = new THREE.CylinderGeometry(0.03, 0.01, 0.5, 5);
                        const limb = new THREE.Mesh(limbGeometry, limbMaterial);
                        
                        const angle = (i / 6) * Math.PI * 2;
                        limb.position.set(
                            Math.cos(angle) * 0.2,
                            0,
                            Math.sin(angle) * 0.2
                        );
                        
                        limb.rotation.x = Math.PI / 2;
                        limb.rotation.z = angle;
                        
                        body.add(limb);
                        limbs.push(limb);
                    }
                    
                    // Yeux
                    const creatureEyeGeometry = new THREE.SphereGeometry(0.03, 8, 8);
                    const creatureEyeMaterial = new THREE.MeshBasicMaterial({
                        color: 0xff0000
                    });
                    
                    const creatureLeftEye = new THREE.Mesh(creatureEyeGeometry, creatureEyeMaterial);
                    creatureLeftEye.position.set(0.1, 0.2, 0.15);
                    body.add(creatureLeftEye);
                    
                    const creatureRightEye = new THREE.Mesh(creatureEyeGeometry, creatureEyeMaterial);
                    creatureRightEye.position.set(-0.1, 0.2, 0.15);
                    body.add(creatureRightEye);
                    
                    // Animation de la créature
                    group.userData.update = (time) => {
                        body.rotation.y = Math.sin(time) * 0.3;
                        
                        limbs.forEach((limb, i) => {
                            limb.rotation.x = Math.PI/2 + Math.sin(time * 3 + i) * 0.3;
                        });
                        
                        creatureLeftEye.scale.setScalar(0.8 + Math.sin(time * 5) * 0.2);
                        creatureRightEye.scale.setScalar(0.8 + Math.sin(time * 5 + 1) * 0.2);
                    };
                    break;
            }
            
            // Personnaliser l'entité selon sa variante
            customizeEntityByVariant(group, entityVariant);
            
            return group;
        }
        
        // Personnaliser l'entité en fonction de sa variante (pour la diversité)
        function customizeEntityByVariant(entity, variant) {
            // Appliquer des modifications selon le type de variante
            switch(variant) {
                case 1: // Variante plus grande
                    entity.scale.set(1.3, 1.3, 1.3);
                    break;
                case 2: // Variante colorée différemment
                    entity.traverse(child => {
                        if (child.isMesh && child.material) {
                            // Changer la teinte
                            if (child.material.color) {
                                const color = child.material.color;
                                color.setHSL((color.getHSL({}).h + 0.2) % 1, color.getHSL({}).s, color.getHSL({}).l);
                            }
                        }
                    });
                    break;
                case 3: // Variante déformée
                    entity.rotation.set(Math.PI/6, 0, Math.PI/8);
                    entity.scale.set(0.9, 1.2, 0.9);
                    break;
                case 4: // Variante avec lueur
                    const glow = new THREE.PointLight(0xaaccff, 0.5, 2);
                    entity.add(glow);
                    break;
                case 5: // Variante multiple (clones)
                    for (let i = 0; i < 2; i++) {
                        const clone = entity.clone();
                        clone.position.set(
                            (Math.random() - 0.5) * 0.5,
                            (Math.random() - 0.5) * 0.5,
                            (Math.random() - 0.5) * 0.5
                        );
                        clone.scale.set(0.7, 0.7, 0.7);
                        entity.add(clone);
                    }
                    break;
                case 6: // Variante plus angoissante/agressive
                    // Augmenter la vitesse d'animation
                    const originalUpdate = entity.userData.update;
                    if (originalUpdate) {
                        entity.userData.update = (time) => {
                            originalUpdate(time * 1.5); // Animation plus rapide
                        };
                    }
                    break;
                // Cas par défaut: aucune modification
            }
        }
        
        // Jouer un son mystérieux (simulation)
        function playMysterySound(type) {
            // Ici, on ne fait que simuler le son avec console.log
            // Dans une application réelle, vous utiliseriez l'API Web Audio
            const sounds = [
                "Chuchotements inquiétants",
                "Crissement humide",
                "Respiration profonde",
                "Bourdonnement électrique",
                "Gémissement spectral",
                "Vrombissement énergétique",
                "Grognement menaçant"
            ];
            
            console.log(`Son: ${sounds[Math.min(type, sounds.length - 1)]}`);
            
            // Déclencher un événement aléatoire basé sur la progression narrative
            if (Math.random() < window.storyProgress * 0.05) {
                setTimeout(() => {
                    console.log("Événement sonore spécial déclenché!");
                    // Effet supplémentaire possible ici
                }, 1000 + Math.random() * 2000);
            }
        }
        
        // Déclencher un effet spécial selon le type d'élément mystérieux
        function triggerMysteryEffect(type, element) {
            // Effets variés selon le type
            switch(type) {
                case 0: // Yeux - Flash rapide de lumière rouge
                    flashLightEffect(0xff0000);
                    break;
                case 1: // Tentacule - Secousse de caméra
                    cameraShakeEffect(0.5);
                    break;
                case 2: // Silhouette - Assombrissement temporaire
                    darkenEffect(1.5);
                    break;
                case 3: // Objet flottant - Pulse lumineux
                    pulseLightEffect(0x88ffff, 3);
                    break;
                case 4: // Visage - Effet de distorsion d'écran
                    distortScreenEffect(1);
                    break;
                case 5: // Portail - Mouvement soudain vers le portail
                    pullTowardsEffect(element, 0.5);
                    break;
                case 6: // Créature - Rugissement et secousse
                    cameraShakeEffect(0.8);
                    flashLightEffect(0xff3300);
                    break;
            }
        }
        
        // ==========================================
        // EFFETS VISUELS
        // ==========================================
        
        // Flash de lumière
        function flashLightEffect(color, intensity = 1.5) {
            // Ne pas créer un nouvel élément à chaque fois, réutiliser l'existant
            let flashOverlay = document.getElementById('flash-overlay');
            if (!flashOverlay) {
                flashOverlay = document.createElement('div');
                flashOverlay.id = 'flash-overlay';
                flashOverlay.style.position = 'fixed';
                flashOverlay.style.top = '0';
                flashOverlay.style.left = '0';
                flashOverlay.style.width = '100%';
                flashOverlay.style.height = '100%';
                flashOverlay.style.pointerEvents = 'none';
                flashOverlay.style.zIndex = '990';
                flashOverlay.style.transition = 'opacity 0.1s ease-in, opacity 0.3s ease-out';
                document.body.appendChild(flashOverlay);
            }
            
            flashOverlay.style.backgroundColor = new THREE.Color(color).getStyle();
            flashOverlay.style.opacity = '0';
            
            // Animation simplifiée pour éviter les empilements de setTimeout
            window.requestAnimationFrame(() => {
                flashOverlay.style.opacity = '0.3'; // Réduit pour moins de charge visuelle
                
                setTimeout(() => {
                    flashOverlay.style.opacity = '0';
                }, 100);
            });
        }
        
        // Secousse de caméra
        function cameraShakeEffect(intensity) {
            const originalPosition = {
                x: window.camera.position.x,
                y: window.camera.position.y,
                z: window.camera.position.z
            };
            
            let duration = 0;
            const maxDuration = 1; // durée en secondes
            
            function shake() {
                if (duration < maxDuration) {
                    duration += 0.05;
                    
                    // Appliquer un déplacement aléatoire à la caméra
                    window.camera.position.x = originalPosition.x + (Math.random() - 0.5) * intensity;
                    window.camera.position.y = originalPosition.y + (Math.random() - 0.5) * intensity;
                    
                    requestAnimationFrame(shake);
                } else {
                    // Remettre la caméra à sa position d'origine
                    window.camera.position.x = originalPosition.x;
                    window.camera.position.y = originalPosition.y;
                    window.camera.position.z = originalPosition.z;
                }
            }
            
            shake();
        }
        
        // Assombrissement de la scène
        function darkenEffect(duration) {
            // Stocker les intensités lumineuses originales
            const lights = [];
            window.scene.traverse(obj => {
                if (obj instanceof THREE.Light) {
                    lights.push({
                        light: obj,
                        originalIntensity: obj.intensity
                    });
                    obj.intensity *= 0.2; // Réduire fortement l'intensité
                }
            });
            
            // Restaurer après un délai
            setTimeout(() => {
                lights.forEach(item => {
                    item.light.intensity = item.originalIntensity;
                });
            }, duration * 1000);
        }
        
        // Effet de pulse lumineux
        function pulseLightEffect(color, pulseCount) {
            const pulseLight = new THREE.PointLight(color, 0, 10);
            pulseLight.position.copy(window.boat.position);
            window.scene.add(pulseLight);
            
            let currentPulse = 0;
            
            function pulse() {
                if (currentPulse < pulseCount) {
                    // Augmenter puis diminuer l'intensité
                    let time = 0;
                    const maxTime = 100;
                    
                    function pulseCycle() {
                        if (time < maxTime) {
                            time++;
                            // Courbe sinusoïdale pour l'intensité
                            const intensity = Math.sin((time / maxTime) * Math.PI) * 2;
                            pulseLight.intensity = intensity;
                            
                            requestAnimationFrame(pulseCycle);
                        } else {
                            currentPulse++;
                            if (currentPulse < pulseCount) {
                                setTimeout(pulse, 200);
                            } else {
                                window.scene.remove(pulseLight);
                            }
                        }
                    }
                    
                    pulseCycle();
                }
            }
            
            pulse();
        }
        
        // Effet de distorsion d'écran (simulé)
        function distortScreenEffect(duration) {
            // Créer un overlay pour simuler la distorsion
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'transparent';
            overlay.style.pointerEvents = 'none';
            overlay.style.zIndex = '1000';
            overlay.style.animation = `distort ${duration}s ease-in-out`;
            
            // Ajouter des styles pour l'animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes distort {
                    0% { backdrop-filter: blur(0px); }
                    25% { backdrop-filter: blur(3px) hue-rotate(45deg); }
                    50% { backdrop-filter: blur(5px) hue-rotate(90deg); }
                    75% { backdrop-filter: blur(3px) hue-rotate(45deg); }
                    100% { backdrop-filter: blur(0px); }
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(overlay);
            
            // Supprimer après la durée spécifiée
            setTimeout(() => {
                document.body.removeChild(overlay);
                document.head.removeChild(style);
            }, duration * 1000);
        }
        
        // Effet d'attraction vers un objet
        function pullTowardsEffect(element, duration) {
            if (!element) return;
            
            const startPosition = {
                x: window.boat.position.x,
                y: window.boat.position.y,
                z: window.boat.position.z
            };
            
            const targetPosition = new THREE.Vector3();
            element.getWorldPosition(targetPosition);
            
            // Calculer un point entre le bateau et la cible
            const pullTarget = new THREE.Vector3(
                startPosition.x + (targetPosition.x - startPosition.x) * 0.4,
                startPosition.y,
                startPosition.z + (targetPosition.z - startPosition.z) * 0.4
            );
            
            let time = 0;
            const pullDuration = duration * 40; // Nombre d'étapes pour l'animation
            
            function pull() {
                if (time < pullDuration) {
                    time++;
                    
                    // Courbe d'accélération puis décélération
                    let progress = time / pullDuration;
                    if (progress < 0.5) {
                        // Accélération
                        progress = 2 * progress * progress;
                    } else {
                        // Décélération
                        progress = -1 + (4 - 2 * progress) * progress;
                    }
                    
                    // Déplacer le bateau vers la cible puis retour
                    if (time < pullDuration / 2) {
                        window.boat.position.x = startPosition.x + (pullTarget.x - startPosition.x) * progress;
                        window.boat.position.z = startPosition.z + (pullTarget.z - startPosition.z) * progress;
                    } else {
                        const returnProgress = (time - pullDuration / 2) / (pullDuration / 2);
                        window.boat.position.x = pullTarget.x + (startPosition.x - pullTarget.x) * returnProgress;
                        window.boat.position.z = pullTarget.z + (startPosition.z - pullTarget.z) * returnProgress;
                    }
                    
                    requestAnimationFrame(pull);
                } else {
                    // Assurer que le bateau revient exactement à sa position initiale
                    window.boat.position.x = startPosition.x;
                    window.boat.position.z = startPosition.z;
                }
            }
            
            pull();
        }
        
        // ==========================================
        // SYSTÈME DE NARRATION ET DE DONS
        // ==========================================
        
        // Gérer un élément narratif (indice, événement, etc.)
        function handleNarrativeElement(element) {
            switch(element.type) {
                case "clue":
                    revealClue(element.data);
                    break;
                case "mystery":
                    handleMystery(element.data);
                    break;
                case "fragment":
                    showNarrativeFragment(element.data);
                    break;
            }
        }
        
        // Révéler un indice
        function revealClue(clue) {
            // Vérifier si l'indice est déjà découvert
            if (window.discoveredClues.includes(clue.id)) return;
            
            // Ajouter l'indice à la liste des découverts
            window.discoveredClues.push(clue.id);
            
            // Afficher une notification
            showClueNotification(`Indice trouvé: ${clue.text}`);
            
            // Afficher un message narratif
            showNarrativeMessage(`${clue.text}`, 8000);
            
            // Vérifier si cet indice complète un mystère
            checkMysteryCompletion();
            
            // Effet visuel spécial
            specialEffectForClueType(clue.category);
        }
        
        // Effet spécial selon la catégorie d'indice
        function specialEffectForClueType(category) {
            switch(category) {
                case "sequence":
                    flashLightEffect(0xffffff);
                    break;
                case "phrase":
                    showNarrativeMessage("Les mots semblent résonner dans le tunnel...", 4000);
                    break;
                case "symbol":
                    distortScreenEffect(0.5);
                    break;
                case "date":
                    countdownEffect();
                    break;
                case "location":
                    cameraShakeEffect(0.3);
                    break;
                case "word":
                    // Effet d'inversion de l'écran
                    const overlay = document.createElement('div');
                    overlay.style.position = 'fixed';
                    overlay.style.top = '0';
                    overlay.style.left = '0';
                    overlay.style.width = '100%';
                    overlay.style.height = '100%';
                    overlay.style.backgroundColor = 'transparent';
                    overlay.style.transform = 'scaleX(-1)';
                    overlay.style.zIndex = '1000';
                    document.body.appendChild(overlay);
                    
                    setTimeout(() => {
                        document.body.removeChild(overlay);
                    }, 3000);
                    break;
                case "pattern":
                    pulseLightEffect(0xaaffaa, 5);
                    break;
                case "name":
                    showNarrativeMessage("Ce nom semble important...", 4000);
                    flashLightEffect(0xffaaff);
                    break;
                case "math":
                    countdownEffect();
                    break;
                case "audio":
                    console.log("Son: Voix distordue mystérieuse");
                    break;
                case "cipher":
                    showNarrativeMessage("Ces lettres forment un code...", 4000);
                    break;
            }
        }
        
        // Afficher une notification d'indice trouvé
        function showClueNotification(text) {
            const notification = document.getElementById('clue-notification');
            notification.textContent = text;
            notification.classList.add('visible');
            
            setTimeout(() => {
                notification.classList.remove('visible');
            }, 5000);
        }
        
        // Vérifier si un mystère est complété
        function checkMysteryCompletion() {
            STORY_ELEMENTS.mysteries.forEach(mystery => {
                if (!mystery.solved) {
                    // Vérifier si tous les indices requis sont découverts
                    const allCluesFound = mystery.requiredClues.every(
                        clueId => window.discoveredClues.includes(clueId)
                    );
                    
                    if (allCluesFound) {
                        // Marquer le mystère comme résolu
                        mystery.solved = true;
                        window.solvedMysteries++;
                        
                        // Mettre à jour l'affichage
                        document.getElementById('solved-mysteries').textContent = 
                            `${window.solvedMysteries}/${STORY_ELEMENTS.mysteries.length}`;
                        
                        // Afficher un message
                        showNarrativeMessage(`Mystère résolu: ${mystery.title} - ${mystery.reward}`, 10000);
                        
                        // Déclencher un événement spécial
                        triggerSpecialEvent();
                    }
                }
            });
        }
        
        // Afficher un message narratif plus élégant avec optimisation
        function showNarrativeMessage(text, duration = 5000) {
            // Limiter les appels intensifs pendant les animations
            // Si nous sommes déjà en train d'afficher un message, mettons celui-ci en file d'attente
            if (window.narrativeMessageActive) {
                // Stocker le message pour l'afficher plus tard
                if (!window.messageQueue) window.messageQueue = [];
                window.messageQueue.push({text, duration});
                return;
            }
            
            window.narrativeMessageActive = true;
            const display = document.getElementById('narrative-display');
            
            // Limiter la longueur du texte pour éviter les problèmes de performance
            if (text.length > 300) {
                text = text.substring(0, 297) + '...';
            }
            
            // Déterminer le type de message pour un style visuel différent
            let messageType = 'milestone'; // Type par défaut
            let icon = '📜'; // Icône par défaut
            
            if (text.includes('Indice') || text.includes('découvert') || text.includes('révèle')) {
                messageType = 'discovery';
                icon = '🔍';
            } else if (text.includes('Mystère') || text.includes('événement') || text.includes('apparition') || text.includes('distorsion')) {
                messageType = 'event';
                icon = '⚡';
            }
            
            // Version simplifiée du HTML pour réduire la charge de mise en page
            display.innerHTML = `<div>${icon} ${text}</div>`;
            display.setAttribute('data-type', messageType);
            
            // Ajouter immédiatement au journal d'exploration (sans doublon)
            addToStoryHistory(messageType, text);
            
            // Affichage avec optimisation
            display.style.opacity = '0'; // Optimisation: éviter la transition en définissant directement le style
            setTimeout(() => {
                display.classList.add('visible');
                
                setTimeout(() => {
                    display.classList.remove('visible');
                    
                    // Libérer le verrou après un court délai pour s'assurer que la transition est terminée
                    setTimeout(() => {
                        window.narrativeMessageActive = false;
                        
                        // Vérifier s'il y a des messages en attente
                        if (window.messageQueue && window.messageQueue.length > 0) {
                            const nextMessage = window.messageQueue.shift();
                            showNarrativeMessage(nextMessage.text, nextMessage.duration);
                        }
                    }, 500);
                }, duration);
            }, 50);
        }
        
        // Afficher un fragment narratif
        function showNarrativeFragment(fragment) {
            showNarrativeMessage(fragment, 8000);
        }
        
        // Simuler un don
        function simulateDonation(username, amount) {
            // Ajouter au total des dons
            window.totalDonations += amount;
            
            // Mettre à jour l'affichage
            updateDonationDisplay();

            // Ajouter le donateur au mur
            addDonorToWall(username, amount);
            
            // Vérifier si un palier est atteint
                checkMilestoneUnlock(username);

            // Événement aléatoire basé sur le montant
            if (amount >= 100) {
                triggerSpecialEvent();
            } else if (amount >= 50) {
                revealRandomClue();
            } else if (amount >= 20) {
                // Petit effet visuel
                const effectChoice = Math.floor(Math.random() * 3);
                switch(effectChoice) {
                    case 0:
                        flashLightEffect(0xffff00);
                        break;
                    case 1:
                        pulseLightEffect(0xaaddff, 2);
                        break;
                    case 2:
                        cameraShakeEffect(0.3);
                        break;
                }
            }
            
            // Faire briller la lanterne du bateau pour montrer l'activité
            if (window.boat && window.boat.userData.lanternLight) {
                const originalIntensity = window.boat.userData.lanternOriginalIntensity;
                window.boat.userData.lanternLight.intensity = originalIntensity * 2;
                
                setTimeout(() => {
                    window.boat.userData.lanternLight.intensity = originalIntensity;
                }, 1000);
            }
            
            // Mettre à jour le classement (si nécessaire)
            updateLeaderboard(username, amount);
            
            // Mettre à jour les fenêtres de détails si elles sont ouvertes
            if (window.detailWindows && window.detailWindows.length > 0) {
                window.sendDataToExplorationDetails();
            }
        }
        
        // Mise à jour de l'affichage des dons sans mettre à jour le story-milestone (qui est maintenant caché)
        function updateDonationDisplay() {
            document.getElementById('total-donations').textContent = window.totalDonations + ' unités';
            
            // Calculer le pourcentage de progression jusqu'au prochain palier
            const currentMilestone = STORY_MILESTONES[window.currentMilestoneIndex];
            const nextMilestone = STORY_MILESTONES[window.currentMilestoneIndex + 1];
            
            if (nextMilestone) {
                const progress = Math.min(100, (window.totalDonations / nextMilestone.amount) * 100);
                document.getElementById('story-progress').style.width = progress + '%';
                document.getElementById('progress-percent').textContent = Math.floor(progress) + '%';
                document.getElementById('next-milestone-amount').textContent = nextMilestone.amount + ' unités';
                
                // Au lieu d'afficher dans l'élément visible, ajoutons-le uniquement au journal
                if (nextMilestone.description && nextMilestone.description !== document.getElementById('story-milestone').textContent) {
                    // Ajouter le jalon au journal seulement lors du changement
                    addToStoryHistory('milestone', `Prochain objectif: ${nextMilestone.description}`);
                }
                
                // Stocker la description, mais ne pas l'afficher
                document.getElementById('story-milestone').textContent = nextMilestone.description;
                
                // Mettre à jour la variable de progression globale
                window.storyProgress = progress / 100;
            }
        }
        
        // Mettre à jour l'affichage des paliers narratifs
        function updateMilestoneDisplay() {
            // Mettre à jour le nombre de mystères résolus
            const solvedCount = STORY_ELEMENTS.mysteries.filter(mystery => mystery.solved).length;
            document.getElementById('solved-mysteries').textContent = `${solvedCount}/${STORY_ELEMENTS.mysteries.length}`;
            
            // Mettre à jour l'affichage des dons et progression
            updateDonationDisplay();
            
            // Afficher le palier actuel
            const currentMilestone = STORY_MILESTONES[window.currentMilestoneIndex];
            if (currentMilestone) {
                document.getElementById('story-milestone').textContent = currentMilestone.description;
            }
        }
        
        // Ajouter un donateur au mur des contributeurs
        function addDonorToWall(username, amount) {
            const donorList = document.getElementById('donor-list');
            
            // Déterminer le niveau du donateur
            let donorTier = DONOR_TIERS.find(tier => 
                amount >= tier.min && amount <= tier.max
            );
            
            if (!donorTier) {
                donorTier = DONOR_TIERS[0]; // Par défaut
            }
            
            // Créer l'élément
            const donorElement = document.createElement('div');
            donorElement.className = `donor ${donorTier.class}`;
            donorElement.textContent = `${username} (${donorTier.name}): ${amount} unités`;
            
            // Ajouter au début de la liste
            if (donorList.firstChild) {
                donorList.insertBefore(donorElement, donorList.firstChild);
                } else {
                donorList.appendChild(donorElement);
            }
            
            // Limiter à 10 contributeurs affichés
            if (donorList.children.length > 10) {
                donorList.removeChild(donorList.lastChild);
            }
            
            // Animation
            donorElement.style.animation = 'pulse 2s';
        }
        
        // Vérifier si un palier est atteint
        function checkMilestoneUnlock(username) {
            // Vérifier si nous avons atteint le prochain palier
            const nextMilestone = STORY_MILESTONES[window.currentMilestoneIndex + 1];
            
            if (nextMilestone && window.totalDonations >= nextMilestone.amount) {
                unlockNextMilestone(username);
            }
        }
        
        // Débloquer le prochain palier narratif
        function unlockNextMilestone(username) {
            window.currentMilestoneIndex++;
            const milestone = STORY_MILESTONES[window.currentMilestoneIndex];
            
            if (milestone) {
                // Afficher un message
                showNarrativeMessage(`[${milestone.title}] ${milestone.description}`, 10000);
                
                // Déclencher la fonction associée
                if (milestone.unlocksFunction) {
                    milestone.unlocksFunction(username);
                }
                
                // Mettre à jour l'affichage
                updateDonationDisplay();
                
                // Compte à rebours pour l'événement
                countdownEffect(3, () => {
                    triggerSpecialEvent();
                });
            }
        }
        
        // Fonction de compte à rebours
        function countdownEffect(count = 3, callback) {
            const counterElement = document.getElementById('event-counter') || (() => {
                const el = document.createElement('div');
                el.id = 'event-counter';
                document.body.appendChild(el);
                return el;
            })();
            
            let currentCount = count;
            counterElement.textContent = currentCount;
            counterElement.classList.add('visible');
            
            // Utiliser requestAnimationFrame pour la gestion du temps
            const startTime = performance.now();
            const interval = 1000; // 1 seconde entre chaque compte
            
            function updateCounter(timestamp) {
                const elapsed = timestamp - startTime;
                const newCount = count - Math.floor(elapsed / interval);
                
                if (newCount !== currentCount && newCount >= 0) {
                    currentCount = newCount;
                    counterElement.textContent = currentCount;
                    
                    // Ajouter un effet visuel léger
                    counterElement.style.transform = 'translate(-50%, -50%) scale(1.2)';
                    setTimeout(() => {
                        counterElement.style.transform = 'translate(-50%, -50%) scale(1)';
                    }, 100);
                }
                
                if (newCount >= 0) {
                    requestAnimationFrame(updateCounter);
                } else {
                    counterElement.classList.remove('visible');
                    if (callback) callback();
                }
            }
            
            requestAnimationFrame(updateCounter);
        }
        
        // Révéler un indice aléatoire
        function revealRandomClue() {
            // Trouver les indices non découverts
            const availableClues = STORY_ELEMENTS.clues.filter(
                clue => !window.discoveredClues.includes(clue.id)
            );
            
            if (availableClues.length > 0) {
                const randomClue = availableClues[Math.floor(Math.random() * availableClues.length)];
                revealClue(randomClue);
            }
        }
        
        // Déclencher un événement spécial
        function triggerSpecialEvent() {
            // Choisir un événement en fonction de la progression
            const eventType = Math.floor(Math.random() * 5);
            
            switch(eventType) {
                case 0: // Apparition d'entité
                    spawnSpecialEntity();
                    break;
                case 1: // Blackout
                    darkenEffect(3);
                    setTimeout(() => {
                        showNarrativeMessage("Quelque chose se déplace dans l'obscurité...", 5000);
                    }, 1000);
                    break;
                case 2: // Distorsion de réalité
                    distortScreenEffect(2);
                    setTimeout(() => {
                        showNarrativeFragment(
                            STORY_ELEMENTS.narrativeFragments[
                                Math.floor(Math.random() * STORY_ELEMENTS.narrativeFragments.length)
                            ]
                        );
                    }, 1000);
                    break;
                case 3: // Porte qui s'ouvre spontanément
                    // Trouver une porte visible
                    const visibleDoors = window.doors.filter(door => {
                        const doorPos = new THREE.Vector3();
                        door.getWorldPosition(doorPos);
                        const distance = doorPos.distanceTo(window.boat.position);
                        return distance < 15;
                    });
                    
                    if (visibleDoors.length > 0) {
                        const randomDoor = visibleDoors[Math.floor(Math.random() * visibleDoors.length)];
                        animateDoor(randomDoor);
                    }
                    break;
                case 4: // Vote communautaire
                    startVote();
                    break;
            }
        }
        
        // Faire apparaître une entité spéciale
        function spawnSpecialEntity() {
            // Position devant le bateau
            const position = new THREE.Vector3(
                window.boat.position.x + (Math.random() - 0.5) * 2,
                WATER_LEVEL + 0.5 + Math.random() * 1.5,
                window.boat.position.z + 10 + Math.random() * 5
            );
            
            // Type d'entité avancé basé sur la progression narrative
            let entityType;
            
            if (window.storyProgress < 0.2) {
                entityType = Math.floor(Math.random() * 3); // Entités basiques au début
            } else if (window.storyProgress < 0.5) {
                entityType = Math.floor(Math.random() * 5); // Plus de variété
            } else {
                // Utiliser seulement les types 0-5 pour éviter le type 6 (qui peut utiliser CapsuleGeometry)
                entityType = Math.floor(Math.random() * 6); 
                
                // Chance pour une entité boss avec progression élevée
                if (window.storyProgress > 0.8 && Math.random() < 0.3) {
                    return spawnBossEntity();
                }
            }
            
            // Variante basée sur l'avancement de l'histoire
            const entityVariant = Math.min(6, Math.floor(window.storyProgress * 10));
            
            try {
                const entity = createMysteryElement(entityType, entityVariant);
                entity.position.copy(position);
                
                // Orientation vers le bateau
                entity.lookAt(window.boat.position);
                
                window.scene.add(entity);
                
                // Stocker dans la liste des éléments mystérieux
                window.mysteryElements[entity.uuid] = entity;
                
                // Afficher un message selon le type
                const messages = [
                    "Des yeux brillent dans l'obscurité...",
                    "Quelque chose s'agite sous la surface...",
                    "Une silhouette se tient immobile, observant...",
                    "Un objet étrange flotte dans l'air...",
                    "Est-ce un visage qui vous regarde?",
                    "Une brèche énergétique s'ouvre devant vous...",
                    "Une créature émerge des profondeurs..."
                ];
                
                showNarrativeMessage(messages[entityType], 5000);
                
                // Faire disparaître après un certain temps
                setTimeout(() => {
                    // Animation de disparition
                    let opacity = 1;
                    const fadeInterval = setInterval(() => {
                        opacity -= 0.05;
                        
                        entity.traverse(child => {
                            if (child.material && child.material.opacity !== undefined) {
                                child.material.transparent = true;
                                child.material.opacity = opacity;
                            }
                        });
                        
                        if (opacity <= 0) {
                            clearInterval(fadeInterval);
                            window.scene.remove(entity);
                            delete window.mysteryElements[entity.uuid];
                        }
                    }, 100);
                }, 10000 + Math.random() * 5000);
                
                return entity;
            } catch (error) {
                console.error("Erreur lors de la création d'une entité:", error);
                // En cas d'erreur, essayons avec un type d'entité plus simple (type 0)
                return spawnSpecialEntity();
            }
        }
        
        // Faire apparaître une entité boss
        function spawnBossEntity() {
            // Annoncer l'événement
            countdownEffect(5, () => {
                // Assombrir la scène
                darkenEffect(10);
                
                // Créer l'entité boss
                const boss = new THREE.Group();
                
                // Position devant le bateau, plus loin que les entités normales
                boss.position.set(
                    window.boat.position.x,
                    WATER_LEVEL + 2,
                    window.boat.position.z + 20
                );
                
                // Corps principal de l'entité
                const bodyGeometry = new THREE.SphereGeometry(2, 16, 16);
                const bodyMaterial = new THREE.MeshPhongMaterial({
                    color: 0x220022,
                    emissive: 0x330033,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.8
                });
                
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                boss.add(body);
                
                // Aura lumineuse
                const auraLight = new THREE.PointLight(0xbb00ff, 3, 15);
                body.add(auraLight);
                
                // Tentacules
                const tentacles = [];
                for (let i = 0; i < 8; i++) {
                    const tentacle = new THREE.Group();
                    
                    const angle = (i / 8) * Math.PI * 2;
                    tentacle.position.set(
                        Math.cos(angle) * 1.5,
                        Math.sin(angle) * 1.5,
                        0
                    );
                    
                    // Segments de tentacule
                    const segments = [];
                    let prevSegment = null;
                    
                    for (let j = 0; j < 6; j++) {
                        const segGeometry = new THREE.CylinderGeometry(
                            0.2 - j * 0.03, 
                            0.17 - j * 0.03, 
                            0.5, 
                            8
                        );
                        
                        const segMaterial = new THREE.MeshPhongMaterial({
                            color: 0x440044,
                            emissive: 0x220022,
                            emissiveIntensity: 0.3
                        });
                        
                        const segment = new THREE.Mesh(segGeometry, segMaterial);
                        segment.rotation.x = Math.PI / 2;
                        
                        if (prevSegment) {
                            segment.position.z = 0.5;
                            prevSegment.add(segment);
                        } else {
                            tentacle.add(segment);
                        }
                        
                        prevSegment = segment;
                        segments.push(segment);
                    }
                    
                    boss.add(tentacle);
                    tentacles.push({
                        main: tentacle,
                        segments: segments,
                        angle: angle,
                        speed: 0.5 + Math.random() * 1
                    });
                }
                
                // Yeux
                for (let i = 0; i < 3; i++) {
                    const angle = (i / 3) * Math.PI * 2;
                    const radius = 1.2;
                    
                    const eyeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                    const eyeMaterial = new THREE.MeshBasicMaterial({
                        color: 0xff0000
                        // emissive et emissiveIntensity ne sont pas supportés par MeshBasicMaterial
                    });
                    
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius,
                        1.8 // Placé à l'avant
                    );
                    
                    body.add(eye);
                    
                    // Lumière pour chaque œil
                    const eyeLight = new THREE.PointLight(0xff0000, 1, 3);
                    eyeLight.position.set(0, 0, 0.2);
                    eye.add(eyeLight);
                }
                
                // Animation
                boss.userData.update = (time) => {
                    // Pulsation du corps
                    const pulse = 1 + Math.sin(time * 2) * 0.1;
                    body.scale.set(pulse, pulse, pulse);
                    
                    // Animation des tentacules
                    tentacles.forEach((tentacle, i) => {
                        const mainAngle = tentacle.angle + time * 0.2;
                        tentacle.main.position.set(
                            Math.cos(mainAngle) * 1.5,
                            Math.sin(mainAngle) * 1.5,
                            0
                        );
                        
                        // Mouvement ondulant des segments
                        tentacle.segments.forEach((segment, j) => {
                            const segAngle = time * tentacle.speed + j * 0.5;
                            segment.rotation.y = Math.sin(segAngle) * 0.5;
                            segment.rotation.z = Math.cos(segAngle) * 0.5;
                        });
                    });
                    
                    // L'entité boss suit lentement le bateau
                    const targetX = window.boat.position.x;
                    const targetZ = window.boat.position.z + 15;
                    
                    boss.position.x += (targetX - boss.position.x) * 0.01;
                    boss.position.z += (targetZ - boss.position.z) * 0.01;
                    
                    // Variation d'intensité lumineuse
                    auraLight.intensity = 2 + Math.sin(time * 5) * 1;
                };
                
                // Ajouter à la scène
                window.scene.add(boss);
                window.mysteryElements[boss.uuid] = boss;
                
                // Message dramatique
                showNarrativeMessage("Une présence ancienne a senti votre intrusion...", 8000);
                
                // Faire disparaître après un temps plus long
                setTimeout(() => {
                    // Animation de disparition spirale
                    let opacity = 1;
                    let scale = 1;
                    const fadeInterval = setInterval(() => {
                        opacity -= 0.02;
                        scale += 0.1;
                        
                        boss.scale.set(scale, scale, scale);
                        
                        boss.traverse(child => {
                            if (child.material && child.material.opacity !== undefined) {
                                child.material.transparent = true;
                                child.material.opacity = opacity;
                            }
                        });
                        
                        boss.rotation.z += 0.1;
                        
                        if (opacity <= 0) {
                            clearInterval(fadeInterval);
                            window.scene.remove(boss);
                            delete window.mysteryElements[boss.uuid];
                        }
                    }, 100);
                }, 30000);
                
                return boss;
            });
            
            showNarrativeMessage("Quelque chose d'imposant approche...", 5000);
        }
        
        // Démarrer un vote communautaire
        function startVote() {
            // Vérifier s'il y a déjà un vote en cours
            if (window.activeVote) return;
            
            // Types de votes possibles
            const voteTypes = [
                {
                    question: "Quelle porte le voyageur devrait-il ouvrir ensuite?",
                    options: [
                        "Porte avec symbole spirale",
                        "Porte rouge clignotante",
                        "Porte avec marques de griffes"
                    ]
                },
                {
                    question: "Quelle direction explorer?",
                    options: [
                        "Vers les profondeurs",
                        "Vers le couloir étroit",
                        "Vers la lumière distante"
                    ]
                },
                {
                    question: "Comment interagir avec l'entité?",
                    options: [
                        "L'observer à distance",
                        "Tenter de communiquer",
                        "Fuir immédiatement"
                    ]
                }
            ];
            
            // Choisir un type de vote aléatoire
            const voteType = voteTypes[Math.floor(Math.random() * voteTypes.length)];
            
            // Initialiser le vote
            window.activeVote = {
                question: voteType.question,
                options: voteType.options.map(option => ({ text: option, votes: 0 })),
                timeRemaining: 180, // 3 minutes
                totalVotes: 0
            };
            
            // Mettre à jour l'interface du vote
            const votePanel = document.getElementById('vote-panel');
            const voteQuestion = document.getElementById('vote-question');
            const voteTimer = document.getElementById('vote-timer');
            
            voteQuestion.textContent = voteType.question;
            
            // Mettre à jour les options de vote
            const voteOptions = votePanel.querySelectorAll('.vote-option');
            voteOptions.forEach((option, index) => {
                const optionText = option.querySelector('span:first-child');
                const optionPercent = option.querySelector('span:last-child');
                const optionFill = option.querySelector('.vote-fill');
                
                if (index < voteType.options.length) {
                    optionText.textContent = voteType.options[index];
                    optionPercent.textContent = "0%";
                    optionFill.style.width = "0%";
                    option.setAttribute('data-option', index);
                    option.style.display = 'block';
                } else {
                    option.style.display = 'none';
                }
            });
            
            // Afficher le panneau
            votePanel.style.display = 'block';
            
            // Annoncer le vote
            showNarrativeMessage(`Vote communautaire: ${voteType.question}`, 8000);
            
            // Démarrer le compte à rebours
            const timerInterval = setInterval(() => {
                window.activeVote.timeRemaining--;
                
                const minutes = Math.floor(window.activeVote.timeRemaining / 60);
                const seconds = window.activeVote.timeRemaining % 60;
                voteTimer.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                if (window.activeVote.timeRemaining <= 0) {
                    clearInterval(timerInterval);
                    endVote();
                }
            }, 1000);
            
            // Ajouter quelques votes initiaux
            for (let i = 0; i < 30; i++) {
                setTimeout(() => {
                    const randomOption = Math.floor(Math.random() * voteType.options.length);
                    voteForOption(randomOption);
                }, Math.random() * 10000);
            }
        }
        
        // Voter pour une option
        function voteForOption(optionIndex) {
            if (!window.activeVote) return;
            
            // Ajouter le vote
            window.activeVote.options[optionIndex].votes++;
            window.activeVote.totalVotes++;
            
            // Mettre à jour l'affichage
            updateVoteDisplay();
        }
        
        // Mettre à jour l'affichage du vote
        function updateVoteDisplay() {
            if (!window.activeVote) return;
            
            const votePanel = document.getElementById('vote-panel');
            const voteOptions = votePanel.querySelectorAll('.vote-option');
            
            voteOptions.forEach((option, index) => {
                if (index >= window.activeVote.options.length) return;
                
                const optionData = window.activeVote.options[index];
                const percent = window.activeVote.totalVotes === 0 ? 
                    0 : Math.round((optionData.votes / window.activeVote.totalVotes) * 100);
                
                const optionPercent = option.querySelector('span:last-child');
                const optionFill = option.querySelector('.vote-fill');
                
                optionPercent.textContent = `${percent}%`;
                optionFill.style.width = `${percent}%`;
            });
        }
        
        // Terminer un vote
        function endVote() {
            if (!window.activeVote) return;
            
            // Trouver l'option gagnante
            let winningIndex = 0;
            let maxVotes = 0;
            
            window.activeVote.options.forEach((option, index) => {
                if (option.votes > maxVotes) {
                    maxVotes = option.votes;
                    winningIndex = index;
                }
            });
            
            const winningOption = window.activeVote.options[winningIndex];
            
            // Annoncer le résultat
            showNarrativeMessage(`Le vote est terminé! Résultat: "${winningOption.text}" (${Math.round((winningOption.votes / window.activeVote.totalVotes) * 100)}%)`, 8000);
            
            // Exécuter l'action correspondante
            executeVoteResult(window.activeVote.question, winningOption.text);
            
            // Masquer le panneau de vote
            document.getElementById('vote-panel').style.display = 'none';
            
            // Réinitialiser le vote actif
            window.activeVote = null;
        }
        
        // Exécuter le résultat d'un vote
        function executeVoteResult(question, result) {
            // Actions en fonction du type de question
            if (question.includes("porte")) {
                // Recherche des portes correspondantes
                let matchingDoors = [];
                
                if (result.includes("spirale")) {
                    matchingDoors = window.doors.filter(door => 
                        door.userData.doorSymbol === "symbol" &&
                        door.userData.symbolType === 1
                    );
                } else if (result.includes("rouge")) {
                    matchingDoors = window.doors.filter(door => 
                        door.userData.doorSymbol === "blood"
                    );
                } else if (result.includes("griffes")) {
                    matchingDoors = window.doors.filter(door => 
                        door.userData.doorSymbol === "claw"
                    );
                }
                
                // Si on trouve une porte correspondante, l'ouvrir
                if (matchingDoors.length > 0) {
                    const doorToOpen = matchingDoors[Math.floor(Math.random() * matchingDoors.length)];
                    
                    // Déplacer le bateau vers la porte
                    moveBoatTowards(doorToOpen, () => {
                        animateDoor(doorToOpen);
                    });
                } else {
                    // Aucune porte trouvée, en créer une
                    showNarrativeMessage("Une nouvelle porte apparaît...", 5000);
                    
                    setTimeout(() => {
                        spawnSpecialDoor(result);
                    }, 2000);
                }
            } else if (question.includes("direction")) {
                // Changer la direction d'exploration
                if (result.includes("profondeurs")) {
                    // Accélérer vers l'avant
                    window.boatSpeed = 0.2;
                    setTimeout(() => {
                        window.boatSpeed = 0.05;
                    }, 10000);
                    
                    // Effet visuel d'accélération
                    distortScreenEffect(0.5);
                    
                } else if (result.includes("couloir")) {
                    // Se diriger vers un passage plus étroit
                    createNarrowPassage();
                    
                } else if (result.includes("lumière")) {
                    // Créer une zone lumineuse distante
                    createDistantLight();
                }
            } else if (question.includes("entité")) {
                // Interaction avec une entité
                const entity = spawnSpecialEntity();
                
                if (result.includes("observer")) {
                    // L'entité reste à distance et fait des mouvements lents
                    entity.userData.behavior = "observe";
                    showNarrativeMessage("L'entité semble curieuse, vous observant à distance...", 5000);
                    
                } else if (result.includes("communiquer")) {
                    // L'entité s'approche et "parle"
                    entity.userData.behavior = "communicate";
                    
                    moveEntityTowards(entity, window.boat.position, 5, () => {
                        showNarrativeFragment(
                            STORY_ELEMENTS.narrativeFragments[
                                Math.floor(Math.random() * STORY_ELEMENTS.narrativeFragments.length)
                            ]
                        );
                        
                        // Effet de communication
                        pulseLightEffect(0xaaffff, 5);
                    });
                    
                } else if (result.includes("fuir")) {
                    // L'entité devient menaçante et poursuit
                    entity.userData.behavior = "chase";
                    
                    showNarrativeMessage("Vous tentez de fuir, mais l'entité vous poursuit rapidement!", 5000);
                    
                    // Animation de poursuite
                    const chaseInterval = setInterval(() => {
                        moveEntityTowards(entity, window.boat.position, 2, null);
                        
                        // Si l'entité est trop proche, effet de secousse
                        const distance = entity.position.distanceTo(window.boat.position);
                        if (distance < 3) {
                            cameraShakeEffect(0.5);
                            flashLightEffect(0xff0000);
                        }
                    }, 500);
                    
                    // Arrêter la poursuite après un moment
                    setTimeout(() => {
                        clearInterval(chaseInterval);
                    }, 15000);
                }
            }
        }
        
        // Déplacer le bateau vers une cible
        function moveBoatTowards(target, callback = null) {
            const targetPosition = new THREE.Vector3();
            target.getWorldPosition(targetPosition);
            
            // Calculer un point d'arrêt à une distance raisonnable
            const direction = new THREE.Vector3().subVectors(targetPosition, window.boat.position).normalize();
            const stopPosition = new THREE.Vector3().copy(targetPosition).sub(direction.multiplyScalar(3));
            
            const originalSpeed = window.boatSpeed;
            let moving = true;
            
            // Animation de déplacement
            function moveStep() {
                if (!moving) return;
                
                // Calculer la direction vers la cible
                const currentDirection = new THREE.Vector3().subVectors(stopPosition, window.boat.position).normalize();
                
                // Mettre à jour la position du bateau
                window.boat.position.x += currentDirection.x * 0.1;
                window.boat.position.z += currentDirection.z * 0.1;
                
                // Orienter le bateau vers la cible
                window.boat.rotation.y = Math.atan2(currentDirection.x, currentDirection.z);
                
                // Vérifier si on est arrivé
                const distance = window.boat.position.distanceTo(stopPosition);
                if (distance < 0.5) {
                    moving = false;
                    window.boatSpeed = originalSpeed;
                    
                    if (callback) setTimeout(callback, 500);
                } else {
                    requestAnimationFrame(moveStep);
                }
            }
            
            // Démarrer l'animation
            moveStep();
        }
        
        // Déplacer une entité vers une position
        function moveEntityTowards(entity, targetPosition, speed = 3, callback = null) {
            // Calculer la direction
            const direction = new THREE.Vector3().subVectors(targetPosition, entity.position).normalize();
            
            // Déplacer l'entité
            entity.position.x += direction.x * (0.05 * speed);
            entity.position.z += direction.z * (0.05 * speed);
            
            // Orienter l'entité vers la cible
            entity.lookAt(targetPosition);
            
            // Vérifier si on est arrivé
            const distance = entity.position.distanceTo(targetPosition);
            if (distance < 1 && callback) {
                callback();
            }
        }
        
        // Créer un passage étroit
        function createNarrowPassage() {
            // Message narratif
            showNarrativeMessage("Le tunnel se rétrécit devant vous...", 5000);
            
            // Créer un segment spécial qui se rétrécit
            const segment = new THREE.Group();
            segment.position.z = window.boat.position.z + 30; // Plus loin devant
            
            // Tunnel conique qui se rétrécit
            const tunnelGeometry = new THREE.CylinderGeometry(
                TUNNEL_RADIUS, TUNNEL_RADIUS * 0.6, TUNNEL_LENGTH, 16, 8, true
            );
            const tunnelMaterial = new THREE.MeshPhongMaterial({
                color: 0x222222, 
                side: THREE.BackSide
            });
            const tunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
            tunnel.rotation.x = Math.PI / 2;
            segment.add(tunnel);
            
            // Sol/eau au centre
            const waterGeometry = new THREE.PlaneGeometry(
                TUNNEL_RADIUS * 1.2, TUNNEL_LENGTH
            );
            const waterMaterial = new THREE.MeshPhongMaterial({
                color: 0x004466,
                transparent: true,
                opacity: 0.7
            });
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = WATER_LEVEL;
            segment.add(water);
            
            // Lumières plus sombres
            for (let z = 0; z < TUNNEL_LENGTH; z += 3) {
                const zPos = z - TUNNEL_LENGTH / 2;
                
                const light = new THREE.PointLight(0x443333, 0.3, 3);
                light.position.set(0, 0, zPos);
                segment.add(light);
            }
            
            window.scene.add(segment);
            
            // Ajouter des effets de passage
            setTimeout(() => {
                // Son d'écoulement d'eau
                console.log("Son: Écoulement d'eau accéléré");
                
                // Déplacement automatique
                window.boatSpeed = 0.1;
                setTimeout(() => {
                    window.boatSpeed = 0.05;
                    
                    // Révéler un indice après le passage
                    revealRandomClue();
                }, 8000);
            }, 2000);
        }
        
        // Créer une lumière distante
        function createDistantLight() {
            // Message narratif
            showNarrativeMessage("Une lueur apparaît au loin...", 5000);
            
            // Créer un point lumineux au loin
            const lightPosition = new THREE.Vector3(
                window.boat.position.x + (Math.random() - 0.5) * 2,
                WATER_LEVEL + 1.5,
                window.boat.position.z + 50
            );
            
            // Lumière distante
            const distantLight = new THREE.PointLight(0xffffaa, 2, 50);
            distantLight.position.copy(lightPosition);
            window.scene.add(distantLight);
            
            // Halo visuel
            const haloGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const haloMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffaa,
                transparent: true,
                opacity: 0.7
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.position.copy(lightPosition);
            window.scene.add(halo);
            
            // Pulse animation
            halo.userData.update = (time) => {
                const pulse = 1 + Math.sin(time * 3) * 0.3;
                halo.scale.set(pulse, pulse, pulse);
                distantLight.intensity = 1.5 + Math.sin(time * 3) * 0.5;
            };
            
            // Ajouter à la liste des éléments mystérieux pour l'animation
            window.mysteryElements[halo.uuid] = halo;
            
            // Déplacer le bateau automatiquement vers la lumière
            setTimeout(() => {
                // Accélérer le bateau
                window.boatSpeed = 0.12;
                
                // Attendre que le bateau s'approche
                const checkInterval = setInterval(() => {
                    const distance = halo.position.distanceTo(window.boat.position);
                    
                    if (distance < 10) {
                        clearInterval(checkInterval);
                        window.boatSpeed = 0.05;
                        
                        // Effet de révélation
                        flashLightEffect(0xffffaa);
                        distortScreenEffect(1);
                        
                        // Faire disparaître la lumière
                        let scale = 1;
                        const fadeInterval = setInterval(() => {
                            scale += 0.2;
                            halo.scale.set(scale, scale, scale);
                            haloMaterial.opacity -= 0.05;
                            distantLight.intensity -= 0.1;
                            
                            if (haloMaterial.opacity <= 0) {
                                clearInterval(fadeInterval);
                                window.scene.remove(halo);
                                window.scene.remove(distantLight);
                                delete window.mysteryElements[halo.uuid];
                                
                                // Récompense
                                revealRandomClue();
                                showNarrativeMessage("La lumière révèle un secret avant de disparaître...", 5000);
                            }
                        }, 100);
                    }
                }, 500);
            }, 3000);
        }
        
        // Créer une porte spéciale basée sur un résultat de vote
        function spawnSpecialDoor(doorType) {
            // Position visible devant le bateau
            const doorPosition = new THREE.Vector3(
                window.boat.position.x + (Math.random() - 0.5) * 3,
                WATER_LEVEL + 1.5,
                window.boat.position.z + 8
            );
            
            // Déterminer le type de porte
            let doorSymbol = "symbol";
            if (doorType.includes("spirale")) {
                doorSymbol = "symbol";
            } else if (doorType.includes("rouge")) {
                doorSymbol = "blood";
            } else if (doorType.includes("griffes")) {
                doorSymbol = "claw";
            }
            
            // Créer la porte spéciale
            const door = createDoor(true);
            door.position.copy(doorPosition);
            
            // Vertical orientation
            if (doorPosition.x < 0) {
                door.rotation.y = Math.PI/2; // Left side
            } else {
                door.rotation.y = -Math.PI/2; // Right side
            }
            door.rotation.z = 0; // Ensure door is vertical
            
            // Assigner le symbole spécifique
            door.userData.doorSymbol = doorSymbol;
            
            // S'assurer qu'elle contient un indice
            door.userData.containsClue = true;
            
            // Ajouter un indice non découvert
            const availableClues = STORY_ELEMENTS.clues.filter(
                clue => !window.discoveredClues.includes(clue.id)
            );
            
            if (availableClues.length > 0) {
                const randomClue = availableClues[Math.floor(Math.random() * availableClues.length)];
                door.userData.narrativeElement = {
                    type: "clue",
                    data: randomClue
                };
            }
            
            // Enregistrer la porte
            window.doors.push(door);
            window.scene.add(door);
            registerSpecialDoor(door);
            
            // Effet de matérialisation
            door.scale.set(0.1, 0.1, 0.1);
            
            // Animation d'apparition
            let scale = 0.1;
            const appearInterval = setInterval(() => {
                scale += 0.05;
                door.scale.set(scale, scale, scale);
                
                if (scale >= 1) {
                    clearInterval(appearInterval);
                    
                    // Effets visuels
                    flashLightEffect(0xaaffaa);
                    
                    // Attirer l'attention
                    door.traverse(child => {
                        if (child.isMesh && child.material) {
                            const originalColor = child.material.color.clone();
                            
                            // Faire pulser la couleur
                            let pulseTime = 0;
                            const pulseInterval = setInterval(() => {
                                pulseTime += 0.1;
                                
                                // Couleur pulsante
                                const pulseColor = new THREE.Color().copy(originalColor);
                                pulseColor.r += Math.sin(pulseTime * 5) * 0.3;
                                pulseColor.g += Math.sin(pulseTime * 5) * 0.3;
                                pulseColor.b += Math.sin(pulseTime * 5) * 0.3;
                                
                                child.material.color.copy(pulseColor);
                                
                                if (pulseTime > 3) {
                                    clearInterval(pulseInterval);
                                    child.material.color.copy(originalColor);
                                }
                            }, 50);
                        }
                    });
                }
            }, 50);
        }
        
        // ==========================================
        // FONCTIONS POUR LES PALIERS NARRATIFS
        // ==========================================
        
        // Débloquer le prologue
        function unlockPrologue(username) {
            showNarrativeMessage("Vous entrez dans les tunnels, ignorant ce qui vous attend...", 8000);
            
            // Ajouter des effets visuels subtils
            pulseLightEffect(0xaaffff, 3);
            
            // Ajuster l'ambiance
            window.scene.fog.density = 0.02;
            
            // Révéler le premier indice
            setTimeout(revealRandomClue, 5000);
        }
        
        // Débloquer le secteur 2
        function unlockSector2(username) {
            showNarrativeMessage("Les formes dans l'eau commencent à bouger avec intention...", 8000);
            
            // Effet visuel sur l'eau
            window.segments.forEach(segment => {
                if (segment.userData.water) {
                    // Changer la couleur de l'eau
                    segment.userData.water.material.color.set(0x005577);
                }
            });
            
            // Ajouter des ondulations à l'eau
            window.waterAnimation = true;
            
            // Déclencher un événement spécial
            setTimeout(spawnSpecialEntity, 3000);
        }
        
        // Débloquer le secteur 3
        function unlockSector3(username) {
            showNarrativeMessage("Des symboles étranges apparaissent sur les portes. Ils semblent former un motif...", 8000);
            
            // Ajouter des symboles à toutes les portes
            window.doors.forEach(door => {
                if (!door.userData.doorSymbol && Math.random() < 0.3) {
                    door.userData.doorSymbol = "symbol";
                    door.userData.symbolType = Math.floor(Math.random() * 5);
                    addSymbolToDoor(door, door.children.find(child => child.name === "plate" || child instanceof THREE.Mesh));
                }
            });
            
            // Lancer un vote
            setTimeout(startVote, 10000);
        }
        
        // Débloquer le secteur 4
        function unlockSector4(username) {
            showNarrativeMessage("L'eau vibre à intervalles réguliers, comme si quelque chose d'énorme se déplaçait en dessous...", 8000);
            
            // Créer un effet de tremblement périodique
            window.pulseInterval = setInterval(() => {
                cameraShakeEffect(0.3);
                
                // Sons de vibration
                console.log("Son: Vibration profonde");
                
                // Effet sur l'eau
                window.segments.forEach(segment => {
                    if (segment.userData.water) {
                        segment.userData.water.position.y = WATER_LEVEL + 0.1;
                        
                        setTimeout(() => {
                            segment.userData.water.position.y = WATER_LEVEL;
                        }, 300);
                    }
                });
            }, 15000);
            
            // Révéler plusieurs indices
            for (let i = 0; i < 2; i++) {
                setTimeout(revealRandomClue, 5000 + i * 15000);
            }
        }
        
        // Débloquer la confrontation mineure
        function unlockMinorEntity(username) {
            showNarrativeMessage("Une présence observe chacun de vos mouvements... Elle se rapproche...", 8000);
            
            // Créer l'entité observatrice
            const entityPosition = new THREE.Vector3(
                window.boat.position.x,
                WATER_LEVEL + 1,
                window.boat.position.z + 15
            );
            
            const observer = new THREE.Group();
            observer.position.copy(entityPosition);
            
            // Corps principal - silhouette sombre
            const bodyGeometry = new THREE.SphereGeometry(1, 16, 16);
            const bodyMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.7
            });
            
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.scale.set(1, 1.5, 1);
            observer.add(body);
            
            // Yeux brillants
            const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00
                // emissive et emissiveIntensity ne sont pas supportés par MeshBasicMaterial
            });
            
            // Trois yeux disposés en triangle
            const eyes = [];
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2;
                const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye.position.set(
                    Math.cos(angle) * 0.3,
                    0.5 + Math.sin(angle) * 0.3,
                    0.8
                );
                
                const eyeLight = new THREE.PointLight(0xffff00, 0.5, 2);
                eyeLight.position.set(0, 0, 0.1);
                eye.add(eyeLight);
                
                body.add(eye);
                eyes.push(eye);
            }
            
            // Animation
            observer.userData.update = (time) => {
                // Mouvement de flottement
                observer.position.y = WATER_LEVEL + 1 + Math.sin(time * 0.5) * 0.2;
                
                // Yeux clignotants
                eyes.forEach((eye, i) => {
                    eye.visible = Math.sin(time * 3 + i) > 0;
                });
                
                // L'observateur suit le bateau à distance
                const targetPosition = new THREE.Vector3(
                    window.boat.position.x,
                    observer.position.y,
                    window.boat.position.z + 15 + Math.sin(time) * 3
                );
                
                observer.position.x += (targetPosition.x - observer.position.x) * 0.01;
                observer.position.z += (targetPosition.z - observer.position.z) * 0.01;
                
                // Orientation vers le bateau
                observer.lookAt(window.boat.position);
            };
            
            // Ajouter à la scène
            window.scene.add(observer);
            window.mysteryElements[observer.uuid] = observer;
            
            // Message du donateur qui a débloqué cette entité
            if (username) {
                showNarrativeMessage(`L'Observateur a été invoqué par ${username}...`, 5000);
            }
            
            // L'observateur reste pendant longtemps
            setTimeout(() => {
                // Disparition
                let opacity = 0.7;
                const fadeInterval = setInterval(() => {
                    opacity -= 0.02;
                    
                    observer.traverse(child => {
                        if (child.material && child.material.opacity !== undefined) {
                            child.material.opacity = opacity;
                        }
                    });
                    
                    if (opacity <= 0) {
                        clearInterval(fadeInterval);
                        window.scene.remove(observer);
                        delete window.mysteryElements[observer.uuid];
                    }
                }, 100);
            }, 120000); // 2 minutes
        }
        
        // Débloquer le secteur 5
        function unlockSector5(username) {
            showNarrativeMessage("La réalité semble se distordre. Des portes mènent à des lieux impossibles...", 8000);
            
            // Effet de distorsion
            distortScreenEffect(3);
            
            // Modifier l'apparence du tunnel
            window.scene.fog.color.set(0x330033);
            window.scene.fog.density = 0.04;
            
            // Modifier la couleur des lumières
            window.scene.traverse(obj => {
                if (obj instanceof THREE.PointLight && obj !== window.boat.userData.lanternLight) {
                    obj.color.set(0xaa55ff);
                }
            });
            
            // Créer des portes spéciales
            setTimeout(() => {
                // Porte qui mène à une distorsion spatiale
                spawnSpecialDoor("spirale");
            }, 5000);
        }
        
        // Débloquer le secteur 6
        function unlockSector6(username) {
            showNarrativeMessage("Les indices commencent à former un schéma cohérent. La vérité se rapproche...", 8000);
            
            // Révéler plusieurs indices rapprochés
            for (let i = 0; i < 3; i++) {
                setTimeout(revealRandomClue, 2000 + i * 5000);
            }
            
            // Visualisation du schéma
            setTimeout(() => {
                // Créer une visualisation flottante des indices connectés
                const patternPosition = new THREE.Vector3(
                    window.boat.position.x,
                    WATER_LEVEL + 1.5,
                    window.boat.position.z + 8
                );
                
                const pattern = new THREE.Group();
                pattern.position.copy(patternPosition);
                
                // Cadre
                const frameGeometry = new THREE.TorusGeometry(1.5, 0.05, 16, 32);
                const frameMaterial = new THREE.MeshBasicMaterial({
                    color: 0xaaaaff,
                    transparent: true,
                    opacity: 0.8
                });
                
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                pattern.add(frame);
                
                // Points représentant les indices
                const points = [];
                const lines = [];
                
                for (let i = 0; i < window.discoveredClues.length; i++) {
                    const angle = (i / window.discoveredClues.length) * Math.PI * 2;
                    const radius = 1.2;
                    
                    const pointGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                    const pointMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff
                    });
                    
                    const point = new THREE.Mesh(pointGeometry, pointMaterial);
                    point.position.set(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius,
                        0
                    );
                    
                    pattern.add(point);
                    points.push(point);
                    
                    // Ajouter des lignes entre certains points
                    if (i > 0) {
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                            points[i-1].position,
                            point.position
                        ]);
                        
                        const lineMaterial = new THREE.LineBasicMaterial({
                            color: 0xaaaaff,
                            transparent: true,
                            opacity: 0.5
                        });
                        
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        pattern.add(line);
                        lines.push(line);
                    }
                }
                
                // Animation du pattern
                pattern.userData.update = (time) => {
                    // Rotation lente
                    pattern.rotation.z = time * 0.2;
                    
                    // Pulsation des points
                    points.forEach((point, i) => {
                        point.scale.setScalar(0.8 + Math.sin(time * 3 + i) * 0.3);
                    });
                    
                    // Opacité des lignes
                    lines.forEach((line, i) => {
                        line.material.opacity = 0.3 + Math.sin(time * 2 + i) * 0.2;
                    });
                };
                
                // Ajouter à la scène
                window.scene.add(pattern);
                window.mysteryElements[pattern.uuid] = pattern;
                
                // Faire disparaître après un moment
                setTimeout(() => {
                    // Animation de disparition
                    let opacity = 1;
                    let scale = 1;
                    
                    const fadeInterval = setInterval(() => {
                        opacity -= 0.02;
                        scale += 0.05;
                        
                        pattern.scale.set(scale, scale, scale);
                        
                        pattern.traverse(child => {
                            if (child.material && child.material.opacity !== undefined) {
                                child.material.opacity = opacity;
                            }
                        });
                        
                        if (opacity <= 0) {
                            clearInterval(fadeInterval);
                            window.scene.remove(pattern);
                            delete window.mysteryElements[pattern.uuid];
                        }
                    }, 50);
                }, 30000);
            }, 15000);
        }
        
        // Débloquer la confrontation majeure
        function unlockMajorEntity(username) {
            showNarrativeMessage("Une présence ancienne bloque votre chemin. Vous devez l'affronter pour continuer...", 8000);
            
            // Faire apparaître l'entité majeure
            setTimeout(() => {
                spawnBossEntity();
            }, 5000);
            
            // Message du donateur qui a débloqué cette entité
            if (username) {
                showNarrativeMessage(`Le Gardien a été provoqué par ${username}...`, 5000);
            }
        }
        
        // Débloquer le secteur 7
        function unlockSector7(username) {
            showNarrativeMessage("Les derniers fragments du mystère se dévoilent. La vérité est presque à portée...", 8000);
            
            // Effet visuel important
            flashLightEffect(0xffffff);
            distortScreenEffect(2);
            
            // Révéler tous les indices restants
            STORY_ELEMENTS.clues.forEach(clue => {
                if (!window.discoveredClues.includes(clue.id)) {
                    setTimeout(() => {
                        revealClue(clue);
                    }, Math.random() * 30000); // Étalé sur 30 secondes
                }
            });
            
            // Changement d'ambiance majeur
            window.scene.fog.color.set(0x220022);
            window.scene.fog.density = 0.03;
            
            window.scene.background = new THREE.Color(0x110011);
            
            // Modifier la couleur de l'eau
            window.segments.forEach(segment => {
                if (segment.userData.water) {
                    segment.userData.water.material.color.set(0x220044);
                }
            });
        }
        
        // Débloquer le finale
        function unlockFinale(username) {
            showNarrativeMessage("La vérité sur Les Profondeurs est sur le point d'être révélée...", 8000);
            
            // Compte à rebours dramatique
            countdownEffect(10, () => {
                // Effet final
                darkenEffect(3);
                
                setTimeout(() => {
                    // Lumière aveuglante
                    const finalLight = new THREE.PointLight(0xffffff, 10, 50);
                    finalLight.position.set(
                        window.boat.position.x,
                        window.boat.position.y + 3,
                        window.boat.position.z + 20
                    );
                    window.scene.add(finalLight);
                    
                    // Message final
                    const finalMessage = `
                        Les Profondeurs n'ont jamais été un lieu physique, mais une projection mentale collective.
                        
                        Chaque porte ouverte était une fenêtre vers une conscience différente.
                        
                        Le sixième cycle s'achève. Le prochain cycle commence...
                        
                        À suivre dans la Saison 2: "Les Résonances"
                    `;
                    
                    showNarrativeMessage(finalMessage, 20000);
                    
                    // Faire disparaître tout sauf le bateau
                    window.doors.forEach(door => {
                        window.scene.remove(door);
                    });
                    
                    Object.values(window.mysteryElements).forEach(element => {
                        window.scene.remove(element);
                    });
                    
                    // Animation finale
                    window.boatSpeed = 0.2;
                    
                    setTimeout(() => {
                        // Écran blanc
                        const whiteScreen = document.createElement('div');
                        whiteScreen.style.position = 'fixed';
                        whiteScreen.style.top = '0';
                        whiteScreen.style.left = '0';
                        whiteScreen.style.width = '100%';
                        whiteScreen.style.height = '100%';
                        whiteScreen.style.backgroundColor = 'white';
                        whiteScreen.style.opacity = '0';
                        whiteScreen.style.transition = 'opacity 5s';
                        whiteScreen.style.zIndex = '2000';
                        document.body.appendChild(whiteScreen);
                        
                        setTimeout(() => {
                            whiteScreen.style.opacity = '1';
                            
                            // Crédit de fin
                            setTimeout(() => {
                                whiteScreen.innerHTML = `
                                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: black; font-family: Arial, sans-serif;">
                                        <h1 style="font-size: 36px; margin-bottom: 50px;">Fin de la Saison 1</h1>
                                        <p style="font-size: 24px; margin-bottom: 20px;">Merci à tous les Explorateurs</p>
                                        <p style="font-size: 18px; margin-bottom: 10px;">Mystères résolus: ${window.solvedMysteries}/${STORY_ELEMENTS.mysteries.length}</p>
                                        <p style="font-size: 18px; margin-bottom: 10px;">Portes ouvertes: ${window.activatedDoors}</p>
                                        <p style="font-size: 18px; margin-bottom: 50px;">Total des dons: ${window.totalDonations} unités</p>
                                        <p style="font-size: 24px;">Rendez-vous dans la Saison 2...</p>
                                    </div>
                                `;
                            }, 5000);
                        }, 100);
                    }, 10000);
                }, 3000);
            });
        }
        
        // ==========================================
        // BOUCLE D'ANIMATION
        // ==========================================
        
        // Mettre à jour les éléments mystérieux dans l'animation principale
        function updateMysteryElements(time) {
            // Limiter la mise à jour aux éléments visibles ou proches du bateau
            const maxDistance = TUNNEL_LENGTH / 2;  // Ne mettre à jour que les éléments à portée visuelle
            
            // Parcourir tous les éléments mystérieux pour les animer
            Object.values(window.mysteryElements).forEach(element => {
                // Vérifier si l'élément est proche du bateau
                if (element.position && window.boat.position) {
                    const dx = element.position.x - window.boat.position.x;
                    const dz = element.position.z - window.boat.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    // Ne mettre à jour que les éléments à portée
                    if (distance < maxDistance && element.userData.update) {
                        element.userData.update(time);
                    }
                } else if (element.userData.update) {
                    // Pour les éléments sans position (ex: effets globaux), mettre à jour normalement
                    element.userData.update(time);
                }
            });
            
            // Animation de l'eau - limiter aux segments visibles
            if (window.waterAnimation) {
                const boatZ = window.boat.position.z;
                window.segments.forEach(segment => {
                    // Ne mettre à jour que les segments proches du bateau
                    if (Math.abs(segment.userData.zPosition - boatZ) < maxDistance && segment.userData.water) {
                        segment.userData.water.material.color.lerp(
                            segment.userData.waterBaseColor, 
                            0.05
                        );
                        
                        // Ondulation légère
                        segment.userData.water.position.y = 
                            WATER_LEVEL + Math.sin(time * 2 + segment.position.z * 0.1) * 0.05;
                    }
                });
            }
            
            // Animation des lumières murales - limiter aux segments visibles
            window.segments.forEach(segment => {
                // Ne mettre à jour que les segments proches du bateau
                if (Math.abs(segment.userData.zPosition - window.boat.position.z) < maxDistance) {
                    segment.traverse(obj => {
                        if (obj.userData && obj.userData.flicker && obj.userData.light) {
                            const flickerAmount = Math.sin(time * obj.userData.flickerSpeed) * 0.3 + 0.7;
                            obj.userData.light.intensity = obj.userData.originalIntensity * flickerAmount;
                            
                            // Animation de couleur progressive (moins fréquente)
                            if (obj.userData.originalColor && window.frameCount % 6 === 0) {
                                const hue = (time * 0.05) % 1;
                                const newColor = new THREE.Color().setHSL(
                                    hue, 
                                    0.7, 
                                    obj.userData.originalColor.getHSL({}).l
                                );
                                
                                obj.userData.light.color.lerp(newColor, 0.01);
                                
                                if (obj.userData.bulb) {
                                    obj.userData.bulb.material.color.copy(obj.userData.light.color);
                                }
                            }
                        }
                    });
                }
            });
            
            // Animation narrative du bateau
            if (window.boat.userData.lanternLight) {
                const lanternFlicker = 0.8 + Math.sin(time * 5) * 0.2;
                window.boat.userData.lanternLight.intensity = window.boat.userData.lanternOriginalIntensity * lanternFlicker;
            }
        }
        
        // Fonction principale d'animation avec optimisation des performances
        function animate() {
            // Pour mesurer et limiter les performances
            if (!window.frameCounter) window.frameCounter = 0;
            window.frameCounter++;
            
            const currentTime = performance.now();
            if (!window.lastAnimationTime) window.lastAnimationTime = currentTime;
            const deltaTime = (currentTime - window.lastAnimationTime) / 1000; // en secondes
            window.lastAnimationTime = currentTime;
            
            // Limiter le deltaTime max pour éviter les sauts extrêmes
            const cappedDeltaTime = Math.min(deltaTime, 0.1);
            
            if (window.boat && window.camera && !window.isPaused) {
                // Définir boatPosition pour référencer la position du bateau
                const boatPosition = window.boat.position;
                
                // Toujours avancer le bateau à une vitesse constante dans l'axe Z
                const boatSpeed = 0.05;
                boatPosition.z += boatSpeed;
                
                // Si on n'a pas de position cible, créer une par défaut
                if (!window.boatTargetPosition) {
                    window.boatTargetPosition = {
                        x: boatPosition.x,
                        z: boatPosition.z + 10
                    };
                }
                
                // Si on n'a pas de position précédente, initialiser
                if (!window.previousBoatPosition) {
                    window.previousBoatPosition = {
                        x: boatPosition.x, 
                        z: boatPosition.z - boatSpeed // Position juste avant la position actuelle
                    };
                }
                
                // Mise à jour moins fréquente du pitch/roll du bateau (économise des calculs)
                if (window.frameCounter % 3 === 0) {
                    // Rotation du bateau en fonction de la vitesse
                    const dx = boatPosition.x - window.previousBoatPosition.x;
                    const dz = boatPosition.z - window.previousBoatPosition.z;
                    
                    if (Math.abs(dx) > 0.001 || Math.abs(dz) > 0.001) {
                        const targetRotation = Math.atan2(dx, dz);
                        // Interpolation plus douce pour la rotation
                        window.boat.rotation.y += (targetRotation - window.boat.rotation.y) * Math.min(2 * cappedDeltaTime, 0.1);
                    }
                    
                    // Simuler le mouvement de la mer
                    if (window.canRock) {
                        window.boat.rotation.x = Math.sin(currentTime / 1000) * 0.03;
                        window.boat.rotation.z = Math.sin(currentTime / 1200) * 0.02;
                    }
                    
                    // Mettre à jour la position précédente
                    window.previousBoatPosition = { x: boatPosition.x, z: boatPosition.z };
                }
                
                // La caméra suit toujours le bateau à chaque frame pour une expérience fluide
                updateCameraPosition();
                
                // Mise à jour des mystères moins fréquente (économise beaucoup de calculs)
                if (window.frameCounter % 5 === 0) {
                    updateMysteryElements(currentTime / 1000); 
                }
                
                // Vérification de tunnel chaque seconde
                if (window.frameCounter % 60 === 0) {
                    checkTunnel();
                }
                
                // Limiter la mise à jour du panneau de votes si présent
                if (window.votePanel && window.frameCounter % 30 === 0) {
                    updateVotePanel();
                }
            }
            
            // Rendre la scène
            if (window.renderer && window.scene && window.camera) {
                window.renderer.render(window.scene, window.camera);
            }
            
            // Appeler la prochaine frame
            requestAnimationFrame(animate);
        }
        
        // Ajout de la fonction manquante updateCameraPosition
        function updateCameraPosition() {
            if (!window.camera || !window.boat) return;
            
            // Positionner la caméra derrière le bateau
            window.camera.position.x = window.boat.position.x;
            window.camera.position.y = window.boat.position.y + 1.5;
            window.camera.position.z = window.boat.position.z - 5;
            
            // Orienter la caméra vers le bateau
            window.camera.lookAt(window.boat.position);
        }
        
        // ==========================================
        // INITIALISATION DE L'APPLICATION
        // ==========================================
        
        // Vérifier si Three.js est disponible et initialiser l'application
        window.onload = function() {
            if (typeof THREE === 'undefined') {
                document.getElementById('loading').innerHTML = 
                    "<h1>Erreur</h1><p>Impossible de charger Three.js. " +
                    "Vérifiez votre connexion internet ou essayez un autre navigateur.</p>";
                return;
            }
            
            // Simuler le chargement
            simulateLoading();
            
            // Initialiser l'application après un délai pour l'écran de chargement
            setTimeout(init, 3000);
        };
        
        // ==========================================
        // LEADERBOARD & HISTORIQUE
        // ==========================================
        
        // Initialiser les structures de données
        window.leaderboard = [];
        window.storyHistory = [];
        
        // Mettre à jour le leaderboard
        function updateLeaderboard(username, amount) {
            // Assurez-vous que le tableau des contributeurs existe
            if (!window.leaderboard) {
                window.leaderboard = [];
            }
            
            // Vérifier si l'utilisateur existe déjà dans le classement
            let userExists = false;
            for (let i = 0; i < window.leaderboard.length; i++) {
                if (window.leaderboard[i].username === username) {
                    // Mettre à jour le montant
                    window.leaderboard[i].amount += amount;
                    window.leaderboard[i].lastDonation = Date.now(); // Ajouter timestamp pour tri récent
                    userExists = true;
                    break;
                }
            }
            
            // Si l'utilisateur n'existe pas, l'ajouter
            if (!userExists) {
                window.leaderboard.push({
                    username: username,
                    amount: amount,
                    lastDonation: Date.now() // Timestamp pour tri récent
                });
            }
            
            // Trier le classement par montant décroissant
            window.leaderboard.sort((a, b) => b.amount - a.amount);
            
            // Conserver uniquement les 100 premiers pour le Top 100
            if (window.leaderboard.length > 100) {
                window.leaderboard = window.leaderboard.slice(0, 100);
            }
            
            // Afficher le classement
            renderLeaderboard();
            renderTop100();
            
            // S'assurer que les tableaux sont visibles
            const leaderboardPanel = document.getElementById('leaderboard-panel');
            if (leaderboardPanel.style.display === 'none' || !leaderboardPanel.style.display) {
                leaderboardPanel.style.display = 'block';
            }
            
            // Ne pas afficher le top100 qui fait double emploi
            const top100Panel = document.getElementById('top100-panel');
            if (top100Panel) {
                top100Panel.style.display = 'none';
            }
            
            // Mettre à jour les fenêtres de détails si elles sont ouvertes
            if (window.detailWindows && window.detailWindows.length > 0) {
                window.sendDataToExplorationDetails();
            }
        }
        
        // Afficher le leaderboard
        function renderLeaderboard() {
            const leaderboardList = document.getElementById('leaderboard-list');
            if (!leaderboardList) return;
            
            leaderboardList.innerHTML = '';
            
            if (!window.leaderboard || window.leaderboard.length === 0) {
                leaderboardList.innerHTML = '<div class="leaderboard-item">Aucun donateur</div>';
            } else {
                // Wrap content in autoscroll container
                const scrollContainer = document.createElement('div');
                scrollContainer.className = 'autoscroll-container';
                
                const scrollContent = document.createElement('div');
                scrollContent.className = 'autoscroll-content';
                
                // Calculate animation duration based on content length
                const durationInSeconds = Math.max(20, Math.min(60, window.leaderboard.length * 4));
                scrollContent.style.animationDuration = durationInSeconds + 's';
                
                window.leaderboard.forEach((entry, index) => {
                    const item = document.createElement('div');
                    item.className = 'leaderboard-item';
                    item.style.position = 'relative';  // Pour permettre le positionnement absolu du numéro
                    
                    const rank = document.createElement('div');
                    rank.className = 'leaderboard-rank';
                    rank.textContent = `#${index + 1}`;
                    
                    const name = document.createElement('div');
                    name.className = 'leaderboard-name';
                    name.textContent = entry.username;
                    
                    const score = document.createElement('div');
                    score.className = 'leaderboard-score';
                    score.textContent = `${entry.amount} unités`;
                    
                    // Numéro d'entrée global (différent du rank qui est basé sur le score)
                    const entryNumber = document.createElement('div');
                    entryNumber.style.position = 'absolute';
                    entryNumber.style.right = '3px';
                    entryNumber.style.top = '0px';
                    entryNumber.style.fontSize = '7px';
                    entryNumber.style.color = '#777';
                    entryNumber.textContent = `E${index + 1}`;
                    
                    item.appendChild(rank);
                    item.appendChild(name);
                    item.appendChild(score);
                    item.appendChild(entryNumber);
                    
                    scrollContent.appendChild(item);
                });
                
                scrollContainer.appendChild(scrollContent);
                leaderboardList.appendChild(scrollContainer);
            }
        }
        
        // Après la fonction renderLeaderboard, ajouter la fonction renderTop100
        function renderTop100() {
            const top100List = document.getElementById('top100-list');
            if (!top100List) return;
            
            top100List.innerHTML = '';
            
            if (!window.leaderboard || window.leaderboard.length === 0) {
                top100List.innerHTML = '<div class="top100-item">Aucun donateur</div>';
            } else {
                // Wrap content in autoscroll container
                const scrollContainer = document.createElement('div');
                scrollContainer.className = 'autoscroll-container';
                
                const scrollContent = document.createElement('div');
                scrollContent.className = 'autoscroll-content';
                
                // Calculate animation duration based on content length
                const durationInSeconds = Math.max(30, Math.min(120, window.leaderboard.length * 2));
                scrollContent.style.animationDuration = durationInSeconds + 's';
                
                window.leaderboard.forEach((entry, index) => {
                    if (index < 100) { // Limiter à 100 entrées
                        const item = document.createElement('div');
                        item.className = 'top100-item';
                        
                        const rank = document.createElement('div');
                        rank.className = 'top100-rank';
                        rank.textContent = `#${index + 1}`;
                        
                        const name = document.createElement('div');
                        name.className = 'top100-name';
                        name.textContent = entry.username;
                        
                        const score = document.createElement('div');
                        score.className = 'top100-score';
                        score.textContent = `${entry.amount} unités`;
                        
                        // Numéro d'entrée global
                        const entryNumber = document.createElement('div');
                        entryNumber.style.position = 'absolute';
                        entryNumber.style.right = '3px';
                        entryNumber.style.top = '0px';
                        entryNumber.style.fontSize = '7px';
                        entryNumber.style.color = '#777';
                        entryNumber.textContent = `E${index + 1}`;
                        
                        item.appendChild(rank);
                        item.appendChild(name);
                        item.appendChild(score);
                        
                        scrollContent.appendChild(item);
                    }
                });
                
                scrollContainer.appendChild(scrollContent);
                top100List.appendChild(scrollContainer);
            }
        }
        
        // Ajouter une entrée à l'historique
        function addToStoryHistory(type, content) {
            if (!window.storyHistory) {
                window.storyHistory = [];
            }
            
            // Vérification stricte des doublons - éviter de traiter des messages identiques
            const isDuplicate = window.storyHistory.some(entry => 
                entry.content === content && 
                (Date.now() - entry.rawTimestamp) < 30000 // 30 secondes pour être sûr
            );
            
            if (isDuplicate) return;
            
            const now = new Date();
            const entry = {
                type: type,
                content: content,
                timestamp: now.toLocaleTimeString(),
                rawTimestamp: Date.now()
            };
            
            window.storyHistory.unshift(entry);
            
            // Limiter la taille pour éviter trop de DOM et de mémoire
            if (window.storyHistory.length > 20) { // Réduit de 30 à 20
                window.storyHistory = window.storyHistory.slice(0, 20);
            }
            
            // Optimisation: ne pas rendre le contenu à chaque fois, mais limiter la fréquence
            if (!window.historyRenderTimeout) {
                window.historyRenderTimeout = setTimeout(() => {
                    renderStoryHistory();
                    window.historyRenderTimeout = null;
                    
                    // Mettre à jour les fenêtres de détails si elles sont ouvertes
                    if (window.detailWindows && window.detailWindows.length > 0) {
                        window.sendDataToExplorationDetails();
                    }
                }, 500); // Regrouper les mises à jour en un seul rendu toutes les 500ms
            }
            
            // S'assurer que le panneau est visible
            const historyPanel = document.getElementById('story-history-panel');
            if (historyPanel.style.display === 'none' || !historyPanel.style.display) {
                historyPanel.style.display = 'block';
            }
        }
        
        // Afficher l'historique
        function renderStoryHistory() {
            const historyList = document.getElementById('story-history-list');
            if (!historyList) return;
            
            historyList.innerHTML = '';
            
            if (!window.storyHistory || window.storyHistory.length === 0) {
                historyList.innerHTML = '<div class="history-item">Aucun événement enregistré</div>';
            } else {
                // Wrap content in autoscroll container
                const scrollContainer = document.createElement('div');
                scrollContainer.className = 'autoscroll-container';
                
                const scrollContent = document.createElement('div');
                scrollContent.className = 'autoscroll-content';
                
                // Calculate animation duration based on content length
                const durationInSeconds = Math.max(20, Math.min(60, window.storyHistory.length * 4));
                scrollContent.style.animationDuration = durationInSeconds + 's';
                
                // En-têtes pour les types d'entrées
                const typeLabels = {
                    'milestone': '📜 Progression',
                    'discovery': '🔍 Découverte',
                    'event': '⚡ Événement'
                };
                
                window.storyHistory.forEach((entry, index) => {
                    const item = document.createElement('div');
                    item.className = `history-item history-item-${entry.type}`;
                    
                    // Ajouter un numéro d'entrée
                    const entryNumber = document.createElement('div');
                    entryNumber.className = 'history-number';
                    entryNumber.textContent = `#${index + 1}`;
                    entryNumber.style.position = 'absolute';
                    entryNumber.style.right = '5px';
                    entryNumber.style.top = '3px';
                    entryNumber.style.fontSize = '8px';
                    entryNumber.style.color = '#aaa';
                    entryNumber.style.fontWeight = 'bold';
                    
                    const timestamp = document.createElement('div');
                    timestamp.className = 'history-timestamp';
                    timestamp.textContent = entry.timestamp;
                    
                    const typeLabel = document.createElement('div');
                    typeLabel.style.fontWeight = 'bold';
                    typeLabel.style.fontSize = '10px';
                    typeLabel.style.marginBottom = '2px';
                    typeLabel.textContent = typeLabels[entry.type] || 'Message';
                    
                    const content = document.createElement('div');
                    content.textContent = entry.content;
                    
                    item.appendChild(entryNumber);
                    item.appendChild(timestamp);
                    item.appendChild(typeLabel);
                    item.appendChild(content);
                    
                    scrollContent.appendChild(item);
                });
                
                scrollContainer.appendChild(scrollContent);
                historyList.appendChild(scrollContainer);
            }
        }
        
        // Modifier les fonctions existantes pour enregistrer dans l'historique
        
        // Surcharger la fonction originale pour ajouter l'entrée au tableau
        const originalUnlockNextMilestone = unlockNextMilestone;
        unlockNextMilestone = function(username) {
            originalUnlockNextMilestone(username);
            
            const milestone = STORY_MILESTONES[window.currentMilestoneIndex];
            addToStoryHistory('milestone', `[${milestone.title}] ${milestone.description}`);
        };
        
        // Surcharger la fonction de révélation d'indice
        const originalRevealClue = revealClue;
        revealClue = function(clue) {
            originalRevealClue(clue);
            addToStoryHistory('discovery', `Indice découvert: ${clue.text}`);
        };
        
        // Surcharger la fonction d'événements spéciaux
        const originalTriggerSpecialEvent = triggerSpecialEvent;
        triggerSpecialEvent = function() {
            const eventType = Math.floor(Math.random() * 5);
            const eventNames = [
                "Apparition mystérieuse", 
                "Blackout soudain", 
                "Distorsion de réalité",
                "Porte qui s'ouvre",
                "Vote communautaire"
            ];
            
            addToStoryHistory('event', `Événement: ${eventNames[eventType]}`);
            return originalTriggerSpecialEvent();
        };
        
        // Modifier la fonction simulateDonation pour mettre à jour le leaderboard
        const originalSimulateDonation = simulateDonation;
        simulateDonation = function(username, amount) {
            originalSimulateDonation(username, amount);
            updateLeaderboard(username, amount);
        };
        
        // Fonction pour vérifier les dons externes (via localStorage)
        function checkExternalDonations() {
            const latestDonation = localStorage.getItem('latestDonation');
            if (latestDonation) {
                try {
                    const donation = JSON.parse(latestDonation);
                    // Vérifier si c'est une nouvelle donation (en utilisant le timestamp)
                    const lastProcessedDonation = localStorage.getItem('lastProcessedDonation') || '0';
                    
                    if (donation.timestamp > parseInt(lastProcessedDonation)) {
                        // Traiter la donation
                        simulateDonation(donation.username, donation.amount);
                        // Marquer comme traitée
                        localStorage.setItem('lastProcessedDonation', donation.timestamp.toString());
                    }
                } catch (e) {
                    console.error("Erreur lors du traitement d'une donation externe:", e);
                }
            }
        }
        
        // Écouter les messages du simulateur de dons externe
        window.addEventListener('message', function(event) {
            // Vérification de sécurité (si nécessaire, vérifiez l'origine)
            if (event.data && event.data.type === 'donation') {
                const donation = event.data.data;
                simulateDonation(donation.username, donation.amount);
            }
        });
        
        // Vérifier périodiquement les dons externes
        setInterval(checkExternalDonations, 2000);
        
        // Ajouter le gestionnaire pour ouvrir le simulateur de dons
        const openDonationSimulatorBtn = document.getElementById('open-donation-simulator');
        if (openDonationSimulatorBtn) {
            openDonationSimulatorBtn.addEventListener('click', function() {
                // Suppression de l'ouverture de la nouvelle fenêtre
                // window.open('donation_simulator.html', 'DonationSimulator', 'width=550,height=600');
                
                // Vérifier si un panneau existe déjà et le supprimer
                const existingPanel = document.getElementById('inline-donation-panel');
                if (existingPanel) {
                    existingPanel.remove();
                    return;
                }
                
                // Créer un panneau flottant
                const panel = document.createElement('div');
                panel.id = 'inline-donation-panel';
                panel.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    width: 300px;
                    background: rgba(0, 0, 0, 0.9);
                    border: 1px solid #ff3366;
                    z-index: 1000;
                    padding: 15px;
                    color: white;
                    border-radius: 5px;
                    box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
                `;
                
                // Ajouter le contenu du simulateur
                panel.innerHTML = `
                    <h3 style="text-align: center; margin-top: 0;">Simulateur de Dons</h3>
                    <button id="close-simulator" style="position: absolute; top: 5px; right: 5px; background: none; border: none; color: #fff; cursor: pointer; font-size: 16px;">×</button>
                    <div style="margin-bottom: 15px;">
                        <label>Nom d'utilisateur:</label>
                        <input type="text" id="sim-username" value="Utilisateur${Math.floor(Math.random() * 1000)}" style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label>Montant:</label>
                        <input type="number" id="sim-amount" value="5" min="1" max="1000" style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label>Message (optionnel):</label>
                        <input type="text" id="sim-message" placeholder="Message avec votre don..." style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <button id="donate-2" style="flex: 1; margin-right: 5px; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+2€</button>
                        <button id="donate-5" style="flex: 1; margin-right: 5px; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+5€</button>
                        <button id="donate-10" style="flex: 1; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+10€</button>
                    </div>
                    <button id="send-donation" style="width: 100%; margin-top: 15px; background: #ff3366; border: none; color: white; padding: 10px; cursor: pointer;">Simuler le Don</button>
                `;
                
                // Ajouter le panneau au document
                document.body.appendChild(panel);
                
                // Gérer la fermeture du panneau
                document.getElementById('close-simulator').addEventListener('click', () => {
                    panel.remove();
                });
                
                // Gérer les boutons de montant prédéfinis
                document.getElementById('donate-2').addEventListener('click', () => {
                    document.getElementById('sim-amount').value = "2";
                });
                
                document.getElementById('donate-5').addEventListener('click', () => {
                    document.getElementById('sim-amount').value = "5";
                });
                
                document.getElementById('donate-10').addEventListener('click', () => {
                    document.getElementById('sim-amount').value = "10";
                });
                
                // Gérer l'envoi du don
                document.getElementById('send-donation').addEventListener('click', async () => {
                    const username = document.getElementById('sim-username').value || `Utilisateur${Math.floor(Math.random() * 1000)}`;
                    const amount = parseFloat(document.getElementById('sim-amount').value) || 5;
                    const message = document.getElementById('sim-message').value || '';
                    
                    if (amount <= 0) {
                        alert('Veuillez entrer un montant positif.');
                        return;
                    }
                    
                    try {
                        // Simuler le don via l'API
                        const response = await fetch('/api/simulate/donation', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ username, amount, message })
                        });
                        
                        const data = await response.json();
                        
                        if (data.success) {
                            // Fermer le panneau après un don réussi
                            panel.remove();
                            // Traiter le don localement si nécessaire
                            simulateDonation(username, amount);
                        } else {
                            console.error('Erreur lors de la simulation du don:', data.message);
                            alert('Erreur lors de la simulation du don: ' + data.message);
                        }
                    } catch (error) {
                        console.error('Erreur lors de la simulation du don:', error);
                        alert('Erreur lors de la simulation du don.');
                    }
                });
            });
        }
        
        // Ajout de la fonction manquante updateCameraPosition
        function updateCameraPosition() {
            if (!window.camera || !window.boat) return;
            
            // Positionner la caméra derrière le bateau
            window.camera.position.x = window.boat.position.x;
            window.camera.position.y = window.boat.position.y + 1.5;
            window.camera.position.z = window.boat.position.z - 5;
            
            // Orienter la caméra vers le bateau
            window.camera.lookAt(window.boat.position);
        }
        
        // Fonction pour mettre à jour les éléments mystérieux (optimisée)
        function updateMysteryElements() {
            if (!window.mysteryElements || !window.boat) return;
            
            // Définir une distance maximale pour les mises à jour (optimisation importante)
            const maxDistance = 250; // Unités 3D
            const maxDistanceSquared = maxDistance * maxDistance;
            
            for (let i = 0; i < window.mysteryElements.length; i++) {
                const element = window.mysteryElements[i];
                if (!element || !element.mesh) continue;
                
                // Calculer la distance au carré (évite le calcul coûteux de racine carrée)
                const dx = element.mesh.position.x - window.boat.position.x;
                const dz = element.mesh.position.z - window.boat.position.z;
                const distanceSquared = dx * dx + dz * dz;
                
                // Ne mettre à jour que les éléments proches du bateau
                if (distanceSquared > maxDistanceSquared) {
                    // Si l'élément a une propriété visible, le cacher s'il est trop loin
                    if (element.mesh.visible) {
                        element.mesh.visible = false;
                    }
                    continue;
                } else if (!element.mesh.visible) {
                    // Rendre visible si on s'en rapproche
                    element.mesh.visible = true;
                }
                
                // Animation de l'eau (moins fréquente)
                if (element.type === 'water' && window.frameCounter % 10 === 0) {
                    const time = performance.now() / 1000;
                    element.mesh.position.y = Math.sin(time + i) * 0.2 - 0.5;
                }
                
                // Animation de certains objets
                if (element.type === 'apparition') {
                    // Animation plus simple
                    const time = performance.now() / 1000;
                    element.mesh.rotation.y += 0.01;
                    element.mesh.position.y = Math.sin(time) * 0.5 + element.initialY;
                } else if (element.type === 'wallLight' && window.frameCounter % 15 === 0) {
                    // Animation moins fréquente pour les lumières
                    const intensity = 0.5 + Math.sin(performance.now() / 500) * 0.5;
                    if (element.light) {
                        element.light.intensity = intensity;
                    }
                }
            }
            
            // Animation des segments de tunnel (moins fréquente et seulement pour les segments proches)
            if (window.tunnelSegments) {
                for (let i = 0; i < window.tunnelSegments.length; i++) {
                    const segment = window.tunnelSegments[i];
                    if (!segment.mesh) continue;
                    
                    // Calculer la distance
                    const dx = segment.mesh.position.x - window.boat.position.x;
                    const dz = segment.mesh.position.z - window.boat.position.z;
                    const distanceSquared = dx * dx + dz * dz;
                    
                    // Ne traiter que les segments proches
                    if (distanceSquared > maxDistanceSquared) continue;
                    
                    // Animation réduite et moins fréquente
                    if (window.frameCounter % 20 === 0 && segment.lights) {
                        for (let j = 0; j < segment.lights.length; j++) {
                            const light = segment.lights[j];
                            if (light) {
                                // Animation simplifiée
                                const intensity = 0.7 + Math.sin(performance.now() / 1000 + j * 0.5) * 0.3;
                                light.intensity = intensity;
                            }
                        }
                    }
                }
            }
        }

        // Fonction pour vérifier et mettre à jour le tunnel
        function checkTunnel() {
            if (!window.boat || !window.segments || window.segments.length === 0) return;
            
            // Position actuelle du bateau
            const boatZ = window.boat.position.z;
            
            // Dernier segment existant
            const lastSegment = window.segments[window.segments.length - 1];
            
            // Premier segment existant
            const firstSegment = window.segments[0];
            
            // Vérifier si on doit ajouter un nouveau segment (si le bateau s'approche de la fin du tunnel)
            if (boatZ > lastSegment.userData.zPosition - TUNNEL_LENGTH) {
                // Créer un nouveau segment à la fin
                const newSegmentZ = lastSegment.userData.zPosition + TUNNEL_LENGTH;
                createSegment(newSegmentZ);
                
                // Supprimer le premier segment si on a plus de 5 segments (pour économiser les ressources)
                if (window.segments.length > 5) {
                    const oldSegment = window.segments.shift(); // Retirer le premier segment
                    window.scene.remove(oldSegment);
                    
                    // Supprimer les portes associées à ce segment
                    window.doors = window.doors.filter(door => !oldSegment.children.includes(door));
                }
            }
        }
        
        // Ajouter une fonction pour créer et mettre à jour le panneau d'objectifs
        function createObjectivesPanel() {
            // Créer le panneau s'il n'existe pas déjà
            if (!document.getElementById('objectives-panel')) {
                const panel = document.createElement('div');
                panel.id = 'objectives-panel';
                document.body.appendChild(panel);
            }
            
            updateObjectivesPanel();
        }
        
        function updateObjectivesPanel() {
            const panel = document.getElementById('objectives-panel');
            if (!panel) return;
            
            panel.innerHTML = '';
            
            // Ajouter l'objectif principal (jalon actuel)
            if (window.currentMilestoneIndex < STORY_MILESTONES.length) {
                const currentMilestone = STORY_MILESTONES[window.currentMilestoneIndex];
                
                const objective = document.createElement('div');
                objective.className = 'objective';
                
                const icon = document.createElement('span');
                icon.className = 'objective-icon';
                icon.textContent = '🎯';
                
                const text = document.createElement('span');
                text.className = 'objective-text';
                text.textContent = currentMilestone.title;
                
                objective.appendChild(icon);
                objective.appendChild(text);
                panel.appendChild(objective);
            }
            
            // Ajouter des objectifs secondaires si nécessaire
            if (window.activeSecondaryObjectives && window.activeSecondaryObjectives.length > 0) {
                window.activeSecondaryObjectives.forEach(obj => {
                    const objective = document.createElement('div');
                    objective.className = 'objective';
                    
                    const icon = document.createElement('span');
                    icon.className = 'objective-icon';
                    icon.textContent = obj.completed ? '✅' : '⭐';
                    
                    const text = document.createElement('span');
                    text.className = 'objective-text';
                    text.textContent = obj.text;
                    
                    objective.appendChild(icon);
                    objective.appendChild(text);
                    panel.appendChild(objective);
                });
            }
        }
        
        // Surcharger la fonction unlockNextMilestone pour mettre à jour également les objectifs
        const originalUnlockNextMilestone2 = unlockNextMilestone;
        unlockNextMilestone = function(username) {
            originalUnlockNextMilestone2(username);
            updateObjectivesPanel();
            
            // Mettre à jour les fenêtres de détails si elles sont ouvertes
            if (window.detailWindows && window.detailWindows.length > 0) {
                window.sendDataToExplorationDetails();
            }
        };
        
        // Ajouter une fonction pour envoyer les données à la page des détails d'exploration
        window.sendDataToExplorationDetails = function() {
            // Nettoyer les fenêtres fermées
            window.detailWindows = window.detailWindows.filter(w => !w.closed);
            
            // Parcourir les fenêtres encore ouvertes
            window.detailWindows.forEach(detailWindow => {
                try {
                    // Vérifier si la fenêtre est accessible et si la fonction est disponible
                    if (detailWindow && !detailWindow.closed && typeof detailWindow.updateExplorationData === 'function') {
                        const data = {
                            leaderboard: window.leaderboard || [],
                            storyHistory: window.storyHistory || [],
                            discoveredClues: window.discoveredClues || [],
                            totalDonations: window.totalDonations || 0,
                            storyProgress: window.storyProgress || 0,
                            STORY_ELEMENTS: window.STORY_ELEMENTS || { clues: [], mysteries: [] }
                        };
                        detailWindow.updateExplorationData(data);
                        console.log("Données envoyées à la page de détails");
                    }
                } catch (e) {
                    console.error("Erreur lors de l'envoi des données à la fenêtre:", e);
                }
            });
        };
        
        // Vérifier périodiquement les fenêtres de détails
        setInterval(() => {
            if (window.detailWindows && window.detailWindows.length > 0) {
                window.sendDataToExplorationDetails();
            }
        }, 5000); // Toutes les 5 secondes
        
        // Définir une liste d'entités narratives qui peuvent apparaître avec le temps
        const NARRATIVE_ENTITIES = [
            { 
                id: "ancient_guardian", 
                name: "Gardien Ancien", 
                description: "Une silhouette luminescente qui semble observer les explorateurs depuis les profondeurs.",
                minChapter: 2,
                rarity: 0.2,
                onAppear: function() {
                    addToStoryHistory('event', "Un Gardien Ancien est apparu au loin, observant silencieusement.");
                    playAmbientSound('whisper', 0.5);
                }
            },
            { 
                id: "echo_wisp", 
                name: "Écho Lumineux", 
                description: "Une orbe de lumière qui répète les derniers mots prononcés dans le tunnel.",
                minChapter: 1,
                rarity: 0.4,
                onAppear: function() {
                    addToStoryHistory('discovery', "Un Écho Lumineux flotte dans les airs, répétant des fragments de conversation.");
                    createFloatingLight();
                }
            },
            { 
                id: "memory_crystal", 
                name: "Cristal de Mémoire", 
                description: "Un cristal qui contient des fragments de souvenirs d'une civilisation oubliée.",
                minChapter: 3,
                rarity: 0.3,
                onAppear: function() {
                    addToStoryHistory('discovery', "Un Cristal de Mémoire a été découvert, pulsant doucement avec la lumière.");
                    revealRandomClue();
                }
            },
            { 
                id: "shadow_lurker", 
                name: "Rôdeur des Ombres", 
                description: "Une forme sombre qui se déplace furtivement dans les recoins les plus obscurs.",
                minChapter: 4,
                rarity: 0.15,
                onAppear: function() {
                    addToStoryHistory('event', "Un Rôdeur des Ombres a été aperçu brièvement avant de disparaître dans l'obscurité.");
                    flickerLights(0.7);
                }
            },
            { 
                id: "whispering_statue", 
                name: "Statue Murmurante", 
                description: "Une statue ancienne qui murmure des indices au passage des voyageurs.",
                minChapter: 2,
                rarity: 0.25,
                onAppear: function() {
                    addToStoryHistory('discovery', "Une Statue Murmurante a été découverte, révélant des indices dans ses chuchotements.");
                    spawnSpecialEntity(2); // Utiliser un type spécifique pour la statue
                }
            },
            { 
                id: "portal_echo", 
                name: "Écho de Portail", 
                description: "Une déchirure temporelle qui montre des aperçus d'autres réalités.",
                minChapter: 5,
                rarity: 0.1,
                onAppear: function() {
                    addToStoryHistory('event', "Un Écho de Portail s'est ouvert brièvement, révélant une vision troublante d'un autre monde.");
                    triggerSpecialEvent();
                }
            },
            { 
                id: "sentient_water", 
                name: "Eau Consciente", 
                description: "Une portion d'eau qui semble avoir développé une forme de conscience.",
                minChapter: 3,
                rarity: 0.2,
                onAppear: function() {
                    addToStoryHistory('discovery', "L'Eau Consciente s'élève en formes impossibles, comme animée par une volonté propre.");
                    createWaterRipple(0.8);
                }
            }
        ];
        
        // Système de chance basé sur le temps pour faire apparaître des entités narratives
        function setupNarrativeEntitySystem() {
            // Intervalle pour vérifier l'apparition d'entités (toutes les 3-5 minutes)
            const checkInterval = 180000 + Math.random() * 120000;
            
            // Définir l'intervalle
            setInterval(() => {
                // Ne déclencher que si le jeu est actif (pas en pause)
                if (window.isPaused) return;
                
                // Chance basée sur l'activité récente (dons, commentaires)
                let chanceMultiplier = 1.0;
                const recentActivity = window.recentActivityCount || 0;
                
                // Augmenter les chances si l'activité est élevée
                if (recentActivity > 10) {
                    chanceMultiplier = 1.5;
                } else if (recentActivity > 20) {
                    chanceMultiplier = 2.0;
                }
                
                // Calculer la chance de base (10-20%)
                const baseChance = 0.1 + (Math.random() * 0.1);
                const finalChance = baseChance * chanceMultiplier;
                
                // Tenter l'apparition
                if (Math.random() < finalChance) {
                    spawnRandomNarrativeEntity();
                }
            }, checkInterval);
            
            // Initialiser le compteur d'activité récente
            window.recentActivityCount = 0;
            
            // Réinitialiser le compteur toutes les 15 minutes
            setInterval(() => {
                window.recentActivityCount = 0;
            }, 900000);
            
            // Fonction pour incrémenter l'activité
            window.incrementRecentActivity = function() {
                window.recentActivityCount = (window.recentActivityCount || 0) + 1;
            };
            
            console.log("Système d'entités narratives initialisé");
        }
        
        // Faire apparaître une entité narrative aléatoire appropriée au chapitre actuel
        function spawnRandomNarrativeEntity() {
            // Déterminer le chapitre actuel
            const currentChapter = window.currentChapter || 1;
            
            // Filtrer les entités disponibles pour ce chapitre
            const availableEntities = NARRATIVE_ENTITIES.filter(entity => 
                entity.minChapter <= currentChapter
            );
            
            if (availableEntities.length === 0) return;
            
            // Sélection pondérée par rareté
            // Les entités plus rares ont moins de chances d'apparaître
            availableEntities.sort(() => Math.random() - 0.5); // Mélanger d'abord
            
            let totalWeight = 0;
            const weightedEntities = availableEntities.map(entity => {
                // Inverser la rareté pour en faire un poids (plus rare = moins de poids)
                const weight = 1 - entity.rarity;
                totalWeight += weight;
                return {
                    entity,
                    weight
                };
            });
            
            // Sélectionner une entité selon le poids
            let random = Math.random() * totalWeight;
            let selectedEntity = null;
            
            for (const item of weightedEntities) {
                random -= item.weight;
                if (random <= 0) {
                    selectedEntity = item.entity;
                    break;
                }
            }
            
            // Si aucune entité n'a été sélectionnée (ne devrait pas arriver), prendre la première
            if (!selectedEntity && weightedEntities.length > 0) {
                selectedEntity = weightedEntities[0].entity;
            }
            
            // Faire apparaître l'entité
            if (selectedEntity) {
                console.log(`Entité narrative apparue: ${selectedEntity.name}`);
                
                // Déclencher l'effet d'apparition
                selectedEntity.onAppear();
                
                // Ajouter à l'historique global
                if (!window.encounteredEntities) {
                    window.encounteredEntities = [];
                }
                
                // Vérifier si cette entité a déjà été rencontrée
                const alreadyEncountered = window.encounteredEntities.some(e => e.id === selectedEntity.id);
                
                if (!alreadyEncountered) {
                    // Première apparition - ajouter aux entités rencontrées
                    window.encounteredEntities.push({
                        id: selectedEntity.id,
                        firstEncountered: new Date().toISOString(),
                        encounterCount: 1
                    });
                    
                    // Afficher une notification pour la première rencontre
                    showEntityDiscoveryNotification(selectedEntity);
                } else {
                    // Incrémenter le compteur pour cette entité
                    const entity = window.encounteredEntities.find(e => e.id === selectedEntity.id);
                    entity.encounterCount++;
                    entity.lastEncountered = new Date().toISOString();
                }
            }
        }
        
        // Afficher une notification pour la découverte d'une nouvelle entité
        function showEntityDiscoveryNotification(entity) {
            // Créer une notification similaire à celle des indices
            const notification = document.createElement('div');
            notification.id = 'entity-notification';
            notification.style.cssText = `
                position: fixed;
                top: 20%;
                left: 50%;
                transform: translateX(-50%);
                background-color: rgba(0, 0, 0, 0.8);
                color: #fff;
                padding: 15px 20px;
                border-radius: 8px;
                z-index: 1000;
                text-align: center;
                box-shadow: 0 0 20px rgba(255, 204, 0, 0.5);
                opacity: 0;
                transition: opacity 1s;
                max-width: 80%;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 18px; color: #ffcc00; margin-bottom: 8px;">
                    Nouvelle entité découverte: ${entity.name}
                </div>
                <div style="color: #ccc; font-size: 14px;">
                    ${entity.description}
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Animer l'apparition
            setTimeout(() => {
                notification.style.opacity = '1';
            }, 100);
            
            // Disparition après 6 secondes
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => {
                    notification.remove();
                }, 1000);
            }, 6000);
        }
        
        // Créer une lumière flottante (pour l'entité Écho Lumineux)
        function createFloatingLight() {
            // Créer un groupe pour la lumière
            const lightGroup = new THREE.Group();
            
            // Position aléatoire dans le tunnel, mais visible depuis le bateau
            const boat = window.boat;
            if (!boat) return;
            
            // Définir une position aléatoire devant le bateau
            const randomAngle = Math.random() * Math.PI * 2;
            const randomRadius = 2 + Math.random() * 3;
            const randomHeight = -1 + Math.random() * 2;
            
            const x = boat.position.x + Math.cos(randomAngle) * randomRadius;
            const y = randomHeight;
            const z = boat.position.z + Math.sin(randomAngle) * randomRadius + 5; // Toujours un peu devant
            
            // Positionner le groupe
            lightGroup.position.set(x, y, z);
            
            // Créer une sphère lumineuse
            const sphereGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const sphereMaterial = new THREE.MeshBasicMaterial({
                color: 0x77ccff,
                transparent: true,
                opacity: 0.7
            });
            
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            lightGroup.add(sphere);
            
            // Ajouter une lumière ponctuelle
            const light = new THREE.PointLight(0x77ccff, 2, 5);
            light.position.set(0, 0, 0);
            lightGroup.add(light);
            
            // Ajouter au groupe des entités spéciales
            window.scene.add(lightGroup);
            
            // Stocker une référence
            if (!window.specialEntities) {
                window.specialEntities = [];
            }
            window.specialEntities.push(lightGroup);
            
            // Animation de flottement
            const startTime = Date.now();
            const duration = 10000 + Math.random() * 5000; // 10-15 secondes
            
            function animateFloatingLight() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;
                
                if (progress >= 1) {
                    // Supprimer la lumière après la durée
                    window.scene.remove(lightGroup);
                    window.specialEntities = window.specialEntities.filter(e => e !== lightGroup);
                    return;
                }
                
                // Animation de flottement
                const floatY = Math.sin(elapsed * 0.003) * 0.2;
                const floatX = Math.sin(elapsed * 0.002) * 0.1;
                const floatZ = Math.cos(elapsed * 0.002) * 0.1;
                
                lightGroup.position.y = y + floatY;
                lightGroup.position.x = x + floatX;
                lightGroup.position.z = z + floatZ;
                
                // Faire pulser la lumière
                const pulseScale = 0.8 + Math.sin(elapsed * 0.006) * 0.2;
                sphere.scale.set(pulseScale, pulseScale, pulseScale);
                
                // Faire varier l'intensité de la lumière
                light.intensity = 1.5 + Math.sin(elapsed * 0.006) * 0.5;
                
                // Continuer l'animation
                requestAnimationFrame(animateFloatingLight);
            }
            
            // Démarrer l'animation
            animateFloatingLight();
        }
        
        // Initialiser le système d'entités narratives au chargement
        function initGameSystems() {
            // Initialiser les systèmes existants
            
            // Ajouter le système d'entités narratives
            setupNarrativeEntitySystem();
            
            console.log('Tous les systèmes de jeu ont été initialisés');
        }
        
        // Ajouter à la fonction init
        const originalInit = init;
        init = function() {
            // Appeler la fonction init originale
            originalInit();
            
            // Initialiser nos systèmes de jeu étendus
            initGameSystems();
        };
        
        // Configuration du système de vote
    </script>

    <div id="leaderboard-panel">
        <h3>Classement des Explorateurs</h3>
        <div id="leaderboard-list">
            <!-- Le classement sera ajouté ici dynamiquement -->
                        </div>
                        </div>
                        
    <div id="story-history-panel">
        <h3>Journal des Messages</h3>
        <div id="story-history-list">
            <!-- L'historique sera ajouté ici dynamiquement -->
                        </div>
                        </div>
                        
    <!-- Espace réservé pour la future implémentation de la caméra -->
    <div class="camera-space"></div>
</html>
    <!-- Socket.IO client library -->
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <!-- Script de correctifs --> 
    <script src="fixes.js"></script> 
    <!-- Script de correctifs --> 
    <script src="fixes.js"></script> 

        <script>
        // Code d'injection automatique pour corriger les problèmes
        console.log('🔧 Injection de corrections automatiques...');
        
        // Correction des thresholds
        window.THRESHOLDS_FIX = {
            tiers: [
                { name: "Tier 1", threshold: 20, activated: false },
                { name: "Tier 2", threshold: 50, activated: false },
                { name: "Tier 3", threshold: 100, activated: false }
            ],
            currentTier: 0,
            requiredAmount: 20
        };
        
        // Redéfinir la fonction de vérification des thresholds
        function checkThresholds(amount) {
            // Utiliser nos thresholds de secours si nécessaire
            const thresholds = window.sharedData?.thresholds || window.THRESHOLDS_FIX;
            console.log('🔍 Vérification des seuils avec montant:', amount);
            
            if (thresholds) {
                // Vérifier si un palier est atteint
                for (let i = 0; i < thresholds.tiers.length; i++) {
                    const tier = thresholds.tiers[i];
                    if (!tier.activated && amount >= tier.threshold) {
                        console.log('🎉 Palier atteint:', tier.name);
                        tier.activated = true;
                        thresholds.currentTier = i;
                        return true;
                    }
                }
            } else {
                console.warn('⚠️ Aucun threshold disponible');
            }
            return false;
        }
        
        // Redéfinir la fonction de simulation de don pour utiliser notre checkThresholds
        window.originalSimulateDonation = window.simulateDonation;
        window.simulateDonation = function(event) {
            try {
                const amount = parseInt(document.getElementById('donation-amount').value) || 20;
                const username = document.getElementById('donation-username').value || 'Anonyme';
                
                console.log('💰 Simulation de don:', amount, 'de', username);
                
                // Utiliser notre version de checkThresholds
                checkThresholds(amount);
                
                // Mettre à jour les données partagées
                if (window.sharedData) {
                    if (!window.sharedData.thresholds) {
                        window.sharedData.thresholds = window.THRESHOLDS_FIX;
                    }
                } else {
                    window.sharedData = { thresholds: window.THRESHOLDS_FIX };
                }
                
                // Envoyer l'événement via le serveur central
                if (window.centralSocket && window.centralSocket.connected) {
                    window.centralSocket.emit('simulateDonation', {
                        username: username,
                        amount: amount,
                        message: ''
                    });
                }
                
                // Mettre à jour la jauge manuellement
                if (window.updateAuthGauge) {
                    window.updateAuthGauge(amount);
                }
                
                // Ajouter à l'historique
                if (window.addEventToHistory) {
                    window.addEventToHistory({
                        type: 'donation',
                        username: username,
                        amount: amount,
                        message: ''
                    });
                }
                
                console.log('✅ Don simulé avec succès');
            } catch (error) {
                console.error('❌ Erreur lors de la simulation de don:', error);
            }
        };
        
        // Corriger la connexion socket
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🔌 Configuration des connexions socket alternatives...');
            
            // Connexion au serveur central
            try {
                window.centralSocket = io('http://localhost:3333');
                
                window.centralSocket.on('connect', function() {
                    console.log('✅ Connecté au serveur central sur le port 3333');
                    
                    // S'enregistrer comme client Sethos
                    window.centralSocket.emit('register_client', { type: 'sethos' });
                    
                    // Recevoir les mises à jour du système
                    window.centralSocket.on('system_state', function(data) {
                        console.log('📊 État du système reçu:', data);
                        
                        // Mettre à jour les données partagées
                        window.sharedData = data;
                        
                        // Mettre à jour la progression si disponible
                        if (data.auth && data.auth.progress && window.updateAuthGauge) {
                            window.updateAuthGauge(0, null, data.auth.progress);
                        }
                        
                        // Mettre à jour les thresholds
                        if (data.thresholds) {
                            window.THRESHOLDS_FIX = data.thresholds;
                        }
                    });
                    
                    // Recevoir les événements (donations, etc.)
                    window.centralSocket.on('event', function(data) {
                        console.log('📩 Événement reçu:', data);
                        
                        if (data.type === 'donation') {
                            // Mettre à jour la jauge d'authentification
                            if (window.updateAuthGauge) {
                                window.updateAuthGauge(data.amount, data.username);
                            }
                            
                            // Mettre à jour la liste des événements
                            addEventToHistory(data);
                        }
                    });
                    
                    // Recevoir les événements d'histoire
                    window.centralSocket.on('story_update', function(eventData) {
                        console.log('📖 Événement d\'histoire reçu:', eventData);
                        
                        // Traiter l'événement d'histoire
                        if (window.triggerEvent) {
                            window.triggerEvent(eventData);
                        } else {
                            console.warn('⚠️ La fonction triggerEvent n\'est pas disponible');
                        }
                        
                        // Ajouter à l'historique
                        addEventToHistory({
                            type: 'story_event',
                            username: 'Système',
                            message: `Événement: ${eventData.type || eventData.name || 'inconnu'}`
                        });
                    });
                });
            } catch (e) {
                console.error('❌ Erreur lors de la connexion au serveur central:', e);
            }
            
            // Fonction pour ajouter un événement à l'historique
            window.addEventToHistory = function(event) {
                const historyList = document.getElementById('story-history-list');
                if (!historyList) return;
                
                const eventItem = document.createElement('div');
                eventItem.className = 'history-item';
                
                if (event.type === 'donation') {
                    eventItem.innerHTML = `<strong>${event.username}</strong>: ${event.amount}€ - ${event.message || ''}`;
                } else {
                    eventItem.innerHTML = `<strong>${event.username || 'Système'}</strong>: ${event.type}`;
                }
                
                historyList.appendChild(eventItem);
                historyList.scrollTop = historyList.scrollHeight;
            };
            
            // Fonction pour traiter les événements reçus
            window.triggerEvent = function(eventData) {
                console.log('🎬 Traitement de l\'événement:', eventData);
                
                try {
                    // Afficher l'événement dans le journal d'exploration
                    const eventName = eventData.name || eventData.type || 'Événement inconnu';
                    
                    // Si c'est une séquence, traiter chaque action
                    if (eventData.type === 'sequence' && eventData.sequence && Array.isArray(eventData.sequence)) {
                        console.log(`🔄 Exécution d'une séquence de ${eventData.sequence.length} actions`);
                        
                        // Traiter chaque action de la séquence avec un délai
                        eventData.sequence.forEach((action, index) => {
                            setTimeout(() => {
                                console.log(`🔄 Action séquence #${index+1}:`, action);
                                processAction(action);
                            }, index * 1000); // Délai de 1 seconde entre chaque action
                        });
                    } else {
                        // Traiter l'événement directement s'il n'est pas une séquence
                        processAction(eventData);
                    }
                    
                    // Mise à jour du statut narratif si applicable
                    updateNarrativeStatus(eventData);
                    
                } catch (error) {
                    console.error('❌ Erreur lors du traitement de l\'événement:', error);
                }
            };
            
            // Fonction interne pour traiter une action individuelle
            function processAction(action) {
                // Traiter différents types d'actions
                switch (action.type) {
                    case 'message':
                        // Afficher un message à l'écran
                        displayMessage(
                            action.parameters?.text || "Message système", 
                            action.duration || 5,
                            action.parameters?.color || "#FFFFFF"
                        );
                        break;
                        
                    case 'sound':
                        // Jouer un son
                        playSound(
                            action.parameters?.soundName, 
                            action.parameters?.volume || 0.5, 
                            action.parameters?.loop || false
                        );
                        break;
                        
                    case 'light':
                        // Effet de lumière
                        if (action.parameters?.color) {
                            applyLightEffect(
                                action.parameters.color, 
                                action.parameters?.pattern || 'solid', 
                                action.duration || 3
                            );
                        }
                        break;
                        
                    case 'image':
                        // Afficher une image
                        if (action.parameters?.file) {
                            displayImage(
                                action.parameters.file, 
                                action.parameters?.position || 'center', 
                                action.duration || 10
                            );
                        }
                        break;
                        
                    case 'boat':
                        // Contrôler le bateau
                        if (action.parameters?.action) {
                            controlBoat(
                                action.parameters.action, 
                                action.parameters?.speed || 'normal'
                            );
                        }
                        break;
                        
                    case 'door':
                        // Contrôler une porte
                        if (action.parameters?.doorId && action.parameters?.action) {
                            controlDoor(
                                action.parameters.doorId, 
                                action.parameters.action
                            );
                        }
                        break;
                        
                    default:
                        console.log(`⚠️ Type d'action non géré: ${action.type}`);
                }
            }
            
            // Fonctions auxiliaires pour les événements
            function displayMessage(text, duration, color) {
                const narrativeDisplay = document.getElementById('narrative-display');
                if (!narrativeDisplay) return;
                
                narrativeDisplay.textContent = text;
                narrativeDisplay.style.color = color || '#FFFFFF';
                narrativeDisplay.style.opacity = '1';
                
                // Masquer après une durée spécifiée
                setTimeout(() => {
                    narrativeDisplay.style.opacity = '0';
                }, duration * 1000);
                
                console.log(`💬 Message affiché: "${text}" (${duration}s)`);
            }
            
            function playSound(soundName, volume, loop) {
                console.log(`🔊 Son joué: ${soundName}, Volume: ${volume}, Loop: ${loop}`);
                // Implémenter la lecture du son ici
            }
            
            function applyLightEffect(color, pattern, duration) {
                console.log(`💡 Effet de lumière: ${color}, Modèle: ${pattern}, Durée: ${duration}s`);
                // Implémenter l'effet lumineux ici
            }
            
            function displayImage(file, position, duration) {
                console.log(`🖼️ Image affichée: ${file}, Position: ${position}, Durée: ${duration}s`);
                // Implémenter l'affichage d'image ici
            }
            
            function controlBoat(action, speed) {
                console.log(`⛵ Contrôle du bateau: ${action}, Vitesse: ${speed}`);
                // Implémenter le contrôle du bateau ici
            }
            
            function controlDoor(doorId, action) {
                console.log(`🚪 Contrôle de la porte ${doorId}: ${action}`);
                // Implémenter le contrôle de la porte ici
            }
            
            function updateNarrativeStatus(eventData) {
                // Mise à jour du statut narratif en fonction de l'événement
                const milestone = document.getElementById('story-milestone');
                if (milestone && eventData.name) {
                    milestone.textContent = eventData.name;
                    milestone.style.display = 'block';
                    
                    // Masquer après 5 secondes
                    setTimeout(() => {
                        milestone.style.display = 'none';
                    }, 5000);
                }
            }
            
            // Réinitialiser le socket TikTok toutes les 5 secondes s'il n'est pas connecté
            window.tikTokReconnectInterval = setInterval(function() {
                if (!window.tiktokSocket || !window.tiktokSocket.connected) {
                    console.log('🔄 Tentative de reconnexion au serveur TikTok...');
                    try {
                        window.tiktokSocket = io('http://localhost:8092');
                        
                        window.tiktokSocket.on('connect', function() {
                            console.log('✅ Connecté au serveur TikTok');
                        });
                        
                        window.tiktokSocket.on('tiktokEvent', function(data) {
                            console.log('📨 Événement TikTok reçu:', data);
                            if (data.type === 'donation') {
                                // Simuler un don reçu
                                if (window.updateAuthGauge) {
                                    window.updateAuthGauge(data.amount || 10, data.username);
                                }
                            }
                        });
                    } catch (e) {
                        console.error('❌ Erreur lors de la reconnexion TikTok:', e);
                    }
                }
            }, 5000);
        });
        </script>
        
</body> 

