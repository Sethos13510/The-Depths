<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TikTok Horror Experience - Saison 1: Les Profondeurs</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
        
        #loading { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: #000; 
            color: #fff; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            z-index: 1000;
        }
        
        #debug {
            position: fixed; 
            top: 10px; 
            left: 10px; 
            z-index: 10;
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px;
            border-radius: 5px;
        }
        
        #donation-panel {
            position: fixed;
            right: 10px;
            top: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 180px;
            font-size: 11px;
        }
        
        #donation-panel h3 {
            margin-top: 0;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 40px; /* Déplacé plus bas pour éviter le chevauchement */
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            max-width: 400px;
            z-index: 900;
        }
        
        .progress-bar {
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            margin-bottom: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9900);
            width: 0%;
            transition: width 1s ease-in-out;
        }
        
        #story-milestone {
            position: fixed;
            top: 80px; /* Déplacé encore plus bas */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 12px;
            z-index: 900;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
            padding: 5px 10px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            width: 40%;
            max-width: 400px;
            line-height: 1.3;
            display: none; /* Caché par défaut, sera affiché dans le journal uniquement */
        }
        
        #donor-wall {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Aligné avec le journal d'exploration */
            max-height: 130px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #donor-wall h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 13px;
            text-align: center;
        }
        
        .donor {
            padding: 2px 4px;
            margin: 1px 0;
            border-radius: 3px;
            font-size: 10px;
        }
        
        .donor-legendary {
            background: linear-gradient(90deg, rgba(255,0,0,0.2), rgba(255,215,0,0.2));
            border-left: 2px solid gold;
        }
        
        .donor-epic {
            background: rgba(148,0,211,0.2);
            border-left: 2px solid purple;
        }
        
        .donor-rare {
            background: rgba(30,144,255,0.2);
            border-left: 2px solid blue;
        }
        
        .donor-common {
            background: rgba(100,100,100,0.2);
            border-left: 2px solid gray;
        }
        
        #narrative-display {
            position: fixed;
            top: 50%; /* Centré verticalement */
            left: 50%;
            transform: translate(-50%, -50%); /* Centrage parfait */
            z-index: 950;
            color: white;
            text-align: center;
            width: 70%;
            max-width: 600px;
            text-shadow: 0 0 3px black, 0 0 5px black;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Fond plus opaque pour meilleure lisibilité */
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none; /* Pour éviter d'interférer avec les clics */
        }
        
        #narrative-display.visible {
            opacity: 0.95;
        }
        
        #clue-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 950;
            color: #ffcc00;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 3px solid #ffcc00;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease-out;
        }
        
        #clue-notification.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #event-counter {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            color: white;
            font-size: 120px;
            text-shadow: 0 0 20px red;
            opacity: 0;
            transition: all 0.3s ease-in-out;
            pointer-events: none;
        }
        
        #event-counter.visible {
            opacity: 1;
        }
        
        button, input { 
            margin: 5px 0; 
            display: block;
            border: none;
            background: #444;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #666;
        }
        
        #sim-donation {
            margin-top: 15px;
            width: 100%;
        }
        
        #vote-panel {
            position: fixed;
            right: 10px;
            bottom: 10px; /* En bas à droite */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 160px;
            font-size: 10px;
            display: none;
        }
        
        .vote-option {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .vote-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .vote-bar {
            height: 5px;
            width: 100%;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .vote-fill {
            height: 100%;
            background: linear-gradient(90deg, #77ccff, #4488ff);
            width: 30%;
        }
        
        /* Animation pour les effects */
        @keyframes pulse {
            0% { opacity: 0.2; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.2; transform: scale(0.95); }
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        #leaderboard-panel {
            position: fixed;
            left: 10px;
            top: 120px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 160px;
            max-height: 160px;
            overflow-y: auto;
            font-size: 10px;
            display: none;
        }
        
        #leaderboard-panel h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #aaa;
            width: 20px;
            text-align: center;
        }
        
        .leaderboard-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .leaderboard-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #story-history-panel {
            position: fixed;
            left: 10px;
            bottom: 150px; /* Ajuste pour laisser un peu plus d'espace */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Élargi pour mieux afficher les messages */
            max-height: 200px; /* Plus grand pour afficher plus de messages */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #story-history-panel h3 {
            margin-top: 0;
            margin-bottom: 3px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .history-item {
            margin-bottom: 4px;
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .history-item-milestone {
            background-color: rgba(255, 204, 0, 0.2);
            border-left: 2px solid #ffcc00;
        }
        
        .history-item-discovery {
            background-color: rgba(119, 204, 255, 0.2);
            border-left: 2px solid #77ccff;
        }
        
        .history-item-event {
            background-color: rgba(255, 102, 102, 0.2);
            border-left: 2px solid #ff6666;
        }
        
        .history-timestamp {
            color: #aaa;
            font-size: 8px;
            margin-bottom: 2px;
            font-style: italic;
        }
        
        /* Style pour réserver l'espace pour la caméra */
        .camera-space {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 100px;
            z-index: 800;
            /* Background commenté - juste pour visualiser l'espace réservé 
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            */
        }
        
        /* Assurons-nous que tous les panneaux ont une apparence cohérente */
        #leaderboard-panel, #story-history-panel, #donation-panel, #vote-panel, #donor-wall {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.85; /* Légèrement transparent pour voir le bateau derrière */
        }
        
        /* 
        Organisation des panneaux :
        - Haut gauche : Espace pour la caméra (vide)
        - Milieu gauche : Classement des explorateurs
        - En bas : Journal d'exploration (suivi de)
        - En bas : Mur des contributeurs récents
        - En haut droite : Panneau de donation
        - En bas droite : Panneau de vote
        - Centre haut (ajusté) : Barre de progression et jalon
        - Centre bas : Affichage narratif
        */
        
        /* Hover effect pour rendre les panneaux plus lisibles au survol */
        #leaderboard-panel:hover, #story-history-panel:hover, #donation-panel:hover, #vote-panel:hover, #donor-wall:hover {
            opacity: 0.95;
            z-index: 950; /* Augmente le z-index au survol pour s'assurer qu'il est au-dessus des autres */
        }
        
        /* Style pour les titres des panneaux */
        #leaderboard-panel h3, #story-history-panel h3, #donor-wall h4 {
            color: #ffcc00;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="loading">
        <h1>INITIALISATION...</h1>
        <p>Connexion aux Profondeurs...</p>
        <div class="progress-bar" style="width: 300px;">
            <div class="progress-fill" id="load-progress" style="width: 5%;"></div>
        </div>
    </div>
    
    <div id="progress-display">
        <div style="display: flex; justify-content: space-between;">
            <span>PROGRESSION: </span>
            <span id="progress-percent">0%</span>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="story-progress"></div>
        </div>
        <div style="display: flex; justify-content: space-between;">
            <span>DÉBUT</span>
            <span>FIN</span>
        </div>
    </div>
    
    <div id="debug" style="display: none;">
        <h3>Contrôles Debug</h3>
        <button id="giftBtn">Simuler cadeau</button>
        <input id="commentInput" type="text" placeholder="Commentaire">
        <button id="commentBtn">Envoyer</button>
        <button id="likeBtn">Simuler likes</button>
        <button id="toggle-debug">Afficher contrôles avancés</button>
        <div id="advanced-debug" style="display: none; margin-top: 10px;">
            <button id="debug-milestone">Débloquer milestone</button>
            <button id="debug-entity">Invoquer entité</button>
            <button id="debug-clue">Révéler indice</button>
            <button id="debug-event">Déclencher événement</button>
            <button id="debug-vote">Lancer vote</button>
        </div>
    </div>
    
    <div id="donation-panel">
        <h3 style="margin-top: 0; text-align: center;">Les Profondeurs</h3>
        <button id="open-donation-simulator" style="width:100%; margin-bottom:5px; font-size:10px; padding:4px;">
            Ouvrir le Simulateur de Dons
        </button>
        <div style="font-size:9px; margin-bottom:5px; text-align:center;">
            Pour simuler un don, utilisez le simulateur
        </div>
        <div style="display: flex; justify-content: space-between;">
            <span>Progression narrative:</span>
            <span id="progress-percent">0%</span>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="story-progress"></div>
        </div>
        <div style="display: flex; justify-content: space-between;">
            <span>Prochain palier:</span>
            <span id="next-milestone-amount">500 €</span>
        </div>
        <div id="story-milestone">
            "Le passage vers le secteur 2 semble bloqué. Une intervention externe est nécessaire pour rétablir l'accès..."
        </div>
        <div style="margin-top: 15px;">
            <div style="display: flex; justify-content: space-between;">
                <span>Total des dons:</span>
                <span id="total-donations">0 €</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
                <span>Mystères résolus:</span>
                <span id="solved-mysteries">0/13</span>
            </div>
        </div>
    </div>
    
    <div id="donor-wall">
        <h4 style="margin-top: 0;">Contributeurs Récents</h4>
        <div id="donor-list">
            <!-- Les donateurs seront ajoutés ici dynamiquement -->
        </div>
    </div>
    
    <div id="narrative-display"></div>
    
    <div id="clue-notification">Indice trouvé: Enigme #172</div>
    
    <div id="event-counter"></div>
    
    <div id="vote-panel">
        <h4 style="margin-top: 0;">Vote Communautaire</h4>
        <p id="vote-question">Quelle porte le voyageur devrait-il ouvrir ensuite?</p>
        <div class="vote-option" data-option="1">
            <div style="display: flex; justify-content: space-between;">
                <span>Porte avec symbole spirale</span>
                <span>30%</span>
            </div>
            <div class="vote-bar">
                <div class="vote-fill" style="width: 30%"></div>
            </div>
        </div>
        <div class="vote-option" data-option="2">
            <div style="display: flex; justify-content: space-between;">
                <span>Porte rouge clignotante</span>
                <span>45%</span>
            </div>
            <div class="vote-bar">
                <div class="vote-fill" style="width: 45%"></div>
            </div>
        </div>
        <div class="vote-option" data-option="3">
            <div style="display: flex; justify-content: space-between;">
                <span>Porte avec marques de griffes</span>
                <span>25%</span>
            </div>
            <div class="vote-bar">
                <div class="vote-fill" style="width: 25%"></div>
            </div>
        </div>
        <p style="font-size: 12px; text-align: center; margin-top: 10px;">Les dons comptent comme des votes. Fin dans <span id="vote-timer">02:45</span></p>
    </div>

    <!-- Charger Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Définir les variables globales
        window.scene = null;
        window.camera = null;
        window.renderer = null;
        window.boat = null;
        window.doors = [];
        window.segments = [];
        window.boatSpeed = 0.05;
        window.moveDirection = { x: 0, z: 1 };
        
        // Variables pour le système de narration et de dons
        window.totalDonations = 0;
        window.currentSeason = 1;
        window.currentEpisode = 1;
        window.currentMilestoneIndex = 0;
        window.storyProgress = 0;
        window.mysteryElements = {};
        window.discoveredClues = [];
        window.solvedMysteries = 0;
        window.activatedDoors = 0;
        window.specialDoors = {};
        window.activeVote = null;
        
        // Constantes
        const TUNNEL_RADIUS = 5;
        const TUNNEL_LENGTH = 20;
        const WATER_LEVEL = -2;
        
        // Définition des paliers de donation pour le progrès narratif
        const STORY_MILESTONES = [
            { amount: 100, title: "Prologue: L'entrée", description: "Les premières portes commencent à révéler d'étranges phénomènes...", unlocksFunction: unlockPrologue },
            { amount: 500, title: "Secteur 2: Murmures", description: "Des voix lointaines résonnent dans l'eau. Elles semblent raconter des fragments d'histoires...", unlocksFunction: unlockSector2 },
            { amount: 1500, title: "Secteur 3: Mémoires", description: "Des symboles apparaissent sur certaines portes. Ils semblent former un code à déchiffrer...", unlocksFunction: unlockSector3 },
            { amount: 3000, title: "Secteur 4: Résonance", description: "L'eau commence à vibrer à intervalles réguliers. Une présence se fait sentir dans les profondeurs...", unlocksFunction: unlockSector4 },
            { amount: 5000, title: "Confrontation Mineure: L'Observateur", description: "Une entité mystérieuse semble suivre le bateau. Ses intentions sont inconnues...", unlocksFunction: unlockMinorEntity },
            { amount: 8000, title: "Secteur 5: Distorsion", description: "La réalité semble se plier. Certaines portes mènent à des lieux impossibles...", unlocksFunction: unlockSector5 },
            { amount: 12000, title: "Secteur 6: Convergence", description: "Les indices commencent à converger. Un schéma plus large se dessine...", unlocksFunction: unlockSector6 },
            { amount: 18000, title: "Confrontation Majeure: Le Gardien", description: "Une présence ancienne bloque le chemin. Elle doit être confrontée pour continuer...", unlocksFunction: unlockMajorEntity },
            { amount: 25000, title: "Secteur 7: Vérité", description: "Les derniers fragments du mystère se dévoilent. La vérité est presque à portée...", unlocksFunction: unlockSector7 },
            { amount: 35000, title: "Finale: Révélation", description: "Le mystère final des Profondeurs est sur le point d'être révélé...", unlocksFunction: unlockFinale }
        ];
        
        // Définition des niveaux de donateurs
        const DONOR_TIERS = [
            { min: 1, max: 49, name: "Explorateur", class: "donor-common" },
            { min: 50, max: 199, name: "Chercheur", class: "donor-rare" },
            { min: 200, max: 999, name: "Éclaireur", class: "donor-epic" },
            { min: 1000, max: Infinity, name: "Illuminé", class: "donor-legendary" }
        ];
        
        // Base de données des éléments narratifs
        const STORY_ELEMENTS = {
            clues: [
                { id: "C001", text: "Numéro gravé: 7-3-9-4-2", category: "sequence", linkedMystery: "M003" },
                { id: "C002", text: "Inscription: 'Le cercle s'élargit mais revient toujours au centre'", category: "phrase", linkedMystery: "M001" },
                { id: "C003", text: "Symbole récurrent: œil traversé par une ligne verticale", category: "symbol", linkedMystery: "M002" },
                { id: "C004", text: "Date répétitive: 22.07.1976", category: "date", linkedMystery: "M005" },
                { id: "C005", text: "Coordonnées fragmentées: 47°N 13...", category: "location", linkedMystery: "M004" },
                { id: "C006", text: "Mot inversé: RUEGREMBUS", category: "word", linkedMystery: "M002" },
                { id: "C007", text: "Schéma circulaire avec 9 points", category: "pattern", linkedMystery: "M001" },
                { id: "C008", text: "Référence: 'Projet Abyssus'", category: "name", linkedMystery: "M007" },
                { id: "C009", text: "Équation: 2x² + 3x - √(4) = 0", category: "math", linkedMystery: "M003" },
                { id: "C010", text: "Fragment audio: voix distordue répétant 'le sixième cycle'", category: "audio", linkedMystery: "M006" },
                { id: "C011", text: "Phrase codée: VGSPJVYMREGIVPIVW", category: "cipher", linkedMystery: "M005" },
                { id: "C012", text: "Motif de lumières: court-court-long-long-court", category: "pattern", linkedMystery: "M004" }
            ],
            mysteries: [
                { id: "M001", title: "Le Motif Circulaire", requiredClues: ["C002", "C007"], solved: false, reward: "Révèle l'origine du tunnel" },
                { id: "M002", title: "L'Entité Observatrice", requiredClues: ["C003", "C006"], solved: false, reward: "Débloque une porte spéciale" },
                { id: "M003", title: "La Séquence Mathématique", requiredClues: ["C001", "C009"], solved: false, reward: "Permet de prévoir certains événements" },
                { id: "M004", title: "Les Signaux", requiredClues: ["C005", "C012"], solved: false, reward: "Révèle un mode de communication" },
                { id: "M005", title: "L'Incident Initial", requiredClues: ["C004", "C011"], solved: false, reward: "Explique pourquoi le tunnel existe" },
                { id: "M006", title: "Les Cycles Temporels", requiredClues: ["C010"], solved: false, reward: "Débloque une vision du passé/futur" },
                { id: "M007", title: "Les Origines du Projet", requiredClues: ["C008"], solved: false, reward: "Révèle qui a créé cette expérience" }
            ],
            narrativeFragments: [
                "Les enregistrements indiquent que le projet a été abandonné suite à une 'contamination'.",
                "Le tunnel n'a pas été construit. Il est apparu spontanément le 22 juillet 1976.",
                "Certains chercheurs affirment avoir vu leur propre reflet vieilli de plusieurs décennies.",
                "L'eau n'est pas réellement de l'eau. Sa composition moléculaire est inconnue.",
                "Les portes apparaissaient et disparaissaient même avant notre arrivée.",
                "Les tests ont révélé que le temps s'écoule différemment à diverses profondeurs.",
                "Équipe d'exploration #7: 4 entrés, 5 revenus. Anomalie consignée.",
                "Les manifestations semblent réagir aux émotions collectives des observateurs.",
                "Théorie: nous ne sommes pas dans un lieu physique mais dans une projection mentale collective.",
                "Le sixième cycle s'achèvera quand le témoin final comprendra sa fonction."
            ]
        };
        
        // ==========================================
        // FONCTIONS D'INITIALISATION
        // ==========================================
        
        // Gestion du redimensionnement de la fenêtre
        function onWindowResize() {
            // Mettre à jour la caméra
            window.camera.aspect = window.innerWidth / window.innerHeight;
            window.camera.updateProjectionMatrix();
            
            // Mettre à jour le renderer
            window.renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Initialisation de l'application
        function init() {
            // Créer la scène
            window.scene = new THREE.Scene();
            window.scene.background = new THREE.Color(0x000000);
            
            // Créer la caméra
            window.camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 100
            );
            window.camera.position.set(0, 1, -5);
            
            // Créer le renderer
            window.renderer = new THREE.WebGLRenderer({ antialias: false });
            window.renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(window.renderer.domElement);
            
            // Ajouter une lumière ambiante
            const light = new THREE.AmbientLight(0x444444);
            window.scene.add(light);
            
            // Effet de brouillard pour l'atmosphère
            window.scene.fog = new THREE.FogExp2(0x000000, 0.035);
            
            // Créer le bateau
            window.boat = createBoat();
            
            // Créer le tunnel initial
            for (let i = 0; i < 3; i++) {
                createSegment(i * TUNNEL_LENGTH);
            }
            
            // Gérer le redimensionnement
            window.addEventListener('resize', onWindowResize);
            
            // Configurer le debug et les contrôles de simulation
            setupDebug();
            setupDonationSystem();
            setupVoteSystem();
            
            // Masquer l'écran de chargement
            const loadingScreen = document.getElementById('loading');
            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 500);
            }, 2000);
            
            // Afficher le message d'introduction après un délai
            setTimeout(showNarrativeMessage, 3000, "Bienvenue dans Les Profondeurs. Les portes cachent des secrets. À vous de les découvrir...", 8000);
            
            // Initialiser les variables de narration
            updateMilestoneDisplay();
            
            // Démarrer l'animation
            animate();
        }
        
        // Animation de chargement
        function simulateLoading() {
            let progress = 5;
            const loadProgressBar = document.getElementById('load-progress');
            
            const interval = setInterval(() => {
                progress += Math.floor(Math.random() * 8) + 3;
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(interval);
                }
                loadProgressBar.style.width = progress + '%';
            }, 300);
        }
        
        // Configuration du panneau de debug
        function setupDebug() {
            if (window.location.search.includes('debug=true')) {
                const debugPanel = document.getElementById('debug');
                debugPanel.style.display = 'block';
                
                // Toggle des contrôles avancés
                document.getElementById('toggle-debug').addEventListener('click', () => {
                    const advancedDebug = document.getElementById('advanced-debug');
                    advancedDebug.style.display = advancedDebug.style.display === 'none' ? 'block' : 'none';
                });
                
                // Bouton pour simuler un cadeau/don
                document.getElementById('giftBtn').addEventListener('click', () => {
                    const randomAmount = Math.floor(Math.random() * 100) + 5;
                    simulateDonation("Viewer" + Math.floor(Math.random() * 1000), randomAmount);
                });
                
                // Bouton pour envoyer un commentaire
                document.getElementById('commentBtn').addEventListener('click', () => {
                    const text = document.getElementById('commentInput').value.toLowerCase();
                    handleComment(text);
                    document.getElementById('commentInput').value = '';
                });
                
                // Bouton pour simuler des likes
                document.getElementById('likeBtn').addEventListener('click', () => {
                    // Petit effet visuel
                    window.camera.position.x += (Math.random() - 0.5) * 0.1;
                    window.camera.position.y += (Math.random() - 0.5) * 0.1;
                });
                
                // Contrôles avancés
                document.getElementById('debug-milestone').addEventListener('click', () => {
                    unlockNextMilestone("Debug");
                });
                
                document.getElementById('debug-entity').addEventListener('click', () => {
                    spawnSpecialEntity();
                });
                
                document.getElementById('debug-clue').addEventListener('click', () => {
                    revealRandomClue();
                });
                
                document.getElementById('debug-event').addEventListener('click', () => {
                    triggerSpecialEvent();
                });
                
                document.getElementById('debug-vote').addEventListener('click', () => {
                    startVote();
                });
            }
        }
        
        // Configuration du système de dons
        function setupDonationSystem() {
            // Vérifier si le bouton de simulation de dons existe avant d'ajouter l'écouteur
            const simDonationBtn = document.getElementById('sim-donation');
            if (simDonationBtn) {
                simDonationBtn.addEventListener('click', () => {
                    const amountInput = document.getElementById('donation-amount');
                    const amount = parseInt(amountInput.value);
                    
                    if (amount && amount > 0) {
                        const username = "Viewer" + Math.floor(Math.random() * 10000);
                        simulateDonation(username, amount);
                        amountInput.value = '';
                    }
                });
            }
            
            // Initialisation des valeurs
            updateDonationDisplay();
        }
        
        // Configuration du système de vote
        function setupVoteSystem() {
            // Gestion des clics sur les options de vote
            document.querySelectorAll('.vote-option').forEach(option => {
                option.addEventListener('click', (e) => {
                    const optionIndex = e.currentTarget.getAttribute('data-option');
                    voteForOption(optionIndex);
                });
            });
        }
        
        // ==========================================
        // FONCTIONS DE CRÉATION D'OBJETS 3D
        // ==========================================
        
        // Créer une barque avec un modèle Three.js détaillé
        function createBoat() {
            const boat = new THREE.Group();
            
            // Coque principale - forme d'une barque traditionnelle
            const hullShape = new THREE.Shape();
            // Définir un contour en forme de barque vue de dessus
            hullShape.moveTo(-0.7, -1.2);
            hullShape.quadraticCurveTo(-0.2, -1.5, 0, -1.5);
            hullShape.quadraticCurveTo(0.2, -1.5, 0.7, -1.2);
            hullShape.quadraticCurveTo(0.9, -0.8, 0.9, 0);
            hullShape.quadraticCurveTo(0.9, 0.8, 0.7, 1.2);
            hullShape.quadraticCurveTo(0.2, 1.5, 0, 1.5);
            hullShape.quadraticCurveTo(-0.2, 1.5, -0.7, 1.2);
            hullShape.quadraticCurveTo(-0.9, 0.8, -0.9, 0);
            hullShape.quadraticCurveTo(-0.9, -0.8, -0.7, -1.2);
            
            // Extruder la forme pour créer la coque 3D
            const extrudeSettings = {
                steps: 2,
                depth: 0.5,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.1,
                bevelOffset: 0,
                bevelSegments: 3
            };
            
            const hullGeometry = new THREE.ExtrudeGeometry(hullShape, extrudeSettings);
            
            // Créer un matériau pour la coque avec texture de bois
            const hullMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.7,
                metalness: 0.2
            });
            
            // Créer un effet de veine de bois (procédural)
            const woodTexture = createWoodTexture();
            hullMaterial.map = woodTexture;
            
            const hull = new THREE.Mesh(hullGeometry, hullMaterial);
            hull.rotation.x = Math.PI / 2; // Orienter correctement la barque
            boat.add(hull);
            
            // Ajouter des bancs transversaux
            const benchMaterial = new THREE.MeshStandardMaterial({
                color: 0x964B00,
                roughness: 0.8,
                metalness: 0.1
            });
            
            // Banc avant
            const frontBenchGeometry = new THREE.BoxGeometry(1.4, 0.1, 0.25);
            const frontBench = new THREE.Mesh(frontBenchGeometry, benchMaterial);
            frontBench.position.set(0, 0.3, 0.9);
            boat.add(frontBench);
            
            // Banc arrière
            const backBenchGeometry = new THREE.BoxGeometry(1.4, 0.1, 0.25);
            const backBench = new THREE.Mesh(backBenchGeometry, benchMaterial);
            backBench.position.set(0, 0.3, -0.9);
            boat.add(backBench);
            
            // Banc milieu
            const middleBenchGeometry = new THREE.BoxGeometry(1.4, 0.1, 0.25);
            const middleBench = new THREE.Mesh(middleBenchGeometry, benchMaterial);
            middleBench.position.set(0, 0.3, 0);
            boat.add(middleBench);
            
            // Ajouter une lanterne pour l'ambiance
            const lanternBase = new THREE.CylinderGeometry(0.05, 0.05, 0.2, 8);
            const lanternGlobe = new THREE.SphereGeometry(0.1, 8, 8);
            const lanternMaterial = new THREE.MeshStandardMaterial({
                color: 0x553311,
                roughness: 0.5
            });
            const lanternGlassMaterial = new THREE.MeshStandardMaterial({
                color: 0xffaa55,
                emissive: 0xff6622,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.7
            });
            
            const lanternBaseObj = new THREE.Mesh(lanternBase, lanternMaterial);
            const lanternGlobeObj = new THREE.Mesh(lanternGlobe, lanternGlassMaterial);
            lanternGlobeObj.position.y = 0.15;
            
            const lantern = new THREE.Group();
            lantern.add(lanternBaseObj);
            lantern.add(lanternGlobeObj);
            lantern.position.set(0, 0.4, 0.9);
            boat.add(lantern);
            
            // Ajouter une lumière dans la lanterne
            const lanternLight = new THREE.PointLight(0xff6622, 1, 3);
            lanternLight.position.set(0, 0.15, 0);
            lantern.add(lanternLight);
            
            // Position et échelle finale de la barque
            boat.scale.set(0.7, 0.7, 0.7);
            boat.position.y = WATER_LEVEL + 0.4;
            window.scene.add(boat);
            
            // Variables pour l'animation narrative de la barque
            boat.userData = {
                lanternLight: lanternLight,
                lanternOriginalIntensity: 1,
                narrativeState: "normal"
            };
            
            return boat;
        }
        
        // Fonction pour créer une texture de bois
        function createWoodTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            
            // Fond
            context.fillStyle = "#8B4513";
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Veines de bois
            for (let i = 0; i < 30; i++) {
                // Position et épaisseur variables
                const y = Math.random() * canvas.height;
                const width = 1 + Math.random() * 3;
                
                // Couleur de veine légèrement variable
                const brightness = 100 + Math.floor(Math.random() * 50);
                const color = `rgb(${brightness}, ${brightness * 0.6}, ${brightness * 0.4})`;
                
                context.beginPath();
                context.moveTo(0, y);
                
                // Créer une ligne ondulée
                for (let x = 0; x < canvas.width; x += canvas.width/20) {
                    const newY = y + (Math.random() - 0.5) * 15;
                    context.lineTo(x, newY);
                }
                
                context.strokeStyle = color;
                context.lineWidth = width;
                context.stroke();
            }
            
            // Noeuds du bois
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 3 + Math.random() * 8;
                
                const gradient = context.createRadialGradient(x, y, 1, x, y, radius);
                gradient.addColorStop(0, "#4B2809");
                gradient.addColorStop(1, "#8B4513");
                
                context.beginPath();
                context.arc(x, y, radius, 0, Math.PI * 2);
                context.fillStyle = gradient;
                context.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }
        
        // Créer un segment de tunnel avec rebords et portes
        function createSegment(zPosition) {
            const segment = new THREE.Group();
            segment.position.z = zPosition;
            
            // Tunnel principal
            const tunnelGeometry = new THREE.CylinderGeometry(
                TUNNEL_RADIUS, TUNNEL_RADIUS, TUNNEL_LENGTH, 16, 1, true
            );
            const tunnelMaterial = new THREE.MeshPhongMaterial({
                color: 0x333333, 
                side: THREE.BackSide
            });
            const tunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
            tunnel.rotation.x = Math.PI / 2;
            segment.add(tunnel);
            
            // Sol/eau au centre
            const waterWidth = TUNNEL_RADIUS * 1.2; // Réduire pour laisser de la place aux rebords
            const floorGeometry = new THREE.PlaneGeometry(
                waterWidth, TUNNEL_LENGTH
            );
            const waterMaterial = new THREE.MeshPhongMaterial({
                color: 0x006666,
                transparent: true,
                opacity: 0.7
            });
            const floor = new THREE.Mesh(floorGeometry, waterMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = WATER_LEVEL;
            segment.add(floor);
            
            // Ajouter un effet de miroitement à l'eau
            segment.userData.water = floor;
            segment.userData.waterBaseColor = new THREE.Color(0x006666);
            
            // Ajouter des rebords et des portes régulièrement
            for (let z = 0; z < TUNNEL_LENGTH; z += 5) {
                // Position en z
                const doorZ = z - TUNNEL_LENGTH / 2;
                
                // Déterminer si cette porte est spéciale (narrative)
                const isSpecialDoor = Math.random() < 0.05 + (window.storyProgress * 0.02);
                
                // Porte gauche
                const leftDoor = createDoor(isSpecialDoor);
                leftDoor.position.set(-TUNNEL_RADIUS + 0.2, WATER_LEVEL + 1.5, doorZ);
                leftDoor.rotation.x = Math.PI/2; // Rotation pour que la porte soit parallèle à l'eau
                segment.add(leftDoor);
                
                if (isSpecialDoor) {
                    registerSpecialDoor(leftDoor);
                }
                
                window.doors.push(leftDoor);
                
                // Porte droite - maintenant parallèle à l'eau
                const rightDoor = createDoor(isSpecialDoor);
                rightDoor.position.set(TUNNEL_RADIUS - 0.2, WATER_LEVEL + 1.5, doorZ);
                rightDoor.rotation.x = Math.PI/2; // Rotation pour que la porte soit parallèle à l'eau
                rightDoor.rotation.z = Math.PI; // Rotation pour que la porte soit orientée vers l'intérieur
                segment.add(rightDoor);
                
                if (isSpecialDoor) {
                    registerSpecialDoor(rightDoor);
                }
                
                window.doors.push(rightDoor);
                
                // Rebords pour marcher (gauche et droite)
                createWalkway(segment, -TUNNEL_RADIUS + 0.6, WATER_LEVEL + 0.1, doorZ - 2.5, 5);
                createWalkway(segment, TUNNEL_RADIUS - 0.6, WATER_LEVEL + 0.1, doorZ - 2.5, 5);
                
                // Lumières murales
                createWallLight(segment, -TUNNEL_RADIUS + 0.1, WATER_LEVEL + 2, doorZ - 1.5);
                createWallLight(segment, TUNNEL_RADIUS - 0.1, WATER_LEVEL + 2, doorZ - 1.5);
            }
            
            // Lumière générale du tunnel (faible)
            const ambientLight = new THREE.PointLight(0x333333, 0.3, TUNNEL_RADIUS * 2);
            ambientLight.position.set(0, 0, 0);
            segment.add(ambientLight);
            
            // Stocker la position et les données supplémentaires
            segment.userData = { 
                ...segment.userData,
                zPosition: zPosition,
                narrativeZone: determineNarrativeZone(zPosition),
                ambientLight: ambientLight
            };
            
            window.scene.add(segment);
            window.segments.push(segment);
            return segment;
        }
        
        // Créer un rebord pour marcher
        function createWalkway(parent, x, y, z, length) {
            // Plateforme pour marcher
            const walkwayGeometry = new THREE.BoxGeometry(1, 0.2, length);
            const walkwayMaterial = new THREE.MeshPhongMaterial({color: 0x555555});
            const walkway = new THREE.Mesh(walkwayGeometry, walkwayMaterial);
            walkway.position.set(x, y, z + length/2);
            parent.add(walkway);
            
            // Support métallique
            for (let i = 0; i < length; i += 1.5) {
                const supportGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 6);
                const supportMaterial = new THREE.MeshPhongMaterial({color: 0x777777});
                const support = new THREE.Mesh(supportGeometry, supportMaterial);
                support.position.set(x, y - 0.35, z + i);
                parent.add(support);
            }
            
            return walkway;
        }
        
        // Créer une lumière murale
        function createWallLight(parent, x, y, z) {
            // Groupe pour la lumière
            const lightGroup = new THREE.Group();
            lightGroup.position.set(x, y, z);
            
            // Support mural
            const baseGeometry = new THREE.BoxGeometry(0.1, 0.3, 0.3);
            const baseMaterial = new THREE.MeshPhongMaterial({color: 0x333333});
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            
            // Orientation selon le côté
            if (x < 0) { // Côté gauche
                base.rotation.y = 0;
                lightGroup.rotation.y = 0;
            } else { // Côté droit
                base.rotation.y = Math.PI;
                lightGroup.rotation.y = Math.PI;
            }
            
            lightGroup.add(base);
            
            // Ampoule/Globe
            const bulbGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            
            // La couleur varie en fonction de la progression de l'histoire
            const colorProgress = Math.min(window.storyProgress, 1);
            const bulbColor = new THREE.Color().setHSL(
                0.1 - (colorProgress * 0.1), // De jaune vers rouge
                0.7,
                0.5 + (colorProgress * 0.2) // Devient plus brillant
            );
            
            const bulbMaterial = new THREE.MeshBasicMaterial({
                color: bulbColor
                // emissive et emissiveIntensity sont retirés car non supportés par MeshBasicMaterial
            });
            
            const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
            bulb.position.x = (x < 0) ? 0.1 : -0.1; // Position selon le côté
            lightGroup.add(bulb);
            
            // Lumière
            const intensity = 0.5 + Math.random() * 0.5;
            const light = new THREE.PointLight(bulbColor, intensity, 3);
            light.position.copy(bulb.position);
            lightGroup.add(light);
            
            // Ajouter des données pour les animations
            lightGroup.userData = {
                bulb: bulb,
                light: light,
                originalIntensity: intensity,
                flicker: Math.random() < 0.3, // 30% de chance de scintillement
                flickerSpeed: 0.5 + Math.random() * 2,
                originalColor: bulbColor.clone()
            };
            
            parent.add(lightGroup);
            return lightGroup;
        }
        
        // Créer une porte avec une orientation correcte et thématique
        function createDoor(isSpecial = false) {
            const door = new THREE.Group();
            
            // Couleurs différentes selon le type de porte
            let doorColor, frameColor, detailsColor;
            let doorSymbol = null;
            
            if (isSpecial) {
                // Porte spéciale avec couleur et caractéristiques uniques
                const specialType = Math.floor(Math.random() * 5);
                
                switch(specialType) {
                    case 0: // Porte mystérieuse avec symboles
                        frameColor = 0x443322;
                        doorColor = 0x221100;
                        detailsColor = 0xaa8866;
                        doorSymbol = "symbol";
                        break;
                    case 1: // Porte rouge sang
                        frameColor = 0x662222;
                        doorColor = 0x990000;
                        detailsColor = 0xaa3333;
                        doorSymbol = "blood";
                        break;
                    case 2: // Porte luminescente
                        frameColor = 0x443355;
                        doorColor = 0x334466;
                        detailsColor = 0x88aaff;
                        doorSymbol = "glow";
                        break;
                    case 3: // Porte métallique rouillée
                        frameColor = 0x775533;
                        doorColor = 0x996633;
                        detailsColor = 0xcc8844;
                        doorSymbol = "rust";
                        break;
                    case 4: // Porte avec marques de griffes
                        frameColor = 0x554433;
                        doorColor = 0x443322;
                        detailsColor = 0x333333;
                        doorSymbol = "claw";
                        break;
                }
            } else {
                // Porte standard
                frameColor = 0x553322;
                doorColor = 0x332211;
                detailsColor = 0x888888;
            }
            
            // Cadre de porte
            const frameGeometry = new THREE.BoxGeometry(2, 3, 0.2);
            const frameMaterial = new THREE.MeshPhongMaterial({color: frameColor});
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            door.add(frame);
            
            // La porte elle-même (panneau)
            const doorGeometry = new THREE.BoxGeometry(1.8, 2.8, 0.1);
            const doorMaterial = new THREE.MeshPhongMaterial({color: doorColor});
            const doorMesh = new THREE.Mesh(doorGeometry, doorMaterial);
            // Positionner la porte correctement pour l'animation
            doorMesh.position.z = -0.15; 
            door.add(doorMesh);
            
            // Poignée de porte
            const handleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const handleMaterial = new THREE.MeshPhongMaterial({color: detailsColor});
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.set(0.5, 0, -0.15); // À droite de la porte vue de face
            door.add(handle);
            
            // Ajout de numéro ou symbole de porte
            const doorNumber = Math.floor(Math.random() * 900) + 100;
            
            // Plaque de numéro/symbole
            const plateGeometry = new THREE.PlaneGeometry(0.4, 0.2);
            const plateMaterial = new THREE.MeshPhongMaterial({
                color: detailsColor,
                side: THREE.DoubleSide
            });
            const plate = new THREE.Mesh(plateGeometry, plateMaterial);
            plate.position.set(0, 1, -0.11);
            door.add(plate);
            
            // Ajouter un symbole spécial si c'est une porte spéciale
            if (isSpecial && doorSymbol) {
                // Créer le symbole selon le type
                switch(doorSymbol) {
                    case "symbol":
                        // Ajouter un symbole ésotérique
                        addSymbolToDoor(door, plate);
                        break;
                    case "blood":
                        // Ajouter des taches de sang
                        addBloodToDoor(door, doorMesh);
                        break;
                    case "glow":
                        // Ajouter un effet lumineux
                        addGlowToDoor(door, doorMesh);
                        break;
                    case "rust":
                        // Ajouter des taches de rouille
                        addRustToDoor(door, doorMesh);
                        break;
                    case "claw":
                        // Ajouter des marques de griffes
                        addClawMarksToDoor(door, doorMesh);
                        break;
                }
            }
            
            // Données pour l'animation et statut narratif
            door.userData = {
                doorMesh: doorMesh,
                animating: false,
                doorNumber: doorNumber,
                isSpecial: isSpecial,
                doorSymbol: doorSymbol,
                activated: false,
                containsClue: isSpecial && (Math.random() < 0.6), // 60% des portes spéciales contiennent un indice
                containsEntity: isSpecial && (Math.random() < 0.3), // 30% des portes spéciales contiennent une entité
                entityType: isSpecial ? Math.floor(Math.random() * 7) : null,
                narrativeElement: null
            };
            
            return door;
        }
        
        // Ajouter un symbole ésotérique à une porte
        function addSymbolToDoor(door, plate) {
            // Créer un canvas pour dessiner le symbole
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Fond transparent
            ctx.fillStyle = 'rgba(0, 0, 0, 0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Choisir un symbole aléatoire
            const symbolType = Math.floor(Math.random() * 5);
            
            // Dessiner le symbole en blanc
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.fillStyle = 'white';
            
            switch(symbolType) {
                case 0: // Cercle avec triangle
                    ctx.beginPath();
                    ctx.arc(64, 64, 40, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(64, 34);
                    ctx.lineTo(94, 94);
                    ctx.lineTo(34, 94);
                    ctx.closePath();
                    ctx.stroke();
                    break;
                    
                case 1: // Spirale
                    ctx.beginPath();
                    let radius = 5;
                    let angle = 0;
                    let x = 64;
                    let y = 64;
                    
                    for (let i = 0; i < 200; i++) {
                        angle += 0.1;
                        radius += 0.2;
                        const newX = 64 + Math.cos(angle) * radius;
                        const newY = 64 + Math.sin(angle) * radius;
                        ctx.lineTo(newX, newY);
                        x = newX;
                        y = newY;
                        
                        if (radius > 40) break;
                    }
                    ctx.stroke();
                    break;
                    
                case 2: // Œil
                    ctx.beginPath();
                    ctx.ellipse(64, 64, 45, 25, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(64, 64, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(64, 39);
                    ctx.lineTo(64, 89);
                    ctx.stroke();
                    break;
                    
                case 3: // Runes
                    for (let i = 0; i < 3; i++) {
                        const startX = 34 + i * 30;
                        ctx.beginPath();
                        
                        // Runes aléatoires
                        switch(Math.floor(Math.random() * 5)) {
                            case 0: // F-like
                                ctx.moveTo(startX, 44);
                                ctx.lineTo(startX, 94);
                                ctx.moveTo(startX, 44);
                                ctx.lineTo(startX + 20, 44);
                                ctx.moveTo(startX, 69);
                                ctx.lineTo(startX + 15, 69);
                                break;
                            case 1: // X-like
                                ctx.moveTo(startX - 10, 44);
                                ctx.lineTo(startX + 10, 94);
                                ctx.moveTo(startX + 10, 44);
                                ctx.lineTo(startX - 10, 94);
                                break;
                            case 2: // O with line
                                ctx.arc(startX, 69, 25, 0, Math.PI * 2);
                                ctx.moveTo(startX - 25, 69);
                                ctx.lineTo(startX + 25, 69);
                                break;
                            case 3: // Arrow
                                ctx.moveTo(startX, 44);
                                ctx.lineTo(startX, 94);
                                ctx.moveTo(startX - 10, 54);
                                ctx.lineTo(startX, 44);
                                ctx.lineTo(startX + 10, 54);
                                break;
                            case 4: // Wave
                                ctx.moveTo(startX - 15, 69);
                                for (let j = 0; j < 30; j++) {
                                    ctx.lineTo(startX - 15 + j, 69 + Math.sin(j * 0.3) * 15);
                                }
                                break;
                        }
                        
                        ctx.stroke();
                    }
                    break;
                    
                case 4: // Constellation
                    // Points
                    const points = [];
                    for (let i = 0; i < 7; i++) {
                        points.push({
                            x: 30 + Math.random() * 68,
                            y: 30 + Math.random() * 68,
                            r: 2 + Math.random() * 3
                        });
                    }
                    
                    // Dessiner les points
                    points.forEach(point => {
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, point.r, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Relier certains points
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) {
                        if (Math.random() < 0.7) { // 70% de chance de relier deux points
                            ctx.lineTo(points[i].x, points[i].y);
                        } else {
                            ctx.moveTo(points[i].x, points[i].y);
                        }
                    }
                    ctx.stroke();
                    break;
            }
            
            // Créer une texture à partir du canvas
            const symbolTexture = new THREE.CanvasTexture(canvas);
            
            // Créer un matériau avec cette texture
            const symbolMaterial = new THREE.MeshBasicMaterial({
                map: symbolTexture,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            
            // Remplacer le matériau de la plaque
            plate.material = symbolMaterial;
            
            // Agrandir la plaque pour le symbole
            plate.scale.set(2, 2, 1);
            
            // Stocker les données pour animation
            door.userData.symbolType = symbolType;
            door.userData.symbolTexture = symbolTexture;
        }
        
        // Ajouter des taches de sang à une porte
        function addBloodToDoor(door, doorMesh) {
            // Créer un canvas pour dessiner les taches
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Copier la couleur de base de la porte
            ctx.fillStyle = '#990000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner des taches de sang aléatoires
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 10 + Math.random() * 50;
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, 'rgba(120, 0, 0, 0.9)');
                gradient.addColorStop(0.7, 'rgba(80, 0, 0, 0.6)');
                gradient.addColorStop(1, 'rgba(80, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Dessiner des traînées de sang coulant
            for (let i = 0; i < 5; i++) {
                const startX = Math.random() * canvas.width;
                const startY = Math.random() * (canvas.height / 2); // Commencer dans la moitié supérieure
                
                ctx.strokeStyle = 'rgba(100, 0, 0, 0.8)';
                ctx.lineWidth = 3 + Math.random() * 8;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                
                let currentX = startX;
                let currentY = startY;
                
                // Créer une ligne descendante avec zigzags aléatoires
                const length = 50 + Math.random() * 200;
                for (let j = 0; j < length; j += 10) {
                    currentY += 10;
                    currentX += (Math.random() - 0.5) * 15;
                    
                    // Réduire progressivement l'épaisseur de la ligne
                    ctx.lineWidth = Math.max(1, ctx.lineWidth - 0.2);
                    
                    ctx.lineTo(currentX, currentY);
                    
                    if (currentY > canvas.height) break;
                }
                
                ctx.stroke();
            }
            
            // Créer une texture à partir du canvas
            const bloodTexture = new THREE.CanvasTexture(canvas);
            
            // Appliquer la texture à la porte
            const bloodMaterial = new THREE.MeshStandardMaterial({
                map: bloodTexture,
                color: 0x990000,
                roughness: 0.7,
                metalness: 0.2
            });
            
            doorMesh.material = bloodMaterial;
        }
        
        // Ajouter un effet lumineux à une porte
        function addGlowToDoor(door, doorMesh) {
            // Créer un matériau avec émission pour l'effet lumineux
            const glowMaterial = new THREE.MeshStandardMaterial({
                color: 0x334466,
                emissive: 0x88aaff,
                emissiveIntensity: 0.5,
                roughness: 0.4,
                metalness: 0.6
            });
            
            doorMesh.material = glowMaterial;
            
            // Ajouter une lumière pour renforcer l'effet
            const glowLight = new THREE.PointLight(0x88aaff, 0.8, 1);
            glowLight.position.set(0, 0, -0.1);
            doorMesh.add(glowLight);
            
            // Stocker la lumière pour l'animation
            door.userData.glowLight = glowLight;
            door.userData.originalIntensity = 0.8;
        }
        
        // Ajouter des taches de rouille à une porte
        function addRustToDoor(door, doorMesh) {
            // Créer un canvas pour dessiner la rouille
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Couleur de base métallique
            ctx.fillStyle = '#996633';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Ajouter une texture métallique de base
            for (let i = 0; i < 20; i++) {
                ctx.strokeStyle = `rgba(153, 122, 102, ${Math.random() * 0.3})`;
                ctx.lineWidth = 1 + Math.random() * 2;
                
                ctx.beginPath();
                ctx.moveTo(0, Math.random() * canvas.height);
                ctx.lineTo(canvas.width, Math.random() * canvas.height);
                ctx.stroke();
            }
            
            // Ajouter des taches de rouille
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 5 + Math.random() * 40;
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, 'rgba(180, 60, 20, 0.9)');
                gradient.addColorStop(0.6, 'rgba(160, 80, 30, 0.6)');
                gradient.addColorStop(1, 'rgba(153, 102, 51, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Ajouter quelques trous de rouille
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 2 + Math.random() * 6;
                
                ctx.fillStyle = 'rgba(30, 20, 10, 0.8)';
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Ajouter un halo de rouille intense autour du trou
                const holeGradient = ctx.createRadialGradient(x, y, radius, x, y, radius * 3);
                holeGradient.addColorStop(0, 'rgba(180, 60, 20, 0.9)');
                holeGradient.addColorStop(1, 'rgba(180, 60, 20, 0)');
                
                ctx.fillStyle = holeGradient;
                ctx.beginPath();
                ctx.arc(x, y, radius * 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Créer une texture à partir du canvas
            const rustTexture = new THREE.CanvasTexture(canvas);
            
            // Appliquer la texture à la porte
            const rustMaterial = new THREE.MeshStandardMaterial({
                map: rustTexture,
                roughness: 0.9,
                metalness: 0.4
            });
            
            doorMesh.material = rustMaterial;
        }
        
        // Ajouter des marques de griffes à une porte
        function addClawMarksToDoor(door, doorMesh) {
            // Créer un canvas pour dessiner les marques
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Couleur de base de la porte
            ctx.fillStyle = '#443322';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner des marques de griffes
            const clawSets = Math.floor(Math.random() * 3) + 2; // 2-4 sets de griffes
            
            for (let set = 0; set < clawSets; set++) {
                const startX = 50 + Math.random() * (canvas.width - 100);
                const startY = 50 + Math.random() * (canvas.height - 100);
                const angle = Math.random() * Math.PI / 4 - Math.PI / 8; // Angle aléatoire léger
                const length = 100 + Math.random() * 200;
                
                // 3-5 griffes par set
                const claws = Math.floor(Math.random() * 3) + 3;
                const spacing = 10 + Math.random() * 15;
                
                for (let claw = 0; claw < claws; claw++) {
                    // Calculer le décalage perpendiculaire à l'angle
                    const offsetX = Math.sin(angle) * spacing * (claw - (claws - 1) / 2);
                    const offsetY = -Math.cos(angle) * spacing * (claw - (claws - 1) / 2);
                    
                    ctx.strokeStyle = '#221100';
                    ctx.lineWidth = 3 + Math.random() * 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(startX + offsetX, startY + offsetY);
                    
                    // Ligne principale
                    const endX = startX + Math.cos(angle) * length + offsetX;
                    const endY = startY + Math.sin(angle) * length + offsetY;
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    // Ajouter une ligne plus claire pour montrer le bois exposé
                    ctx.strokeStyle = 'rgba(200, 150, 100, 0.7)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(startX + offsetX + 1, startY + offsetY + 1);
                    ctx.lineTo(endX + 1, endY + 1);
                    ctx.stroke();
                }
            }
            
            // Créer une texture à partir du canvas
            const clawTexture = new THREE.CanvasTexture(canvas);
            
            // Appliquer la texture à la porte
            const clawMaterial = new THREE.MeshStandardMaterial({
                map: clawTexture,
                roughness: 0.8,
                metalness: 0.1
            });
            
            doorMesh.material = clawMaterial;
        }
        
        // Déterminer la zone narrative en fonction de la position
        function determineNarrativeZone(zPosition) {
            // La progression narrative est déterminée par la distance parcourue
            // Plus on s'enfonce dans le tunnel, plus l'histoire avance
            const absolutePosition = Math.abs(zPosition);
            
            // Secteurs déterminés par les paliers de milestone
            if (absolutePosition < 50) return "prologue";
            if (absolutePosition < 150) return "secteur2";
            if (absolutePosition < 300) return "secteur3";
            if (absolutePosition < 500) return "secteur4";
            if (absolutePosition < 800) return "secteur5";
            if (absolutePosition < 1200) return "secteur6";
            if (absolutePosition < 1800) return "secteur7";
            return "finale";
        }
        
        // Enregistrer une porte spéciale
        function registerSpecialDoor(door) {
            const doorId = "door_" + Math.floor(Math.random() * 10000);
            window.specialDoors[doorId] = door;
            door.userData.doorId = doorId;
            
            // Si nous avons des indices non découverts, attribuer l'un d'eux à cette porte
            const availableClues = STORY_ELEMENTS.clues.filter(
                clue => !window.discoveredClues.includes(clue.id)
            );
            
            if (availableClues.length > 0 && door.userData.containsClue) {
                const randomClue = availableClues[Math.floor(Math.random() * availableClues.length)];
                door.userData.narrativeElement = {
                    type: "clue",
                    data: randomClue
                };
            }
        }
        
        // ==========================================
        // FONCTIONS D'ANIMATION ET INTERACTION
        // ==========================================
        
        // Animer une porte et révéler son contenu
        function animateDoor(door) {
            if (!door || door.userData.animating) return;
            
            door.userData.animating = true;
            const doorMesh = door.userData.doorMesh;
            const originalPosition = -0.15; // Position initiale
            
            // Incrémenter le compteur de portes activées
            window.activatedDoors++;
            
            // Si c'est une porte spéciale, la marquer comme activée
            if (door.userData.isSpecial && !door.userData.activated) {
                door.userData.activated = true;
                
                // Révéler un indice ou déclencher un événement narratif si applicable
                if (door.userData.narrativeElement) {
                    handleNarrativeElement(door.userData.narrativeElement);
                }
            }
            
            // Créer ou récupérer l'élément mystérieux derrière la porte
            let mysteryElement = null;
            
            if (!door.userData.mysteryElement) {
                // Déterminer le type d'élément mystérieux
                const entityType = door.userData.entityType || Math.floor(Math.random() * 7);
                
                // Si la porte est spéciale, plus de chance d'avoir une entité complexe
                const mysteryType = door.userData.isSpecial ? 
                    Math.min(6, Math.floor(Math.random() * 8)) : // Favorise les entités 0-6
                    Math.floor(Math.random() * 7); // Distribution uniforme
                
                mysteryElement = createMysteryElement(mysteryType, entityType);
                
                // Positionner l'élément derrière la porte
                const doorPosition = new THREE.Vector3();
                door.getWorldPosition(doorPosition);
                
                // Ajuster la position en fonction de l'orientation de la porte
                const doorDirection = new THREE.Vector3(0, 0, -1);
                doorDirection.applyQuaternion(door.quaternion);
                
                // Placer l'élément derrière la porte à une distance appropriée
                mysteryElement.position.copy(doorPosition);
                mysteryElement.position.add(doorDirection.multiplyScalar(1.5));
                
                // Attacher l'élément à la porte
                door.userData.mysteryElement = mysteryElement;
                door.userData.mysteryType = mysteryType;
                
                // Ajouter l'élément à la scène
                window.scene.add(mysteryElement);
                
                // Stocker dans la liste globale pour les mises à jour
                window.mysteryElements[mysteryElement.uuid] = mysteryElement;
            } else {
                mysteryElement = door.userData.mysteryElement;
            }
            
            // Animation d'ouverture puis de fermeture
            let openAmount = 0;
            let opening = true;
            let revealSound = false;
            let effectTriggered = false;
            
            const interval = setInterval(() => {
                if (opening) {
                    // Phase d'ouverture
                    openAmount += 0.02;
                    
                    // Jouer un son/effet à mi-ouverture
                    if (openAmount >= 0.15 && !revealSound) {
                        playMysterySound(door.userData.mysteryType || 0);
                        revealSound = true;
                    }
                    
                    // Limitation de l'ouverture maximale
                    if (openAmount >= 0.3) {
                        opening = false;
                        
                        // Déclencher un effet spécial une seule fois
                        if (!effectTriggered) {
                            triggerMysteryEffect(door.userData.mysteryType || 0, mysteryElement);
                            effectTriggered = true;
                        }
                    }
                } else {
                    // Phase de fermeture
                    openAmount -= 0.02;
                    
                    // Vérification fin de fermeture
                    if (openAmount <= 0) {
                        openAmount = 0;
                        clearInterval(interval);
                        door.userData.animating = false;
                        
                        // Ne pas supprimer l'élément mystérieux pour permettre des interactions continues
                        // avec le même élément si la porte est rouverte
                    }
                }
                
                // Appliquer le mouvement de la porte correctement
                doorMesh.position.z = originalPosition - openAmount;
            }, 50);
        }
        
        // Créer un élément mystérieux
        function createMysteryElement(type, entityVariant = 0) {
            const group = new THREE.Group();
            
            switch (type) {
                case 0: // Yeux brillants
                    const glowingEyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const glowingEyeMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
                    
                    const glowingLeftEye = new THREE.Mesh(glowingEyeGeometry, glowingEyeMaterial);
                    glowingLeftEye.position.x = 0.2;
                    group.add(glowingLeftEye);
                    
                    const glowingRightEye = new THREE.Mesh(glowingEyeGeometry, glowingEyeMaterial);
                    glowingRightEye.position.x = -0.2;
                    group.add(glowingRightEye);
                    
                    // Animation de clignotement
                    group.userData.update = (time) => {
                        const blink = Math.sin(time * 10) > 0.7;
                        glowingLeftEye.visible = glowingRightEye.visible = blink;
                    };
                    break;
                    
                case 1: // Tentacule ondulante
                    const tentacleGeometry = new THREE.CylinderGeometry(0.1, 0.02, 1.5, 8);
                    const tentacleMaterial = new THREE.MeshPhongMaterial({
                        color: 0x660066,
                        specular: 0x555555,
                        shininess: 30
                    });
                    
                    // Créer plusieurs segments pour la tentacule
                    const segments = 5;
                    const tentacleSegments = [];
                    
                    for (let i = 0; i < segments; i++) {
                        const segment = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.1 - (i * 0.02), 0.08 - (i * 0.02), 0.4, 8),
                            tentacleMaterial
                        );
                        segment.position.y = -i * 0.3;
                        if (i > 0) {
                            segment.position.z = 0.1;
                        }
                        
                        if (i > 0) {
                            tentacleSegments[i-1].add(segment);
                        } else {
                            group.add(segment);
                        }
                        
                        tentacleSegments.push(segment);
                    }
                    
                    // Animation d'ondulation
                    group.userData.update = (time) => {
                        tentacleSegments.forEach((segment, index) => {
                            segment.rotation.x = Math.sin(time * 3 + index * 0.5) * 0.3;
                            segment.rotation.z = Math.cos(time * 2 + index * 0.5) * 0.3;
                        });
                    };
                    break;
                    
                case 2: // Silhouette sombre
                    const torsoGeometry = new THREE.BoxGeometry(0.5, 0.8, 0.3);
                    const headGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                    const limbGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
                    
                    const shadowMaterial = new THREE.MeshBasicMaterial({
                        color: 0x000000,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const torso = new THREE.Mesh(torsoGeometry, shadowMaterial);
                    group.add(torso);
                    
                    const head = new THREE.Mesh(headGeometry, shadowMaterial);
                    head.position.y = 0.5;
                    group.add(head);
                    
                    // Membres
                    const arms = [];
                    for (let i = 0; i < 2; i++) {
                        const arm = new THREE.Mesh(limbGeometry, shadowMaterial);
                        arm.position.set(i === 0 ? -0.3 : 0.3, 0.1, 0);
                        arm.rotation.z = i === 0 ? Math.PI/4 : -Math.PI/4;
                        group.add(arm);
                        arms.push(arm);
                    }
                    
                    const legs = [];
                    for (let i = 0; i < 2; i++) {
                        const leg = new THREE.Mesh(limbGeometry, shadowMaterial);
                        leg.position.set(i === 0 ? -0.15 : 0.15, -0.6, 0);
                        group.add(leg);
                        legs.push(leg);
                    }
                    
                    // Animation d'agitation
                    group.userData.update = (time) => {
                        head.rotation.y = Math.sin(time * 2) * 0.5;
                        arms.forEach((arm, index) => {
                            arm.rotation.x = Math.sin(time * 3 + index) * 0.2;
                        });
                        legs.forEach((leg, index) => {
                            leg.rotation.x = Math.sin(time * 2 + index * Math.PI) * 0.1;
                        });
                        
                        group.position.y = Math.sin(time * 2) * 0.05;
                    };
                    break;
                    
                case 3: // Objet flottant lumineux
                    const coreGeometry = new THREE.OctahedronGeometry(0.2, 1);
                    const coreMaterial = new THREE.MeshBasicMaterial({
                        color: 0x88ffff,
                        wireframe: true
                    });
                    
                    const core = new THREE.Mesh(coreGeometry, coreMaterial);
                    group.add(core);
                    
                    // Lumière interne
                    const coreLight = new THREE.PointLight(0x88ffff, 1, 3);
                    core.add(coreLight);
                    
                    // Particules orbitales
                    const particles = [];
                    const particleGeometry = new THREE.SphereGeometry(0.03, 4, 4);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff
                    });
                    
                    for (let i = 0; i < 8; i++) {
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        particle.userData = {
                            orbitRadius: 0.3 + Math.random() * 0.2,
                            orbitSpeed: 0.5 + Math.random() * 2,
                            orbitOffset: Math.random() * Math.PI * 2,
                            elevation: (Math.random() - 0.5) * 0.3
                        };
                        group.add(particle);
                        particles.push(particle);
                    }
                    
                    // Animation d'orbite
                    group.userData.update = (time) => {
                        core.rotation.x = time * 0.5;
                        core.rotation.y = time * 0.8;
                        
                        particles.forEach(particle => {
                            const orbit = particle.userData;
                            particle.position.x = Math.cos(time * orbit.orbitSpeed + orbit.orbitOffset) * orbit.orbitRadius;
                            particle.position.z = Math.sin(time * orbit.orbitSpeed + orbit.orbitOffset) * orbit.orbitRadius;
                            particle.position.y = orbit.elevation + Math.sin(time * 2) * 0.1;
                        });
                        
                        coreLight.intensity = 0.7 + Math.sin(time * 5) * 0.3;
                    };
                    break;
                    
                case 4: // Visage fantomatique
                    const faceGeometry = new THREE.PlaneGeometry(0.6, 0.8);
                    
                    // Créer une texture dynamique pour le visage
                    const canvas = document.createElement('canvas');
                    canvas.width = 256;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    
                    // Fond transparent
                    ctx.fillStyle = 'rgba(0, 0, 0, 0)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Dessiner un visage de base
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(128, 120, 90, 120, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Yeux
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.ellipse(90, 100, 20, 25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.ellipse(166, 100, 20, 25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bouche
                    ctx.beginPath();
                    ctx.ellipse(128, 160, 40, 20, 0, 0, Math.PI);
                    ctx.fill();
                    
                    const faceTexture = new THREE.CanvasTexture(canvas);
                    const faceMaterial = new THREE.MeshBasicMaterial({
                        map: faceTexture,
                        transparent: true,
                        opacity: 0.7,
                        side: THREE.DoubleSide
                    });
                    
                    const face = new THREE.Mesh(faceGeometry, faceMaterial);
                    group.add(face);
                    
                    // Animation du visage
                    group.userData.canvas = canvas;
                    group.userData.texture = faceTexture;
                    group.userData.context = ctx;
                    
                    group.userData.update = (time) => {
                        const ctx = group.userData.context;
                        const canvas = group.userData.canvas;
                        
                        // Effacer et redessiner
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Visage de base
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.beginPath();
                        ctx.ellipse(128, 120, 90, 120, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Yeux animés
                        const eyeScaleY = Math.max(0.1, Math.sin(time * 4) * 0.5 + 0.5);
                        
                        ctx.fillStyle = '#000000';
                        ctx.beginPath();
                        ctx.ellipse(90, 100, 20, 25 * eyeScaleY, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.ellipse(166, 100, 20, 25 * eyeScaleY, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Bouche animée
                        const mouthOpen = 0.3 + Math.sin(time * 2) * 0.2;
                        ctx.beginPath();
                        ctx.ellipse(128, 160, 40, 20 * mouthOpen, 0, 0, Math.PI);
                        ctx.fill();
                        
                        // Mettre à jour la texture
                        group.userData.texture.needsUpdate = true;
                        
                        // Mouvement flottant
                        group.position.y = Math.sin(time * 1.5) * 0.1;
                        face.rotation.y = Math.sin(time) * 0.2;
                    };
                    break;
                    
                case 5: // Portail énergétique
                    const ringGeometry = new THREE.TorusGeometry(0.3, 0.03, 16, 32);
                    const ringMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffaa00,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    group.add(ring);
                    
                    // Ajouter des anneaux supplémentaires
                    const rings = [ring];
                    for (let i = 1; i < 3; i++) {
                        const newRing = new THREE.Mesh(
                            new THREE.TorusGeometry(0.3, 0.02, 16, 32),
                            new THREE.MeshBasicMaterial({
                                color: 0xffaa00,
                                transparent: true,
                                opacity: 0.5 - (i * 0.1)
                            })
                        );
                        rings.push(newRing);
                        group.add(newRing);
                    }
                    
                    // Centre du portail
                    const centerGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                    const centerMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.5
                    });
                    
                    const center = new THREE.Mesh(centerGeometry, centerMaterial);
                    group.add(center);
                    
                    // Lumière du portail
                    const portalLight = new THREE.PointLight(0xffaa00, 1, 3);
                    group.add(portalLight);
                    
                    // Animation du portail
                    group.userData.update = (time) => {
                        rings.forEach((ring, i) => {
                            ring.rotation.x = time * (1 + i * 0.2);
                            ring.rotation.y = time * (0.5 + i * 0.1);
                            
                            const scalePulse = 1 + Math.sin(time * (3 + i)) * 0.1;
                            ring.scale.set(scalePulse, scalePulse, 1);
                        });
                        
                        center.scale.setScalar(0.8 + Math.sin(time * 4) * 0.2);
                        portalLight.intensity = 0.7 + Math.sin(time * 5) * 0.3;
                    };
                    break;
                    
                case 6: // Créature obscure
                    // Remplacer CapsuleGeometry (non disponible en r128) par une combinaison de cylindre et sphères
                    const body = new THREE.Group();
                    
                    // Cylindre pour le corps
                    const bodyMainGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 12);
                    const bodyMaterial = new THREE.MeshPhongMaterial({
                        color: 0x330000,
                        specular: 0x111111,
                        shininess: 50
                    });
                    const bodyMain = new THREE.Mesh(bodyMainGeometry, bodyMaterial);
                    body.add(bodyMain);
                    
                    // Sphères pour arrondir les extrémités (effet capsule)
                    const topSphereGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                    const topSphere = new THREE.Mesh(topSphereGeometry, bodyMaterial);
                    topSphere.position.y = 0.2;
                    body.add(topSphere);
                    
                    const bottomSphereGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                    const bottomSphere = new THREE.Mesh(bottomSphereGeometry, bodyMaterial);
                    bottomSphere.position.y = -0.2;
                    body.add(bottomSphere);
                    
                    group.add(body);
                    
                    // Membres
                    const limbs = [];
                    const limbMaterial = new THREE.MeshPhongMaterial({
                        color: 0x220000,
                        specular: 0x111111,
                        shininess: 30
                    });
                    
                    for (let i = 0; i < 6; i++) {
                        const limbGeometry = new THREE.CylinderGeometry(0.03, 0.01, 0.5, 5);
                        const limb = new THREE.Mesh(limbGeometry, limbMaterial);
                        
                        const angle = (i / 6) * Math.PI * 2;
                        limb.position.set(
                            Math.cos(angle) * 0.2,
                            0,
                            Math.sin(angle) * 0.2
                        );
                        
                        limb.rotation.x = Math.PI / 2;
                        limb.rotation.z = angle;
                        
                        body.add(limb);
                        limbs.push(limb);
                    }
                    
                    // Yeux
                    const creatureEyeGeometry = new THREE.SphereGeometry(0.03, 8, 8);
                    const creatureEyeMaterial = new THREE.MeshBasicMaterial({
                        color: 0xff0000
                    });
                    
                    const creatureLeftEye = new THREE.Mesh(creatureEyeGeometry, creatureEyeMaterial);
                    creatureLeftEye.position.set(0.1, 0.2, 0.15);
                    body.add(creatureLeftEye);
                    
                    const creatureRightEye = new THREE.Mesh(creatureEyeGeometry, creatureEyeMaterial);
                    creatureRightEye.position.set(-0.1, 0.2, 0.15);
                    body.add(creatureRightEye);
                    
                    // Animation de la créature
                    group.userData.update = (time) => {
                        body.rotation.y = Math.sin(time) * 0.3;
                        
                        limbs.forEach((limb, i) => {
                            limb.rotation.x = Math.PI/2 + Math.sin(time * 3 + i) * 0.3;
                        });
                        
                        creatureLeftEye.scale.setScalar(0.8 + Math.sin(time * 5) * 0.2);
                        creatureRightEye.scale.setScalar(0.8 + Math.sin(time * 5 + 1) * 0.2);
                    };
                    break;
            }
            
            // Personnaliser l'entité selon sa variante
            customizeEntityByVariant(group, entityVariant);
            
            return group;
        }
        
        // Personnaliser l'entité en fonction de sa variante (pour la diversité)
        function customizeEntityByVariant(entity, variant) {
            // Appliquer des modifications selon le type de variante
            switch(variant) {
                case 1: // Variante plus grande
                    entity.scale.set(1.3, 1.3, 1.3);
                    break;
                case 2: // Variante colorée différemment
                    entity.traverse(child => {
                        if (child.isMesh && child.material) {
                            // Changer la teinte
                            if (child.material.color) {
                                const color = child.material.color;
                                color.setHSL((color.getHSL({}).h + 0.2) % 1, color.getHSL({}).s, color.getHSL({}).l);
                            }
                        }
                    });
                    break;
                case 3: // Variante déformée
                    entity.rotation.set(Math.PI/6, 0, Math.PI/8);
                    entity.scale.set(0.9, 1.2, 0.9);
                    break;
                case 4: // Variante avec lueur
                    const glow = new THREE.PointLight(0xaaccff, 0.5, 2);
                    entity.add(glow);
                    break;
                case 5: // Variante multiple (clones)
                    for (let i = 0; i < 2; i++) {
                        const clone = entity.clone();
                        clone.position.set(
                            (Math.random() - 0.5) * 0.5,
                            (Math.random() - 0.5) * 0.5,
                            (Math.random() - 0.5) * 0.5
                        );
                        clone.scale.set(0.7, 0.7, 0.7);
                        entity.add(clone);
                    }
                    break;
                case 6: // Variante plus angoissante/agressive
                    // Augmenter la vitesse d'animation
                    const originalUpdate = entity.userData.update;
                    if (originalUpdate) {
                        entity.userData.update = (time) => {
                            originalUpdate(time * 1.5); // Animation plus rapide
                        };
                    }
                    break;
                // Cas par défaut: aucune modification
            }
        }
        
        // Jouer un son mystérieux (simulation)
        function playMysterySound(type) {
            // Ici, on ne fait que simuler le son avec console.log
            // Dans une application réelle, vous utiliseriez l'API Web Audio
            const sounds = [
                "Chuchotements inquiétants",
                "Crissement humide",
                "Respiration profonde",
                "Bourdonnement électrique",
                "Gémissement spectral",
                "Vrombissement énergétique",
                "Grognement menaçant"
            ];
            
            console.log(`Son: ${sounds[Math.min(type, sounds.length - 1)]}`);
            
            // Déclencher un événement aléatoire basé sur la progression narrative
            if (Math.random() < window.storyProgress * 0.05) {
                setTimeout(() => {
                    console.log("Événement sonore spécial déclenché!");
                    // Effet supplémentaire possible ici
                }, 1000 + Math.random() * 2000);
            }
        }
        
        // Déclencher un effet spécial selon le type d'élément mystérieux
        function triggerMysteryEffect(type, element) {
            // Effets variés selon le type
            switch(type) {
                case 0: // Yeux - Flash rapide de lumière rouge
                    flashLightEffect(0xff0000);
                    break;
                case 1: // Tentacule - Secousse de caméra
                    cameraShakeEffect(0.5);
                    break;
                case 2: // Silhouette - Assombrissement temporaire
                    darkenEffect(1.5);
                    break;
                case 3: // Objet flottant - Pulse lumineux
                    pulseLightEffect(0x88ffff, 3);
                    break;
                case 4: // Visage - Effet de distorsion d'écran
                    distortScreenEffect(1);
                    break;
                case 5: // Portail - Mouvement soudain vers le portail
                    pullTowardsEffect(element, 0.5);
                    break;
                case 6: // Créature - Rugissement et secousse
                    cameraShakeEffect(0.8);
                    flashLightEffect(0xff3300);
                    break;
            }
        }
        
        // ==========================================
        // EFFETS VISUELS
        // ==========================================
        
        // Flash de lumière
        function flashLightEffect(color, intensity = 1.5) {
            // Ne pas créer un nouvel élément à chaque fois, réutiliser l'existant
            let flashOverlay = document.getElementById('flash-overlay');
            if (!flashOverlay) {
                flashOverlay = document.createElement('div');
                flashOverlay.id = 'flash-overlay';
                flashOverlay.style.position = 'fixed';
                flashOverlay.style.top = '0';
                flashOverlay.style.left = '0';
                flashOverlay.style.width = '100%';
                flashOverlay.style.height = '100%';
                flashOverlay.style.pointerEvents = 'none';
                flashOverlay.style.zIndex = '990';
                flashOverlay.style.transition = 'opacity 0.1s ease-in, opacity 0.3s ease-out';
                document.body.appendChild(flashOverlay);
            }
            
            flashOverlay.style.backgroundColor = new THREE.Color(color).getStyle();
            flashOverlay.style.opacity = '0';
            
            // Animation simplifiée pour éviter les empilements de setTimeout
            window.requestAnimationFrame(() => {
                flashOverlay.style.opacity = '0.3'; // Réduit pour moins de charge visuelle
                
                setTimeout(() => {
                    flashOverlay.style.opacity = '0';
                }, 100);
            });
        }
        
        // Secousse de caméra
        function cameraShakeEffect(intensity) {
            const originalPosition = {
                x: window.camera.position.x,
                y: window.camera.position.y,
                z: window.camera.position.z
            };
            
            let duration = 0;
            const maxDuration = 1; // durée en secondes
            
            function shake() {
                if (duration < maxDuration) {
                    duration += 0.05;
                    
                    // Appliquer un déplacement aléatoire à la caméra
                    window.camera.position.x = originalPosition.x + (Math.random() - 0.5) * intensity;
                    window.camera.position.y = originalPosition.y + (Math.random() - 0.5) * intensity;
                    
                    requestAnimationFrame(shake);
                } else {
                    // Remettre la caméra à sa position d'origine
                    window.camera.position.x = originalPosition.x;
                    window.camera.position.y = originalPosition.y;
                    window.camera.position.z = originalPosition.z;
                }
            }
            
            shake();
        }
        
        // Assombrissement de la scène
        function darkenEffect(duration) {
            // Stocker les intensités lumineuses originales
            const lights = [];
            window.scene.traverse(obj => {
                if (obj instanceof THREE.Light) {
                    lights.push({
                        light: obj,
                        originalIntensity: obj.intensity
                    });
                    obj.intensity *= 0.2; // Réduire fortement l'intensité
                }
            });
            
            // Restaurer après un délai
            setTimeout(() => {
                lights.forEach(item => {
                    item.light.intensity = item.originalIntensity;
                });
            }, duration * 1000);
        }
        
        // Effet de pulse lumineux
        function pulseLightEffect(color, pulseCount) {
            const pulseLight = new THREE.PointLight(color, 0, 10);
            pulseLight.position.copy(window.boat.position);
            window.scene.add(pulseLight);
            
            let currentPulse = 0;
            
            function pulse() {
                if (currentPulse < pulseCount) {
                    // Augmenter puis diminuer l'intensité
                    let time = 0;
                    const maxTime = 100;
                    
                    function pulseCycle() {
                        if (time < maxTime) {
                            time++;
                            // Courbe sinusoïdale pour l'intensité
                            const intensity = Math.sin((time / maxTime) * Math.PI) * 2;
                            pulseLight.intensity = intensity;
                            
                            requestAnimationFrame(pulseCycle);
                        } else {
                            currentPulse++;
                            if (currentPulse < pulseCount) {
                                setTimeout(pulse, 200);
                            } else {
                                window.scene.remove(pulseLight);
                            }
                        }
                    }
                    
                    pulseCycle();
                }
            }
            
            pulse();
        }
        
        // Effet de distorsion d'écran (simulé)
        function distortScreenEffect(duration) {
            // Créer un overlay pour simuler la distorsion
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'transparent';
            overlay.style.pointerEvents = 'none';
            overlay.style.zIndex = '1000';
            overlay.style.animation = `distort ${duration}s ease-in-out`;
            
            // Ajouter des styles pour l'animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes distort {
                    0% { backdrop-filter: blur(0px); }
                    25% { backdrop-filter: blur(3px) hue-rotate(45deg); }
                    50% { backdrop-filter: blur(5px) hue-rotate(90deg); }
                    75% { backdrop-filter: blur(3px) hue-rotate(45deg); }
                    100% { backdrop-filter: blur(0px); }
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(overlay);
            
            // Supprimer après la durée spécifiée
            setTimeout(() => {
                document.body.removeChild(overlay);
                document.head.removeChild(style);
            }, duration * 1000);
        }
        
        // Effet d'attraction vers un objet
        function pullTowardsEffect(element, duration) {
            if (!element) return;
            
            const startPosition = {
                x: window.boat.position.x,
                y: window.boat.position.y,
                z: window.boat.position.z
            };
            
            const targetPosition = new THREE.Vector3();
            element.getWorldPosition(targetPosition);
            
            // Calculer un point entre le bateau et la cible
            const pullTarget = new THREE.Vector3(
                startPosition.x + (targetPosition.x - startPosition.x) * 0.4,
                startPosition.y,
                startPosition.z + (targetPosition.z - startPosition.z) * 0.4
            );
            
            let time = 0;
            const pullDuration = duration * 40; // Nombre d'étapes pour l'animation
            
            function pull() {
                if (time < pullDuration) {
                    time++;
                    
                    // Courbe d'accélération puis décélération
                    let progress = time / pullDuration;
                    if (progress < 0.5) {
                        // Accélération
                        progress = 2 * progress * progress;
                    } else {
                        // Décélération
                        progress = -1 + (4 - 2 * progress) * progress;
                    }
                    
                    // Déplacer le bateau vers la cible puis retour
                    if (time < pullDuration / 2) {
                        window.boat.position.x = startPosition.x + (pullTarget.x - startPosition.x) * progress;
                        window.boat.position.z = startPosition.z + (pullTarget.z - startPosition.z) * progress;
                    } else {
                        const returnProgress = (time - pullDuration / 2) / (pullDuration / 2);
                        window.boat.position.x = pullTarget.x + (startPosition.x - pullTarget.x) * returnProgress;
                        window.boat.position.z = pullTarget.z + (startPosition.z - pullTarget.z) * returnProgress;
                    }
                    
                    requestAnimationFrame(pull);
                } else {
                    // Assurer que le bateau revient exactement à sa position initiale
                    window.boat.position.x = startPosition.x;
                    window.boat.position.z = startPosition.z;
                }
            }
            
            pull();
        }
        
        // ==========================================
        // SYSTÈME DE NARRATION ET DE DONS
        // ==========================================
        
        // Gérer un élément narratif (indice, événement, etc.)
        function handleNarrativeElement(element) {
            switch(element.type) {
                case "clue":
                    revealClue(element.data);
                    break;
                case "mystery":
                    handleMystery(element.data);
                    break;
                case "fragment":
                    showNarrativeFragment(element.data);
                    break;
            }
        }
        
        // Révéler un indice
        function revealClue(clue) {
            // Vérifier si l'indice est déjà découvert
            if (window.discoveredClues.includes(clue.id)) return;
            
            // Ajouter l'indice à la liste des découverts
            window.discoveredClues.push(clue.id);
            
            // Afficher une notification
            showClueNotification(`Indice trouvé: ${clue.text}`);
            
            // Afficher un message narratif
            showNarrativeMessage(`${clue.text}`, 8000);
            
            // Vérifier si cet indice complète un mystère
            checkMysteryCompletion();
            
            // Effet visuel spécial
            specialEffectForClueType(clue.category);
        }
        
        // Effet spécial selon la catégorie d'indice
        function specialEffectForClueType(category) {
            switch(category) {
                case "sequence":
                    flashLightEffect(0xffffff);
                    break;
                case "phrase":
                    showNarrativeMessage("Les mots semblent résonner dans le tunnel...", 4000);
                    break;
                case "symbol":
                    distortScreenEffect(0.5);
                    break;
                case "date":
                    countdownEffect();
                    break;
                case "location":
                    cameraShakeEffect(0.3);
                    break;
                case "word":
                    // Effet d'inversion de l'écran
                    const overlay = document.createElement('div');
                    overlay.style.position = 'fixed';
                    overlay.style.top = '0';
                    overlay.style.left = '0';
                    overlay.style.width = '100%';
                    overlay.style.height = '100%';
                    overlay.style.backgroundColor = 'transparent';
                    overlay.style.transform = 'scaleX(-1)';
                    overlay.style.zIndex = '1000';
                    document.body.appendChild(overlay);
                    
                    setTimeout(() => {
                        document.body.removeChild(overlay);
                    }, 3000);
                    break;
                case "pattern":
                    pulseLightEffect(0xaaffaa, 5);
                    break;
                case "name":
                    showNarrativeMessage("Ce nom semble important...", 4000);
                    flashLightEffect(0xffaaff);
                    break;
                case "math":
                    countdownEffect();
                    break;
                case "audio":
                    console.log("Son: Voix distordue mystérieuse");
                    break;
                case "cipher":
                    showNarrativeMessage("Ces lettres forment un code...", 4000);
                    break;
            }
        }
        
        // Afficher une notification d'indice trouvé
        function showClueNotification(text) {
            const notification = document.getElementById('clue-notification');
            notification.textContent = text;
            notification.classList.add('visible');
            
            setTimeout(() => {
                notification.classList.remove('visible');
            }, 5000);
        }
        
        // Vérifier si un mystère est complété
        function checkMysteryCompletion() {
            STORY_ELEMENTS.mysteries.forEach(mystery => {
                if (!mystery.solved) {
                    // Vérifier si tous les indices requis sont découverts
                    const allCluesFound = mystery.requiredClues.every(
                        clueId => window.discoveredClues.includes(clueId)
                    );
                    
                    if (allCluesFound) {
                        // Marquer le mystère comme résolu
                        mystery.solved = true;
                        window.solvedMysteries++;
                        
                        // Mettre à jour l'affichage
                        document.getElementById('solved-mysteries').textContent = 
                            `${window.solvedMysteries}/${STORY_ELEMENTS.mysteries.length}`;
                        
                        // Afficher un message
                        showNarrativeMessage(`Mystère résolu: ${mystery.title} - ${mystery.reward}`, 10000);
                        
                        // Déclencher un événement spécial
                        triggerSpecialEvent();
                    }
                }
            });
        }
        
        // Afficher un message narratif plus élégant avec optimisation
        function showNarrativeMessage(text, duration = 5000) {
            // Limiter les appels intensifs pendant les animations
            // Si nous sommes déjà en train d'afficher un message, mettons celui-ci en file d'attente
            if (window.narrativeMessageActive) {
                // Stocker le message pour l'afficher plus tard
                if (!window.messageQueue) window.messageQueue = [];
                window.messageQueue.push({text, duration});
                return;
            }
            
            window.narrativeMessageActive = true;
            const display = document.getElementById('narrative-display');
            
            // Limiter la longueur du texte pour éviter les problèmes de performance
            if (text.length > 300) {
                text = text.substring(0, 297) + '...';
            }
            
            // Déterminer le type de message pour un style visuel différent
            let messageType = 'milestone'; // Type par défaut
            let icon = '📜'; // Icône par défaut
            
            if (text.includes('Indice') || text.includes('découvert') || text.includes('révèle')) {
                messageType = 'discovery';
                icon = '🔍';
            } else if (text.includes('Mystère') || text.includes('événement') || text.includes('apparition') || text.includes('distorsion')) {
                messageType = 'event';
                icon = '⚡';
            }
            
            // Version simplifiée du HTML pour réduire la charge de mise en page
            display.innerHTML = `<div>${icon} ${text}</div>`;
            display.setAttribute('data-type', messageType);
            
            // Ajouter immédiatement au journal d'exploration (sans doublon)
            addToStoryHistory(messageType, text);
            
            // Affichage avec optimisation
            display.style.opacity = '0'; // Optimisation: éviter la transition en définissant directement le style
            setTimeout(() => {
                display.classList.add('visible');
                
                setTimeout(() => {
                    display.classList.remove('visible');
                    
                    // Libérer le verrou après un court délai pour s'assurer que la transition est terminée
                    setTimeout(() => {
                        window.narrativeMessageActive = false;
                        
                        // Vérifier s'il y a des messages en attente
                        if (window.messageQueue && window.messageQueue.length > 0) {
                            const nextMessage = window.messageQueue.shift();
                            showNarrativeMessage(nextMessage.text, nextMessage.duration);
                        }
                    }, 500);
                }, duration);
            }, 50);
        }
        
        // Afficher un fragment narratif
        function showNarrativeFragment(fragment) {
            showNarrativeMessage(fragment, 8000);
        }
        
        // Simuler un don
        function simulateDonation(username, amount) {
            // Ajouter au total des dons
            window.totalDonations += amount;
            
            // Mettre à jour l'affichage
            updateDonationDisplay();
            
            // Ajouter le donateur au mur
            addDonorToWall(username, amount);
            
            // Vérifier si un palier est atteint
            checkMilestoneUnlock(username);
            
            // Événement aléatoire basé sur le montant
            if (amount >= 100) {
                triggerSpecialEvent();
            } else if (amount >= 50) {
                revealRandomClue();
            } else if (amount >= 20) {
                // Petit effet visuel
                const effectChoice = Math.floor(Math.random() * 3);
                switch(effectChoice) {
                    case 0:
                        flashLightEffect(0xffff00);
                        break;
                    case 1:
                        pulseLightEffect(0xaaddff, 2);
                        break;
                    case 2:
                        cameraShakeEffect(0.3);
                        break;
                }
            }
            
            // Faire briller la lanterne du bateau pour montrer l'activité
            if (window.boat && window.boat.userData.lanternLight) {
                const originalIntensity = window.boat.userData.lanternOriginalIntensity;
                window.boat.userData.lanternLight.intensity = originalIntensity * 2;
                
                setTimeout(() => {
                    window.boat.userData.lanternLight.intensity = originalIntensity;
                }, 1000);
            }
        }
        
        // Mise à jour de l'affichage des dons sans mettre à jour le story-milestone (qui est maintenant caché)
        function updateDonationDisplay() {
            document.getElementById('total-donations').textContent = window.totalDonations + ' €';
            
            // Calculer le pourcentage de progression jusqu'au prochain palier
            const currentMilestone = STORY_MILESTONES[window.currentMilestoneIndex];
            const nextMilestone = STORY_MILESTONES[window.currentMilestoneIndex + 1];
            
            if (nextMilestone) {
                const progress = Math.min(100, (window.totalDonations / nextMilestone.amount) * 100);
                document.getElementById('story-progress').style.width = progress + '%';
                document.getElementById('progress-percent').textContent = Math.floor(progress) + '%';
                document.getElementById('next-milestone-amount').textContent = nextMilestone.amount + ' €';
                
                // Au lieu d'afficher dans l'élément visible, ajoutons-le uniquement au journal
                if (nextMilestone.description && nextMilestone.description !== document.getElementById('story-milestone').textContent) {
                    // Ajouter le jalon au journal seulement lors du changement
                    addToStoryHistory('milestone', `Prochain objectif: ${nextMilestone.description}`);
                }
                
                // Stocker la description, mais ne pas l'afficher
                document.getElementById('story-milestone').textContent = nextMilestone.description;
                
                // Mettre à jour la variable de progression globale
                window.storyProgress = progress / 100;
            }
        }
        
        // Mettre à jour l'affichage des paliers narratifs
        function updateMilestoneDisplay() {
            // Mettre à jour le nombre de mystères résolus
            const solvedCount = STORY_ELEMENTS.mysteries.filter(mystery => mystery.solved).length;
            document.getElementById('solved-mysteries').textContent = `${solvedCount}/${STORY_ELEMENTS.mysteries.length}`;
            
            // Mettre à jour l'affichage des dons et progression
            updateDonationDisplay();
            
            // Afficher le palier actuel
            const currentMilestone = STORY_MILESTONES[window.currentMilestoneIndex];
            if (currentMilestone) {
                document.getElementById('story-milestone').textContent = currentMilestone.description;
            }
        }
        
        // Ajouter un donateur au mur des donateurs
        function addDonorToWall(username, amount) {
            const donorList = document.getElementById('donor-list');
            
            // Déterminer le niveau du donateur
            let donorTier = DONOR_TIERS.find(tier => 
                amount >= tier.min && amount <= tier.max
            );
            
            if (!donorTier) {
                donorTier = DONOR_TIERS[0]; // Par défaut
            }
            
            // Créer l'élément
            const donorElement = document.createElement('div');
            donorElement.className = `donor ${donorTier.class}`;
            donorElement.textContent = `${username} (${donorTier.name}): ${amount} €`;
            
            // Ajouter au début de la liste
            if (donorList.firstChild) {
                donorList.insertBefore(donorElement, donorList.firstChild);
            } else {
                donorList.appendChild(donorElement);
            }
            
            // Limiter à 10 donateurs affichés
            if (donorList.children.length > 10) {
                donorList.removeChild(donorList.lastChild);
            }
            
            // Animation
            donorElement.style.animation = 'pulse 2s';
        }
        
        // Vérifier si un palier est atteint
        function checkMilestoneUnlock(username) {
            // Vérifier si nous avons atteint le prochain palier
            const nextMilestone = STORY_MILESTONES[window.currentMilestoneIndex + 1];
            
            if (nextMilestone && window.totalDonations >= nextMilestone.amount) {
                unlockNextMilestone(username);
            }
        }
        
        // Débloquer le prochain palier narratif
        function unlockNextMilestone(username) {
            window.currentMilestoneIndex++;
            const milestone = STORY_MILESTONES[window.currentMilestoneIndex];
            
            if (milestone) {
                // Afficher un message
                showNarrativeMessage(`[${milestone.title}] ${milestone.description}`, 10000);
                
                // Déclencher la fonction associée
                if (milestone.unlocksFunction) {
                    milestone.unlocksFunction(username);
                }
                
                // Mettre à jour l'affichage
                updateDonationDisplay();
                
                // Compte à rebours pour l'événement
                countdownEffect(3, () => {
                    triggerSpecialEvent();
                });
            }
        }
        
        // Fonction de compte à rebours
        function countdownEffect(count = 3, callback) {
            const counterElement = document.getElementById('event-counter') || (() => {
                const el = document.createElement('div');
                el.id = 'event-counter';
                document.body.appendChild(el);
                return el;
            })();
            
            let currentCount = count;
            counterElement.textContent = currentCount;
            counterElement.classList.add('visible');
            
            // Utiliser requestAnimationFrame pour la gestion du temps
            const startTime = performance.now();
            const interval = 1000; // 1 seconde entre chaque compte
            
            function updateCounter(timestamp) {
                const elapsed = timestamp - startTime;
                const newCount = count - Math.floor(elapsed / interval);
                
                if (newCount !== currentCount && newCount >= 0) {
                    currentCount = newCount;
                    counterElement.textContent = currentCount;
                    
                    // Ajouter un effet visuel léger
                    counterElement.style.transform = 'translate(-50%, -50%) scale(1.2)';
                    setTimeout(() => {
                        counterElement.style.transform = 'translate(-50%, -50%) scale(1)';
                    }, 100);
                }
                
                if (newCount >= 0) {
                    requestAnimationFrame(updateCounter);
                } else {
                    counterElement.classList.remove('visible');
                    if (callback) callback();
                }
            }
            
            requestAnimationFrame(updateCounter);
        }
        
        // Révéler un indice aléatoire
        function revealRandomClue() {
            // Trouver les indices non découverts
            const availableClues = STORY_ELEMENTS.clues.filter(
                clue => !window.discoveredClues.includes(clue.id)
            );
            
            if (availableClues.length > 0) {
                const randomClue = availableClues[Math.floor(Math.random() * availableClues.length)];
                revealClue(randomClue);
            }
        }
        
        // Déclencher un événement spécial
        function triggerSpecialEvent() {
            // Choisir un événement en fonction de la progression
            const eventType = Math.floor(Math.random() * 5);
            
            switch(eventType) {
                case 0: // Apparition d'entité
                    spawnSpecialEntity();
                    break;
                case 1: // Blackout
                    darkenEffect(3);
                    setTimeout(() => {
                        showNarrativeMessage("Quelque chose se déplace dans l'obscurité...", 5000);
                    }, 1000);
                    break;
                case 2: // Distorsion de réalité
                    distortScreenEffect(2);
                    setTimeout(() => {
                        showNarrativeFragment(
                            STORY_ELEMENTS.narrativeFragments[
                                Math.floor(Math.random() * STORY_ELEMENTS.narrativeFragments.length)
                            ]
                        );
                    }, 1000);
                    break;
                case 3: // Porte qui s'ouvre spontanément
                    // Trouver une porte visible
                    const visibleDoors = window.doors.filter(door => {
                        const doorPos = new THREE.Vector3();
                        door.getWorldPosition(doorPos);
                        const distance = doorPos.distanceTo(window.boat.position);
                        return distance < 15;
                    });
                    
                    if (visibleDoors.length > 0) {
                        const randomDoor = visibleDoors[Math.floor(Math.random() * visibleDoors.length)];
                        animateDoor(randomDoor);
                    }
                    break;
                case 4: // Vote communautaire
                    startVote();
                    break;
            }
        }
        
        // Faire apparaître une entité spéciale
        function spawnSpecialEntity() {
            // Position devant le bateau
            const position = new THREE.Vector3(
                window.boat.position.x + (Math.random() - 0.5) * 2,
                WATER_LEVEL + 0.5 + Math.random() * 1.5,
                window.boat.position.z + 10 + Math.random() * 5
            );
            
            // Type d'entité avancé basé sur la progression narrative
            let entityType;
            
            if (window.storyProgress < 0.2) {
                entityType = Math.floor(Math.random() * 3); // Entités basiques au début
            } else if (window.storyProgress < 0.5) {
                entityType = Math.floor(Math.random() * 5); // Plus de variété
            } else {
                // Utiliser seulement les types 0-5 pour éviter le type 6 (qui peut utiliser CapsuleGeometry)
                entityType = Math.floor(Math.random() * 6); 
                
                // Chance pour une entité boss avec progression élevée
                if (window.storyProgress > 0.8 && Math.random() < 0.3) {
                    return spawnBossEntity();
                }
            }
            
            // Variante basée sur l'avancement de l'histoire
            const entityVariant = Math.min(6, Math.floor(window.storyProgress * 10));
            
            try {
                const entity = createMysteryElement(entityType, entityVariant);
                entity.position.copy(position);
                
                // Orientation vers le bateau
                entity.lookAt(window.boat.position);
                
                window.scene.add(entity);
                
                // Stocker dans la liste des éléments mystérieux
                window.mysteryElements[entity.uuid] = entity;
                
                // Afficher un message selon le type
                const messages = [
                    "Des yeux brillent dans l'obscurité...",
                    "Quelque chose s'agite sous la surface...",
                    "Une silhouette se tient immobile, observant...",
                    "Un objet étrange flotte dans l'air...",
                    "Est-ce un visage qui vous regarde?",
                    "Une brèche énergétique s'ouvre devant vous...",
                    "Une créature émerge des profondeurs..."
                ];
                
                showNarrativeMessage(messages[entityType], 5000);
                
                // Faire disparaître après un certain temps
                setTimeout(() => {
                    // Animation de disparition
                    let opacity = 1;
                    const fadeInterval = setInterval(() => {
                        opacity -= 0.05;
                        
                        entity.traverse(child => {
                            if (child.material && child.material.opacity !== undefined) {
                                child.material.transparent = true;
                                child.material.opacity = opacity;
                            }
                        });
                        
                        if (opacity <= 0) {
                            clearInterval(fadeInterval);
                            window.scene.remove(entity);
                            delete window.mysteryElements[entity.uuid];
                        }
                    }, 100);
                }, 10000 + Math.random() * 5000);
                
                return entity;
            } catch (error) {
                console.error("Erreur lors de la création d'une entité:", error);
                // En cas d'erreur, essayons avec un type d'entité plus simple (type 0)
                return spawnSpecialEntity();
            }
        }
        
        // Faire apparaître une entité boss
        function spawnBossEntity() {
            // Annoncer l'événement
            countdownEffect(5, () => {
                // Assombrir la scène
                darkenEffect(10);
                
                // Créer l'entité boss
                const boss = new THREE.Group();
                
                // Position devant le bateau, plus loin que les entités normales
                boss.position.set(
                    window.boat.position.x,
                    WATER_LEVEL + 2,
                    window.boat.position.z + 20
                );
                
                // Corps principal de l'entité
                const bodyGeometry = new THREE.SphereGeometry(2, 16, 16);
                const bodyMaterial = new THREE.MeshPhongMaterial({
                    color: 0x220022,
                    emissive: 0x330033,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.8
                });
                
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                boss.add(body);
                
                // Aura lumineuse
                const auraLight = new THREE.PointLight(0xbb00ff, 3, 15);
                body.add(auraLight);
                
                // Tentacules
                const tentacles = [];
                for (let i = 0; i < 8; i++) {
                    const tentacle = new THREE.Group();
                    
                    const angle = (i / 8) * Math.PI * 2;
                    tentacle.position.set(
                        Math.cos(angle) * 1.5,
                        Math.sin(angle) * 1.5,
                        0
                    );
                    
                    // Segments de tentacule
                    const segments = [];
                    let prevSegment = null;
                    
                    for (let j = 0; j < 6; j++) {
                        const segGeometry = new THREE.CylinderGeometry(
                            0.2 - j * 0.03, 
                            0.17 - j * 0.03, 
                            0.5, 
                            8
                        );
                        
                        const segMaterial = new THREE.MeshPhongMaterial({
                            color: 0x440044,
                            emissive: 0x220022,
                            emissiveIntensity: 0.3
                        });
                        
                        const segment = new THREE.Mesh(segGeometry, segMaterial);
                        segment.rotation.x = Math.PI / 2;
                        
                        if (prevSegment) {
                            segment.position.z = 0.5;
                            prevSegment.add(segment);
                        } else {
                            tentacle.add(segment);
                        }
                        
                        prevSegment = segment;
                        segments.push(segment);
                    }
                    
                    boss.add(tentacle);
                    tentacles.push({
                        main: tentacle,
                        segments: segments,
                        angle: angle,
                        speed: 0.5 + Math.random() * 1
                    });
                }
                
                // Yeux
                for (let i = 0; i < 3; i++) {
                    const angle = (i / 3) * Math.PI * 2;
                    const radius = 1.2;
                    
                    const eyeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                    const eyeMaterial = new THREE.MeshBasicMaterial({
                        color: 0xff0000
                        // emissive et emissiveIntensity ne sont pas supportés par MeshBasicMaterial
                    });
                    
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius,
                        1.8 // Placé à l'avant
                    );
                    
                    body.add(eye);
                    
                    // Lumière pour chaque œil
                    const eyeLight = new THREE.PointLight(0xff0000, 1, 3);
                    eyeLight.position.set(0, 0, 0.2);
                    eye.add(eyeLight);
                }
                
                // Animation
                boss.userData.update = (time) => {
                    // Pulsation du corps
                    const pulse = 1 + Math.sin(time * 2) * 0.1;
                    body.scale.set(pulse, pulse, pulse);
                    
                    // Animation des tentacules
                    tentacles.forEach((tentacle, i) => {
                        const mainAngle = tentacle.angle + time * 0.2;
                        tentacle.main.position.set(
                            Math.cos(mainAngle) * 1.5,
                            Math.sin(mainAngle) * 1.5,
                            0
                        );
                        
                        // Mouvement ondulant des segments
                        tentacle.segments.forEach((segment, j) => {
                            const segAngle = time * tentacle.speed + j * 0.5;
                            segment.rotation.y = Math.sin(segAngle) * 0.5;
                            segment.rotation.z = Math.cos(segAngle) * 0.5;
                        });
                    });
                    
                    // L'entité boss suit lentement le bateau
                    const targetX = window.boat.position.x;
                    const targetZ = window.boat.position.z + 15;
                    
                    boss.position.x += (targetX - boss.position.x) * 0.01;
                    boss.position.z += (targetZ - boss.position.z) * 0.01;
                    
                    // Variation d'intensité lumineuse
                    auraLight.intensity = 2 + Math.sin(time * 5) * 1;
                };
                
                // Ajouter à la scène
                window.scene.add(boss);
                window.mysteryElements[boss.uuid] = boss;
                
                // Message dramatique
                showNarrativeMessage("Une présence ancienne a senti votre intrusion...", 8000);
                
                // Faire disparaître après un temps plus long
                setTimeout(() => {
                    // Animation de disparition spirale
                    let opacity = 1;
                    let scale = 1;
                    const fadeInterval = setInterval(() => {
                        opacity -= 0.02;
                        scale += 0.1;
                        
                        boss.scale.set(scale, scale, scale);
                        
                        boss.traverse(child => {
                            if (child.material && child.material.opacity !== undefined) {
                                child.material.transparent = true;
                                child.material.opacity = opacity;
                            }
                        });
                        
                        boss.rotation.z += 0.1;
                        
                        if (opacity <= 0) {
                            clearInterval(fadeInterval);
                            window.scene.remove(boss);
                            delete window.mysteryElements[boss.uuid];
                        }
                    }, 100);
                }, 30000);
                
                return boss;
            });
            
            showNarrativeMessage("Quelque chose d'imposant approche...", 5000);
        }
        
        // Démarrer un vote communautaire
        function startVote() {
            // Vérifier s'il y a déjà un vote en cours
            if (window.activeVote) return;
            
            // Types de votes possibles
            const voteTypes = [
                {
                    question: "Quelle porte le voyageur devrait-il ouvrir ensuite?",
                    options: [
                        "Porte avec symbole spirale",
                        "Porte rouge clignotante",
                        "Porte avec marques de griffes"
                    ]
                },
                {
                    question: "Quelle direction explorer?",
                    options: [
                        "Vers les profondeurs",
                        "Vers le couloir étroit",
                        "Vers la lumière distante"
                    ]
                },
                {
                    question: "Comment interagir avec l'entité?",
                    options: [
                        "L'observer à distance",
                        "Tenter de communiquer",
                        "Fuir immédiatement"
                    ]
                }
            ];
            
            // Choisir un type de vote aléatoire
            const voteType = voteTypes[Math.floor(Math.random() * voteTypes.length)];
            
            // Initialiser le vote
            window.activeVote = {
                question: voteType.question,
                options: voteType.options.map(option => ({ text: option, votes: 0 })),
                timeRemaining: 180, // 3 minutes
                totalVotes: 0
            };
            
            // Mettre à jour l'interface du vote
            const votePanel = document.getElementById('vote-panel');
            const voteQuestion = document.getElementById('vote-question');
            const voteTimer = document.getElementById('vote-timer');
            
            voteQuestion.textContent = voteType.question;
            
            // Mettre à jour les options de vote
            const voteOptions = votePanel.querySelectorAll('.vote-option');
            voteOptions.forEach((option, index) => {
                const optionText = option.querySelector('span:first-child');
                const optionPercent = option.querySelector('span:last-child');
                const optionFill = option.querySelector('.vote-fill');
                
                if (index < voteType.options.length) {
                    optionText.textContent = voteType.options[index];
                    optionPercent.textContent = "0%";
                    optionFill.style.width = "0%";
                    option.setAttribute('data-option', index);
                    option.style.display = 'block';
                } else {
                    option.style.display = 'none';
                }
            });
            
            // Afficher le panneau
            votePanel.style.display = 'block';
            
            // Annoncer le vote
            showNarrativeMessage(`Vote communautaire: ${voteType.question}`, 8000);
            
            // Démarrer le compte à rebours
            const timerInterval = setInterval(() => {
                window.activeVote.timeRemaining--;
                
                const minutes = Math.floor(window.activeVote.timeRemaining / 60);
                const seconds = window.activeVote.timeRemaining % 60;
                voteTimer.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                if (window.activeVote.timeRemaining <= 0) {
                    clearInterval(timerInterval);
                    endVote();
                }
            }, 1000);
            
            // Ajouter quelques votes initiaux
            for (let i = 0; i < 30; i++) {
                setTimeout(() => {
                    const randomOption = Math.floor(Math.random() * voteType.options.length);
                    voteForOption(randomOption);
                }, Math.random() * 10000);
            }
        }
        
        // Voter pour une option
        function voteForOption(optionIndex) {
            if (!window.activeVote) return;
            
            // Ajouter le vote
            window.activeVote.options[optionIndex].votes++;
            window.activeVote.totalVotes++;
            
            // Mettre à jour l'affichage
            updateVoteDisplay();
        }
        
        // Mettre à jour l'affichage du vote
        function updateVoteDisplay() {
            if (!window.activeVote) return;
            
            const votePanel = document.getElementById('vote-panel');
            const voteOptions = votePanel.querySelectorAll('.vote-option');
            
            voteOptions.forEach((option, index) => {
                if (index >= window.activeVote.options.length) return;
                
                const optionData = window.activeVote.options[index];
                const percent = window.activeVote.totalVotes === 0 ? 
                    0 : Math.round((optionData.votes / window.activeVote.totalVotes) * 100);
                
                const optionPercent = option.querySelector('span:last-child');
                const optionFill = option.querySelector('.vote-fill');
                
                optionPercent.textContent = `${percent}%`;
                optionFill.style.width = `${percent}%`;
            });
        }
        
        // Terminer un vote
        function endVote() {
            if (!window.activeVote) return;
            
            // Trouver l'option gagnante
            let winningIndex = 0;
            let maxVotes = 0;
            
            window.activeVote.options.forEach((option, index) => {
                if (option.votes > maxVotes) {
                    maxVotes = option.votes;
                    winningIndex = index;
                }
            });
            
            const winningOption = window.activeVote.options[winningIndex];
            
            // Annoncer le résultat
            showNarrativeMessage(`Le vote est terminé! Résultat: "${winningOption.text}" (${Math.round((winningOption.votes / window.activeVote.totalVotes) * 100)}%)`, 8000);
            
            // Exécuter l'action correspondante
            executeVoteResult(window.activeVote.question, winningOption.text);
            
            // Masquer le panneau de vote
            document.getElementById('vote-panel').style.display = 'none';
            
            // Réinitialiser le vote actif
            window.activeVote = null;
        }
        
        // Exécuter le résultat d'un vote
        function executeVoteResult(question, result) {
            // Actions en fonction du type de question
            if (question.includes("porte")) {
                // Recherche des portes correspondantes
                let matchingDoors = [];
                
                if (result.includes("spirale")) {
                    matchingDoors = window.doors.filter(door => 
                        door.userData.doorSymbol === "symbol" &&
                        door.userData.symbolType === 1
                    );
                } else if (result.includes("rouge")) {
                    matchingDoors = window.doors.filter(door => 
                        door.userData.doorSymbol === "blood"
                    );
                } else if (result.includes("griffes")) {
                    matchingDoors = window.doors.filter(door => 
                        door.userData.doorSymbol === "claw"
                    );
                }
                
                // Si on trouve une porte correspondante, l'ouvrir
                if (matchingDoors.length > 0) {
                    const doorToOpen = matchingDoors[Math.floor(Math.random() * matchingDoors.length)];
                    
                    // Déplacer le bateau vers la porte
                    moveBoatTowards(doorToOpen, () => {
                        animateDoor(doorToOpen);
                    });
                } else {
                    // Aucune porte trouvée, en créer une
                    showNarrativeMessage("Une nouvelle porte apparaît...", 5000);
                    
                    setTimeout(() => {
                        spawnSpecialDoor(result);
                    }, 2000);
                }
            } else if (question.includes("direction")) {
                // Changer la direction d'exploration
                if (result.includes("profondeurs")) {
                    // Accélérer vers l'avant
                    window.boatSpeed = 0.2;
                    setTimeout(() => {
                        window.boatSpeed = 0.05;
                    }, 10000);
                    
                    // Effet visuel d'accélération
                    distortScreenEffect(0.5);
                    
                } else if (result.includes("couloir")) {
                    // Se diriger vers un passage plus étroit
                    createNarrowPassage();
                    
                } else if (result.includes("lumière")) {
                    // Créer une zone lumineuse distante
                    createDistantLight();
                }
            } else if (question.includes("entité")) {
                // Interaction avec une entité
                const entity = spawnSpecialEntity();
                
                if (result.includes("observer")) {
                    // L'entité reste à distance et fait des mouvements lents
                    entity.userData.behavior = "observe";
                    showNarrativeMessage("L'entité semble curieuse, vous observant à distance...", 5000);
                    
                } else if (result.includes("communiquer")) {
                    // L'entité s'approche et "parle"
                    entity.userData.behavior = "communicate";
                    
                    moveEntityTowards(entity, window.boat.position, 5, () => {
                        showNarrativeFragment(
                            STORY_ELEMENTS.narrativeFragments[
                                Math.floor(Math.random() * STORY_ELEMENTS.narrativeFragments.length)
                            ]
                        );
                        
                        // Effet de communication
                        pulseLightEffect(0xaaffff, 5);
                    });
                    
                } else if (result.includes("fuir")) {
                    // L'entité devient menaçante et poursuit
                    entity.userData.behavior = "chase";
                    
                    showNarrativeMessage("Vous tentez de fuir, mais l'entité vous poursuit rapidement!", 5000);
                    
                    // Animation de poursuite
                    const chaseInterval = setInterval(() => {
                        moveEntityTowards(entity, window.boat.position, 2, null);
                        
                        // Si l'entité est trop proche, effet de secousse
                        const distance = entity.position.distanceTo(window.boat.position);
                        if (distance < 3) {
                            cameraShakeEffect(0.5);
                            flashLightEffect(0xff0000);
                        }
                    }, 500);
                    
                    // Arrêter la poursuite après un moment
                    setTimeout(() => {
                        clearInterval(chaseInterval);
                    }, 15000);
                }
            }
        }
        
        // Déplacer le bateau vers une cible
        function moveBoatTowards(target, callback = null) {
            const targetPosition = new THREE.Vector3();
            target.getWorldPosition(targetPosition);
            
            // Calculer un point d'arrêt à une distance raisonnable
            const direction = new THREE.Vector3().subVectors(targetPosition, window.boat.position).normalize();
            const stopPosition = new THREE.Vector3().copy(targetPosition).sub(direction.multiplyScalar(3));
            
            const originalSpeed = window.boatSpeed;
            let moving = true;
            
            // Animation de déplacement
            function moveStep() {
                if (!moving) return;
                
                // Calculer la direction vers la cible
                const currentDirection = new THREE.Vector3().subVectors(stopPosition, window.boat.position).normalize();
                
                // Mettre à jour la position du bateau
                window.boat.position.x += currentDirection.x * 0.1;
                window.boat.position.z += currentDirection.z * 0.1;
                
                // Orienter le bateau vers la cible
                window.boat.rotation.y = Math.atan2(currentDirection.x, currentDirection.z);
                
                // Vérifier si on est arrivé
                const distance = window.boat.position.distanceTo(stopPosition);
                if (distance < 0.5) {
                    moving = false;
                    window.boatSpeed = originalSpeed;
                    
                    if (callback) setTimeout(callback, 500);
                } else {
                    requestAnimationFrame(moveStep);
                }
            }
            
            // Démarrer l'animation
            moveStep();
        }
        
        // Déplacer une entité vers une position
        function moveEntityTowards(entity, targetPosition, speed = 3, callback = null) {
            // Calculer la direction
            const direction = new THREE.Vector3().subVectors(targetPosition, entity.position).normalize();
            
            // Déplacer l'entité
            entity.position.x += direction.x * (0.05 * speed);
            entity.position.z += direction.z * (0.05 * speed);
            
            // Orienter l'entité vers la cible
            entity.lookAt(targetPosition);
            
            // Vérifier si on est arrivé
            const distance = entity.position.distanceTo(targetPosition);
            if (distance < 1 && callback) {
                callback();
            }
        }
        
        // Créer un passage étroit
        function createNarrowPassage() {
            // Message narratif
            showNarrativeMessage("Le tunnel se rétrécit devant vous...", 5000);
            
            // Créer un segment spécial qui se rétrécit
            const segment = new THREE.Group();
            segment.position.z = window.boat.position.z + 30; // Plus loin devant
            
            // Tunnel conique qui se rétrécit
            const tunnelGeometry = new THREE.CylinderGeometry(
                TUNNEL_RADIUS, TUNNEL_RADIUS * 0.6, TUNNEL_LENGTH, 16, 8, true
            );
            const tunnelMaterial = new THREE.MeshPhongMaterial({
                color: 0x222222, 
                side: THREE.BackSide
            });
            const tunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
            tunnel.rotation.x = Math.PI / 2;
            segment.add(tunnel);
            
            // Sol/eau au centre
            const waterGeometry = new THREE.PlaneGeometry(
                TUNNEL_RADIUS * 1.2, TUNNEL_LENGTH
            );
            const waterMaterial = new THREE.MeshPhongMaterial({
                color: 0x004466,
                transparent: true,
                opacity: 0.7
            });
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = WATER_LEVEL;
            segment.add(water);
            
            // Lumières plus sombres
            for (let z = 0; z < TUNNEL_LENGTH; z += 3) {
                const zPos = z - TUNNEL_LENGTH / 2;
                
                const light = new THREE.PointLight(0x443333, 0.3, 3);
                light.position.set(0, 0, zPos);
                segment.add(light);
            }
            
            window.scene.add(segment);
            
            // Ajouter des effets de passage
            setTimeout(() => {
                // Son d'écoulement d'eau
                console.log("Son: Écoulement d'eau accéléré");
                
                // Déplacement automatique
                window.boatSpeed = 0.1;
                setTimeout(() => {
                    window.boatSpeed = 0.05;
                    
                    // Révéler un indice après le passage
                    revealRandomClue();
                }, 8000);
            }, 2000);
        }
        
        // Créer une lumière distante
        function createDistantLight() {
            // Message narratif
            showNarrativeMessage("Une lueur apparaît au loin...", 5000);
            
            // Créer un point lumineux au loin
            const lightPosition = new THREE.Vector3(
                window.boat.position.x + (Math.random() - 0.5) * 2,
                WATER_LEVEL + 1.5,
                window.boat.position.z + 50
            );
            
            // Lumière distante
            const distantLight = new THREE.PointLight(0xffffaa, 2, 50);
            distantLight.position.copy(lightPosition);
            window.scene.add(distantLight);
            
            // Halo visuel
            const haloGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const haloMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffaa,
                transparent: true,
                opacity: 0.7
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.position.copy(lightPosition);
            window.scene.add(halo);
            
            // Pulse animation
            halo.userData.update = (time) => {
                const pulse = 1 + Math.sin(time * 3) * 0.3;
                halo.scale.set(pulse, pulse, pulse);
                distantLight.intensity = 1.5 + Math.sin(time * 3) * 0.5;
            };
            
            // Ajouter à la liste des éléments mystérieux pour l'animation
            window.mysteryElements[halo.uuid] = halo;
            
            // Déplacer le bateau automatiquement vers la lumière
            setTimeout(() => {
                // Accélérer le bateau
                window.boatSpeed = 0.12;
                
                // Attendre que le bateau s'approche
                const checkInterval = setInterval(() => {
                    const distance = halo.position.distanceTo(window.boat.position);
                    
                    if (distance < 10) {
                        clearInterval(checkInterval);
                        window.boatSpeed = 0.05;
                        
                        // Effet de révélation
                        flashLightEffect(0xffffaa);
                        distortScreenEffect(1);
                        
                        // Faire disparaître la lumière
                        let scale = 1;
                        const fadeInterval = setInterval(() => {
                            scale += 0.2;
                            halo.scale.set(scale, scale, scale);
                            haloMaterial.opacity -= 0.05;
                            distantLight.intensity -= 0.1;
                            
                            if (haloMaterial.opacity <= 0) {
                                clearInterval(fadeInterval);
                                window.scene.remove(halo);
                                window.scene.remove(distantLight);
                                delete window.mysteryElements[halo.uuid];
                                
                                // Récompense
                                revealRandomClue();
                                showNarrativeMessage("La lumière révèle un secret avant de disparaître...", 5000);
                            }
                        }, 100);
                    }
                }, 500);
            }, 3000);
        }
        
        // Créer une porte spéciale basée sur un résultat de vote
        function spawnSpecialDoor(doorType) {
            // Position visible devant le bateau
            const doorPosition = new THREE.Vector3(
                window.boat.position.x + (Math.random() - 0.5) * 3,
                WATER_LEVEL + 1.5,
                window.boat.position.z + 8
            );
            
            // Déterminer le type de porte
            let doorSymbol = "symbol";
            if (doorType.includes("spirale")) {
                doorSymbol = "symbol";
            } else if (doorType.includes("rouge")) {
                doorSymbol = "blood";
            } else if (doorType.includes("griffes")) {
                doorSymbol = "claw";
            }
            
            // Créer la porte spéciale
            const door = createDoor(true);
            door.position.copy(doorPosition);
            door.rotation.x = Math.PI/2; // Parallèle à l'eau
            
            // Assigner le symbole spécifique
            door.userData.doorSymbol = doorSymbol;
            
            // S'assurer qu'elle contient un indice
            door.userData.containsClue = true;
            
            // Ajouter un indice non découvert
            const availableClues = STORY_ELEMENTS.clues.filter(
                clue => !window.discoveredClues.includes(clue.id)
            );
            
            if (availableClues.length > 0) {
                const randomClue = availableClues[Math.floor(Math.random() * availableClues.length)];
                door.userData.narrativeElement = {
                    type: "clue",
                    data: randomClue
                };
            }
            
            // Enregistrer la porte
            window.doors.push(door);
            window.scene.add(door);
            registerSpecialDoor(door);
            
            // Effet de matérialisation
            door.scale.set(0.1, 0.1, 0.1);
            
            // Animation d'apparition
            let scale = 0.1;
            const appearInterval = setInterval(() => {
                scale += 0.05;
                door.scale.set(scale, scale, scale);
                
                if (scale >= 1) {
                    clearInterval(appearInterval);
                    
                    // Effets visuels
                    flashLightEffect(0xaaffaa);
                    
                    // Attirer l'attention
                    door.traverse(child => {
                        if (child.isMesh && child.material) {
                            const originalColor = child.material.color.clone();
                            
                            // Faire pulser la couleur
                            let pulseTime = 0;
                            const pulseInterval = setInterval(() => {
                                pulseTime += 0.1;
                                
                                // Couleur pulsante
                                const pulseColor = new THREE.Color().copy(originalColor);
                                pulseColor.r += Math.sin(pulseTime * 5) * 0.3;
                                pulseColor.g += Math.sin(pulseTime * 5) * 0.3;
                                pulseColor.b += Math.sin(pulseTime * 5) * 0.3;
                                
                                child.material.color.copy(pulseColor);
                                
                                if (pulseTime > 3) {
                                    clearInterval(pulseInterval);
                                    child.material.color.copy(originalColor);
                                }
                            }, 50);
                        }
                    });
                }
            }, 50);
        }
        
        // ==========================================
        // FONCTIONS POUR LES PALIERS NARRATIFS
        // ==========================================
        
        // Débloquer le prologue
        function unlockPrologue(username) {
            showNarrativeMessage("Vous entrez dans les tunnels, ignorant ce qui vous attend...", 8000);
            
            // Ajouter des effets visuels subtils
            pulseLightEffect(0xaaffff, 3);
            
            // Ajuster l'ambiance
            window.scene.fog.density = 0.02;
            
            // Révéler le premier indice
            setTimeout(revealRandomClue, 5000);
        }
        
        // Débloquer le secteur 2
        function unlockSector2(username) {
            showNarrativeMessage("Les formes dans l'eau commencent à bouger avec intention...", 8000);
            
            // Effet visuel sur l'eau
            window.segments.forEach(segment => {
                if (segment.userData.water) {
                    // Changer la couleur de l'eau
                    segment.userData.water.material.color.set(0x005577);
                }
            });
            
            // Ajouter des ondulations à l'eau
            window.waterAnimation = true;
            
            // Déclencher un événement spécial
            setTimeout(spawnSpecialEntity, 3000);
        }
        
        // Débloquer le secteur 3
        function unlockSector3(username) {
            showNarrativeMessage("Des symboles étranges apparaissent sur les portes. Ils semblent former un motif...", 8000);
            
            // Ajouter des symboles à toutes les portes
            window.doors.forEach(door => {
                if (!door.userData.doorSymbol && Math.random() < 0.3) {
                    door.userData.doorSymbol = "symbol";
                    door.userData.symbolType = Math.floor(Math.random() * 5);
                    addSymbolToDoor(door, door.children.find(child => child.name === "plate" || child instanceof THREE.Mesh));
                }
            });
            
            // Lancer un vote
            setTimeout(startVote, 10000);
        }
        
        // Débloquer le secteur 4
        function unlockSector4(username) {
            showNarrativeMessage("L'eau vibre à intervalles réguliers, comme si quelque chose d'énorme se déplaçait en dessous...", 8000);
            
            // Créer un effet de tremblement périodique
            window.pulseInterval = setInterval(() => {
                cameraShakeEffect(0.3);
                
                // Sons de vibration
                console.log("Son: Vibration profonde");
                
                // Effet sur l'eau
                window.segments.forEach(segment => {
                    if (segment.userData.water) {
                        segment.userData.water.position.y = WATER_LEVEL + 0.1;
                        
                        setTimeout(() => {
                            segment.userData.water.position.y = WATER_LEVEL;
                        }, 300);
                    }
                });
            }, 15000);
            
            // Révéler plusieurs indices
            for (let i = 0; i < 2; i++) {
                setTimeout(revealRandomClue, 5000 + i * 15000);
            }
        }
        
        // Débloquer la confrontation mineure
        function unlockMinorEntity(username) {
            showNarrativeMessage("Une présence observe chacun de vos mouvements... Elle se rapproche...", 8000);
            
            // Créer l'entité observatrice
            const entityPosition = new THREE.Vector3(
                window.boat.position.x,
                WATER_LEVEL + 1,
                window.boat.position.z + 15
            );
            
            const observer = new THREE.Group();
            observer.position.copy(entityPosition);
            
            // Corps principal - silhouette sombre
            const bodyGeometry = new THREE.SphereGeometry(1, 16, 16);
            const bodyMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.7
            });
            
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.scale.set(1, 1.5, 1);
            observer.add(body);
            
            // Yeux brillants
            const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00
                // emissive et emissiveIntensity ne sont pas supportés par MeshBasicMaterial
            });
            
            // Trois yeux disposés en triangle
            const eyes = [];
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2;
                const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye.position.set(
                    Math.cos(angle) * 0.3,
                    0.5 + Math.sin(angle) * 0.3,
                    0.8
                );
                
                const eyeLight = new THREE.PointLight(0xffff00, 0.5, 2);
                eyeLight.position.set(0, 0, 0.1);
                eye.add(eyeLight);
                
                body.add(eye);
                eyes.push(eye);
            }
            
            // Animation
            observer.userData.update = (time) => {
                // Mouvement de flottement
                observer.position.y = WATER_LEVEL + 1 + Math.sin(time * 0.5) * 0.2;
                
                // Yeux clignotants
                eyes.forEach((eye, i) => {
                    eye.visible = Math.sin(time * 3 + i) > 0;
                });
                
                // L'observateur suit le bateau à distance
                const targetPosition = new THREE.Vector3(
                    window.boat.position.x,
                    observer.position.y,
                    window.boat.position.z + 15 + Math.sin(time) * 3
                );
                
                observer.position.x += (targetPosition.x - observer.position.x) * 0.01;
                observer.position.z += (targetPosition.z - observer.position.z) * 0.01;
                
                // Orientation vers le bateau
                observer.lookAt(window.boat.position);
            };
            
            // Ajouter à la scène
            window.scene.add(observer);
            window.mysteryElements[observer.uuid] = observer;
            
            // Message du donateur qui a débloqué cette entité
            if (username) {
                showNarrativeMessage(`L'Observateur a été invoqué par ${username}...`, 5000);
            }
            
            // L'observateur reste pendant longtemps
            setTimeout(() => {
                // Disparition
                let opacity = 0.7;
                const fadeInterval = setInterval(() => {
                    opacity -= 0.02;
                    
                    observer.traverse(child => {
                        if (child.material && child.material.opacity !== undefined) {
                            child.material.opacity = opacity;
                        }
                    });
                    
                    if (opacity <= 0) {
                        clearInterval(fadeInterval);
                        window.scene.remove(observer);
                        delete window.mysteryElements[observer.uuid];
                    }
                }, 100);
            }, 120000); // 2 minutes
        }
        
        // Débloquer le secteur 5
        function unlockSector5(username) {
            showNarrativeMessage("La réalité semble se distordre. Des portes mènent à des lieux impossibles...", 8000);
            
            // Effet de distorsion
            distortScreenEffect(3);
            
            // Modifier l'apparence du tunnel
            window.scene.fog.color.set(0x330033);
            window.scene.fog.density = 0.04;
            
            // Modifier la couleur des lumières
            window.scene.traverse(obj => {
                if (obj instanceof THREE.PointLight && obj !== window.boat.userData.lanternLight) {
                    obj.color.set(0xaa55ff);
                }
            });
            
            // Créer des portes spéciales
            setTimeout(() => {
                // Porte qui mène à une distorsion spatiale
                spawnSpecialDoor("spirale");
            }, 5000);
        }
        
        // Débloquer le secteur 6
        function unlockSector6(username) {
            showNarrativeMessage("Les indices commencent à former un schéma cohérent. La vérité se rapproche...", 8000);
            
            // Révéler plusieurs indices rapprochés
            for (let i = 0; i < 3; i++) {
                setTimeout(revealRandomClue, 2000 + i * 5000);
            }
            
            // Visualisation du schéma
            setTimeout(() => {
                // Créer une visualisation flottante des indices connectés
                const patternPosition = new THREE.Vector3(
                    window.boat.position.x,
                    WATER_LEVEL + 1.5,
                    window.boat.position.z + 8
                );
                
                const pattern = new THREE.Group();
                pattern.position.copy(patternPosition);
                
                // Cadre
                const frameGeometry = new THREE.TorusGeometry(1.5, 0.05, 16, 32);
                const frameMaterial = new THREE.MeshBasicMaterial({
                    color: 0xaaaaff,
                    transparent: true,
                    opacity: 0.8
                });
                
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                pattern.add(frame);
                
                // Points représentant les indices
                const points = [];
                const lines = [];
                
                for (let i = 0; i < window.discoveredClues.length; i++) {
                    const angle = (i / window.discoveredClues.length) * Math.PI * 2;
                    const radius = 1.2;
                    
                    const pointGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                    const pointMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff
                    });
                    
                    const point = new THREE.Mesh(pointGeometry, pointMaterial);
                    point.position.set(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius,
                        0
                    );
                    
                    pattern.add(point);
                    points.push(point);
                    
                    // Ajouter des lignes entre certains points
                    if (i > 0) {
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                            points[i-1].position,
                            point.position
                        ]);
                        
                        const lineMaterial = new THREE.LineBasicMaterial({
                            color: 0xaaaaff,
                            transparent: true,
                            opacity: 0.5
                        });
                        
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        pattern.add(line);
                        lines.push(line);
                    }
                }
                
                // Animation du pattern
                pattern.userData.update = (time) => {
                    // Rotation lente
                    pattern.rotation.z = time * 0.2;
                    
                    // Pulsation des points
                    points.forEach((point, i) => {
                        point.scale.setScalar(0.8 + Math.sin(time * 3 + i) * 0.3);
                    });
                    
                    // Opacité des lignes
                    lines.forEach((line, i) => {
                        line.material.opacity = 0.3 + Math.sin(time * 2 + i) * 0.2;
                    });
                };
                
                // Ajouter à la scène
                window.scene.add(pattern);
                window.mysteryElements[pattern.uuid] = pattern;
                
                // Faire disparaître après un moment
                setTimeout(() => {
                    // Animation de disparition
                    let opacity = 1;
                    let scale = 1;
                    
                    const fadeInterval = setInterval(() => {
                        opacity -= 0.02;
                        scale += 0.05;
                        
                        pattern.scale.set(scale, scale, scale);
                        
                        pattern.traverse(child => {
                            if (child.material && child.material.opacity !== undefined) {
                                child.material.opacity = opacity;
                            }
                        });
                        
                        if (opacity <= 0) {
                            clearInterval(fadeInterval);
                            window.scene.remove(pattern);
                            delete window.mysteryElements[pattern.uuid];
                        }
                    }, 50);
                }, 30000);
            }, 15000);
        }
        
        // Débloquer la confrontation majeure
        function unlockMajorEntity(username) {
            showNarrativeMessage("Une présence ancienne bloque votre chemin. Vous devez l'affronter pour continuer...", 8000);
            
            // Faire apparaître l'entité majeure
            setTimeout(() => {
                spawnBossEntity();
            }, 5000);
            
            // Message du donateur qui a débloqué cette entité
            if (username) {
                showNarrativeMessage(`Le Gardien a été provoqué par ${username}...`, 5000);
            }
        }
        
        // Débloquer le secteur 7
        function unlockSector7(username) {
            showNarrativeMessage("Les derniers fragments du mystère se dévoilent. La vérité est presque à portée...", 8000);
            
            // Effet visuel important
            flashLightEffect(0xffffff);
            distortScreenEffect(2);
            
            // Révéler tous les indices restants
            STORY_ELEMENTS.clues.forEach(clue => {
                if (!window.discoveredClues.includes(clue.id)) {
                    setTimeout(() => {
                        revealClue(clue);
                    }, Math.random() * 30000); // Étalé sur 30 secondes
                }
            });
            
            // Changement d'ambiance majeur
            window.scene.fog.color.set(0x220022);
            window.scene.fog.density = 0.03;
            
            window.scene.background = new THREE.Color(0x110011);
            
            // Modifier la couleur de l'eau
            window.segments.forEach(segment => {
                if (segment.userData.water) {
                    segment.userData.water.material.color.set(0x220044);
                }
            });
        }
        
        // Débloquer le finale
        function unlockFinale(username) {
            showNarrativeMessage("La vérité sur Les Profondeurs est sur le point d'être révélée...", 8000);
            
            // Compte à rebours dramatique
            countdownEffect(10, () => {
                // Effet final
                darkenEffect(3);
                
                setTimeout(() => {
                    // Lumière aveuglante
                    const finalLight = new THREE.PointLight(0xffffff, 10, 50);
                    finalLight.position.set(
                        window.boat.position.x,
                        window.boat.position.y + 3,
                        window.boat.position.z + 20
                    );
                    window.scene.add(finalLight);
                    
                    // Message final
                    const finalMessage = `
                        Les Profondeurs n'ont jamais été un lieu physique, mais une projection mentale collective.
                        
                        Chaque porte ouverte était une fenêtre vers une conscience différente.
                        
                        Le sixième cycle s'achève. Le prochain cycle commence...
                        
                        À suivre dans la Saison 2: "Les Résonances"
                    `;
                    
                    showNarrativeMessage(finalMessage, 20000);
                    
                    // Faire disparaître tout sauf le bateau
                    window.doors.forEach(door => {
                        window.scene.remove(door);
                    });
                    
                    Object.values(window.mysteryElements).forEach(element => {
                        window.scene.remove(element);
                    });
                    
                    // Animation finale
                    window.boatSpeed = 0.2;
                    
                    setTimeout(() => {
                        // Écran blanc
                        const whiteScreen = document.createElement('div');
                        whiteScreen.style.position = 'fixed';
                        whiteScreen.style.top = '0';
                        whiteScreen.style.left = '0';
                        whiteScreen.style.width = '100%';
                        whiteScreen.style.height = '100%';
                        whiteScreen.style.backgroundColor = 'white';
                        whiteScreen.style.opacity = '0';
                        whiteScreen.style.transition = 'opacity 5s';
                        whiteScreen.style.zIndex = '2000';
                        document.body.appendChild(whiteScreen);
                        
                        setTimeout(() => {
                            whiteScreen.style.opacity = '1';
                            
                            // Crédit de fin
                            setTimeout(() => {
                                whiteScreen.innerHTML = `
                                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: black; font-family: Arial, sans-serif;">
                                        <h1 style="font-size: 36px; margin-bottom: 50px;">Fin de la Saison 1</h1>
                                        <p style="font-size: 24px; margin-bottom: 20px;">Merci à tous les Explorateurs</p>
                                        <p style="font-size: 18px; margin-bottom: 10px;">Mystères résolus: ${window.solvedMysteries}/${STORY_ELEMENTS.mysteries.length}</p>
                                        <p style="font-size: 18px; margin-bottom: 10px;">Portes ouvertes: ${window.activatedDoors}</p>
                                        <p style="font-size: 18px; margin-bottom: 50px;">Total des dons: ${window.totalDonations} €</p>
                                        <p style="font-size: 24px;">Rendez-vous dans la Saison 2...</p>
                                    </div>
                                `;
                            }, 5000);
                        }, 100);
                    }, 10000);
                }, 3000);
            });
        }
        
        // ==========================================
        // BOUCLE D'ANIMATION
        // ==========================================
        
        // Mettre à jour les éléments mystérieux dans l'animation principale
        function updateMysteryElements(time) {
            // Limiter la mise à jour aux éléments visibles ou proches du bateau
            const maxDistance = TUNNEL_LENGTH / 2;  // Ne mettre à jour que les éléments à portée visuelle
            
            // Parcourir tous les éléments mystérieux pour les animer
            Object.values(window.mysteryElements).forEach(element => {
                // Vérifier si l'élément est proche du bateau
                if (element.position && window.boat.position) {
                    const dx = element.position.x - window.boat.position.x;
                    const dz = element.position.z - window.boat.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    // Ne mettre à jour que les éléments à portée
                    if (distance < maxDistance && element.userData.update) {
                        element.userData.update(time);
                    }
                } else if (element.userData.update) {
                    // Pour les éléments sans position (ex: effets globaux), mettre à jour normalement
                    element.userData.update(time);
                }
            });
            
            // Animation de l'eau - limiter aux segments visibles
            if (window.waterAnimation) {
                const boatZ = window.boat.position.z;
                window.segments.forEach(segment => {
                    // Ne mettre à jour que les segments proches du bateau
                    if (Math.abs(segment.userData.zPosition - boatZ) < maxDistance && segment.userData.water) {
                        segment.userData.water.material.color.lerp(
                            segment.userData.waterBaseColor, 
                            0.05
                        );
                        
                        // Ondulation légère
                        segment.userData.water.position.y = 
                            WATER_LEVEL + Math.sin(time * 2 + segment.position.z * 0.1) * 0.05;
                    }
                });
            }
            
            // Animation des lumières murales - limiter aux segments visibles
            window.segments.forEach(segment => {
                // Ne mettre à jour que les segments proches du bateau
                if (Math.abs(segment.userData.zPosition - window.boat.position.z) < maxDistance) {
                    segment.traverse(obj => {
                        if (obj.userData && obj.userData.flicker && obj.userData.light) {
                            const flickerAmount = Math.sin(time * obj.userData.flickerSpeed) * 0.3 + 0.7;
                            obj.userData.light.intensity = obj.userData.originalIntensity * flickerAmount;
                            
                            // Animation de couleur progressive (moins fréquente)
                            if (obj.userData.originalColor && window.frameCount % 6 === 0) {
                                const hue = (time * 0.05) % 1;
                                const newColor = new THREE.Color().setHSL(
                                    hue, 
                                    0.7, 
                                    obj.userData.originalColor.getHSL({}).l
                                );
                                
                                obj.userData.light.color.lerp(newColor, 0.01);
                                
                                if (obj.userData.bulb) {
                                    obj.userData.bulb.material.color.copy(obj.userData.light.color);
                                }
                            }
                        }
                    });
                }
            });
            
            // Animation narrative du bateau
            if (window.boat.userData.lanternLight) {
                const lanternFlicker = 0.8 + Math.sin(time * 5) * 0.2;
                window.boat.userData.lanternLight.intensity = window.boat.userData.lanternOriginalIntensity * lanternFlicker;
            }
        }
        
        // Fonction principale d'animation avec optimisation des performances
        function animate() {
            // Pour mesurer et limiter les performances
            if (!window.frameCounter) window.frameCounter = 0;
            window.frameCounter++;
            
            const currentTime = performance.now();
            if (!window.lastAnimationTime) window.lastAnimationTime = currentTime;
            const deltaTime = (currentTime - window.lastAnimationTime) / 1000; // en secondes
            window.lastAnimationTime = currentTime;
            
            // Limiter le deltaTime max pour éviter les sauts extrêmes
            const cappedDeltaTime = Math.min(deltaTime, 0.1);
            
            if (window.boat && window.camera && !window.isPaused) {
                // Mise à jour de la position du bateau
                if (window.boatTargetPosition) {
                    // Interpolation plus efficace
                    boatPosition.x += (window.boatTargetPosition.x - boatPosition.x) * Math.min(5 * cappedDeltaTime, 0.2);
                    boatPosition.z += (window.boatTargetPosition.z - boatPosition.z) * Math.min(5 * cappedDeltaTime, 0.2);
                    window.boat.position.set(boatPosition.x, boatPosition.y, boatPosition.z);
                }
                
                // Mise à jour moins fréquente du pitch/roll du bateau (économise des calculs)
                if (window.frameCounter % 3 === 0) {
                    // Rotation du bateau en fonction de la vitesse
                    if (window.boatTargetPosition && window.previousBoatPosition) {
                        const dx = boatPosition.x - window.previousBoatPosition.x;
                        const dz = boatPosition.z - window.previousBoatPosition.z;
                        
                        if (Math.abs(dx) > 0.001 || Math.abs(dz) > 0.001) {
                            const targetRotation = Math.atan2(dx, dz);
                            // Interpolation plus douce pour la rotation
                            window.boat.rotation.y += (targetRotation - window.boat.rotation.y) * Math.min(2 * cappedDeltaTime, 0.1);
                        }
                    }
                    
                    // Simuler le mouvement de la mer
                    if (window.canRock) {
                        window.boat.rotation.x = Math.sin(currentTime / 1000) * 0.03;
                        window.boat.rotation.z = Math.sin(currentTime / 1200) * 0.02;
                    }
                    
                    // Mettre à jour la position précédente
                    window.previousBoatPosition = { x: boatPosition.x, z: boatPosition.z };
                }
                
                // La caméra suit toujours le bateau à chaque frame pour une expérience fluide
                updateCameraPosition();
                
                // Mise à jour des mystères moins fréquente (économise beaucoup de calculs)
                if (window.frameCounter % 5 === 0) {
                    updateMysteryElements(); 
                }
                
                // Vérification de tunnel moins fréquente
                if (window.frameCounter % 10 === 0 && window.tunnelSegments) {
                    checkTunnel();
                }
                
                // Limiter la mise à jour du panneau de votes si présent
                if (window.votePanel && window.frameCounter % 30 === 0) {
                    updateVotePanel();
                }
            }
            
            // Rendre la scène
            if (window.renderer && window.scene && window.camera) {
                window.renderer.render(window.scene, window.camera);
            }
            
            // Appeler la prochaine frame
            requestAnimationFrame(animate);
        }
        
        // Fonction pour mettre à jour les éléments mystérieux (optimisée)
        function updateMysteryElements() {
            if (!window.mysteryElements || !window.boat) return;
            
            // Définir une distance maximale pour les mises à jour (optimisation importante)
            const maxDistance = 250; // Unités 3D
            const maxDistanceSquared = maxDistance * maxDistance;
            
            for (let i = 0; i < window.mysteryElements.length; i++) {
                const element = window.mysteryElements[i];
                if (!element || !element.mesh) continue;
                
                // Calculer la distance au carré (évite le calcul coûteux de racine carrée)
                const dx = element.mesh.position.x - window.boat.position.x;
                const dz = element.mesh.position.z - window.boat.position.z;
                const distanceSquared = dx * dx + dz * dz;
                
                // Ne mettre à jour que les éléments proches du bateau
                if (distanceSquared > maxDistanceSquared) {
                    // Si l'élément a une propriété visible, le cacher s'il est trop loin
                    if (element.mesh.visible) {
                        element.mesh.visible = false;
                    }
                    continue;
                } else if (!element.mesh.visible) {
                    // Rendre visible si on s'en rapproche
                    element.mesh.visible = true;
                }
                
                // Animation de l'eau (moins fréquente)
                if (element.type === 'water' && window.frameCounter % 10 === 0) {
                    const time = performance.now() / 1000;
                    element.mesh.position.y = Math.sin(time + i) * 0.2 - 0.5;
                }
                
                // Animation de certains objets
                if (element.type === 'apparition') {
                    // Animation plus simple
                    const time = performance.now() / 1000;
                    element.mesh.rotation.y += 0.01;
                    element.mesh.position.y = Math.sin(time) * 0.5 + element.initialY;
                } else if (element.type === 'wallLight' && window.frameCounter % 15 === 0) {
                    // Animation moins fréquente pour les lumières
                    const intensity = 0.5 + Math.sin(performance.now() / 500) * 0.5;
                    if (element.light) {
                        element.light.intensity = intensity;
                    }
                }
            }
            
            // Animation des segments de tunnel (moins fréquente et seulement pour les segments proches)
            if (window.tunnelSegments) {
                for (let i = 0; i < window.tunnelSegments.length; i++) {
                    const segment = window.tunnelSegments[i];
                    if (!segment.mesh) continue;
                    
                    // Calculer la distance
                    const dx = segment.mesh.position.x - window.boat.position.x;
                    const dz = segment.mesh.position.z - window.boat.position.z;
                    const distanceSquared = dx * dx + dz * dz;
                    
                    // Ne traiter que les segments proches
                    if (distanceSquared > maxDistanceSquared) continue;
                    
                    // Animation réduite et moins fréquente
                    if (window.frameCounter % 20 === 0 && segment.lights) {
                        for (let j = 0; j < segment.lights.length; j++) {
                            const light = segment.lights[j];
                            if (light) {
                                // Animation simplifiée
                                const intensity = 0.7 + Math.sin(performance.now() / 1000 + j * 0.5) * 0.3;
                                light.intensity = intensity;
                            }
                        }
                    }
                }
            }
        }
        
        // ==========================================
        // INITIALISATION DE L'APPLICATION
        // ==========================================
        
        // Vérifier si Three.js est disponible et initialiser l'application
        window.onload = function() {
            if (typeof THREE === 'undefined') {
                document.getElementById('loading').innerHTML = 
                    "<h1>Erreur</h1><p>Impossible de charger Three.js. " +
                    "Vérifiez votre connexion internet ou essayez un autre navigateur.</p>";
                return;
            }
            
            // Simuler le chargement
            simulateLoading();
            
            // Initialiser l'application après un délai pour l'écran de chargement
            setTimeout(init, 3000);
        };
        
        // ==========================================
        // LEADERBOARD & HISTORIQUE
        // ==========================================
        
        // Initialiser les structures de données
        window.leaderboard = [];
        window.storyHistory = [];
        
        // Mettre à jour le leaderboard
        function updateLeaderboard(username, amount) {
            // Assurez-vous que le tableau des donateurs existe
            if (!window.leaderboard) {
                window.leaderboard = [];
            }
            
            // Vérifier si l'utilisateur existe déjà dans le classement
            let userExists = false;
            for (let i = 0; i < window.leaderboard.length; i++) {
                if (window.leaderboard[i].username === username) {
                    // Mettre à jour le montant
                    window.leaderboard[i].amount += amount;
                    userExists = true;
                    break;
                }
            }
            
            // Si l'utilisateur n'existe pas, l'ajouter
            if (!userExists) {
                window.leaderboard.push({
                    username: username,
                    amount: amount
                });
            }
            
            // Trier le classement par montant décroissant
            window.leaderboard.sort((a, b) => b.amount - a.amount);
            
            // Conserver uniquement les 10 premiers
            if (window.leaderboard.length > 10) {
                window.leaderboard = window.leaderboard.slice(0, 10);
            }
            
            // Afficher le classement
            renderLeaderboard();
            
            // S'assurer que le tableau est visible
            const leaderboardPanel = document.getElementById('leaderboard-panel');
            if (leaderboardPanel.style.display === 'none' || !leaderboardPanel.style.display) {
                leaderboardPanel.style.display = 'block';
            }
        }
        
        // Afficher le leaderboard
        function renderLeaderboard() {
            const leaderboardList = document.getElementById('leaderboard-list');
            if (!leaderboardList) return;
            
            leaderboardList.innerHTML = '';
            
            if (!window.leaderboard || window.leaderboard.length === 0) {
                leaderboardList.innerHTML = '<div class="leaderboard-item">Aucun donateur</div>';
                return;
            }
            
            window.leaderboard.forEach((entry, index) => {
                const itemEl = document.createElement('div');
                itemEl.className = 'leaderboard-item';
                
                const rankEl = document.createElement('div');
                rankEl.className = 'leaderboard-rank';
                rankEl.textContent = `${index + 1}.`;
                
                const nameEl = document.createElement('div');
                nameEl.className = 'leaderboard-name';
                nameEl.textContent = entry.username;
                
                const scoreEl = document.createElement('div');
                scoreEl.className = 'leaderboard-score';
                scoreEl.textContent = `${entry.amount}€`;
                
                itemEl.appendChild(rankEl);
                itemEl.appendChild(nameEl);
                itemEl.appendChild(scoreEl);
                
                leaderboardList.appendChild(itemEl);
            });
        }
        
        // Ajouter une entrée à l'historique
        function addToStoryHistory(type, content) {
            if (!window.storyHistory) {
                window.storyHistory = [];
            }
            
            // Vérification stricte des doublons - éviter de traiter des messages identiques
            const isDuplicate = window.storyHistory.some(entry => 
                entry.content === content && 
                (Date.now() - entry.rawTimestamp) < 30000 // 30 secondes pour être sûr
            );
            
            if (isDuplicate) return;
            
            const now = new Date();
            const entry = {
                type: type,
                content: content,
                timestamp: now.toLocaleTimeString(),
                rawTimestamp: Date.now()
            };
            
            window.storyHistory.unshift(entry);
            
            // Limiter la taille pour éviter trop de DOM et de mémoire
            if (window.storyHistory.length > 20) { // Réduit de 30 à 20
                window.storyHistory = window.storyHistory.slice(0, 20);
            }
            
            // Optimisation: ne pas rendre le contenu à chaque fois, mais limiter la fréquence
            if (!window.historyRenderTimeout) {
                window.historyRenderTimeout = setTimeout(() => {
                    renderStoryHistory();
                    window.historyRenderTimeout = null;
                }, 500); // Regrouper les mises à jour en un seul rendu toutes les 500ms
            }
            
            // S'assurer que le panneau est visible
            const historyPanel = document.getElementById('story-history-panel');
            if (historyPanel.style.display === 'none' || !historyPanel.style.display) {
                historyPanel.style.display = 'block';
            }
        }
        
        // Afficher l'historique
        function renderStoryHistory() {
            const historyList = document.getElementById('story-history-list');
            if (!historyList) return;
            
            historyList.innerHTML = '';
            
            if (!window.storyHistory || window.storyHistory.length === 0) {
                historyList.innerHTML = '<div class="history-item">Aucun événement enregistré</div>';
                return;
            }
            
            // En-têtes pour les types d'entrées
            const typeLabels = {
                'milestone': '📜 Progression',
                'discovery': '🔍 Découverte',
                'event': '⚡ Événement'
            };
            
            window.storyHistory.forEach(entry => {
                const item = document.createElement('div');
                item.className = `history-item history-item-${entry.type}`;
                
                const timestamp = document.createElement('div');
                timestamp.className = 'history-timestamp';
                timestamp.textContent = entry.timestamp;
                
                const typeLabel = document.createElement('div');
                typeLabel.style.fontWeight = 'bold';
                typeLabel.style.fontSize = '10px';
                typeLabel.style.marginBottom = '2px';
                typeLabel.textContent = typeLabels[entry.type] || 'Message';
                
                const content = document.createElement('div');
                content.textContent = entry.content;
                
                item.appendChild(timestamp);
                item.appendChild(typeLabel);
                item.appendChild(content);
                
                historyList.appendChild(item);
            });
        }
        
        // Modifier les fonctions existantes pour enregistrer dans l'historique
        
        // Surcharger la fonction originale pour ajouter l'entrée au tableau
        const originalUnlockNextMilestone = unlockNextMilestone;
        unlockNextMilestone = function(username) {
            originalUnlockNextMilestone(username);
            
            const milestone = STORY_MILESTONES[window.currentMilestoneIndex];
            addToStoryHistory('milestone', `[${milestone.title}] ${milestone.description}`);
        };
        
        // Surcharger la fonction de révélation d'indice
        const originalRevealClue = revealClue;
        revealClue = function(clue) {
            originalRevealClue(clue);
            addToStoryHistory('discovery', `Indice découvert: ${clue.text}`);
        };
        
        // Surcharger la fonction d'événements spéciaux
        const originalTriggerSpecialEvent = triggerSpecialEvent;
        triggerSpecialEvent = function() {
            const eventType = Math.floor(Math.random() * 5);
            const eventNames = [
                "Apparition mystérieuse", 
                "Blackout soudain", 
                "Distorsion de réalité",
                "Porte qui s'ouvre",
                "Vote communautaire"
            ];
            
            addToStoryHistory('event', `Événement: ${eventNames[eventType]}`);
            return originalTriggerSpecialEvent();
        };
        
        // Modifier la fonction simulateDonation pour mettre à jour le leaderboard
        const originalSimulateDonation = simulateDonation;
        simulateDonation = function(username, amount) {
            originalSimulateDonation(username, amount);
            updateLeaderboard(username, amount);
        };
        
        // Fonction pour vérifier les dons externes (via localStorage)
        function checkExternalDonations() {
            const latestDonation = localStorage.getItem('latestDonation');
            if (latestDonation) {
                try {
                    const donation = JSON.parse(latestDonation);
                    // Vérifier si c'est une nouvelle donation (en utilisant le timestamp)
                    const lastProcessedDonation = localStorage.getItem('lastProcessedDonation') || '0';
                    
                    if (donation.timestamp > parseInt(lastProcessedDonation)) {
                        // Traiter la donation
                        simulateDonation(donation.username, donation.amount);
                        // Marquer comme traitée
                        localStorage.setItem('lastProcessedDonation', donation.timestamp.toString());
                    }
                } catch (e) {
                    console.error("Erreur lors du traitement d'une donation externe:", e);
                }
            }
        }
        
        // Écouter les messages du simulateur de dons externe
        window.addEventListener('message', function(event) {
            // Vérification de sécurité (si nécessaire, vérifiez l'origine)
            if (event.data && event.data.type === 'donation') {
                const donation = event.data.data;
                simulateDonation(donation.username, donation.amount);
            }
        });
        
        // Vérifier périodiquement les dons externes
        setInterval(checkExternalDonations, 2000);
        
        // Ajouter le gestionnaire pour ouvrir le simulateur de dons
        const openDonationSimulatorBtn = document.getElementById('open-donation-simulator');
        if (openDonationSimulatorBtn) {
            openDonationSimulatorBtn.addEventListener('click', function() {
                window.open('donation_simulator.html', 'DonationSimulator', 'width=550,height=600');
            });
        }
    </script>

    <div id="leaderboard-panel">
        <h3>Classement des Explorateurs</h3>
        <div id="leaderboard-list">
            <!-- Le classement sera ajouté ici dynamiquement -->
        </div>
    </div>

    <div id="story-history-panel">
        <h3>Journal des Messages</h3>
        <div id="story-history-list">
            <!-- L'historique sera ajouté ici dynamiquement -->
        </div>
    </div>
    
    <!-- Espace réservé pour la future implémentation de la caméra -->
    <div class="camera-space"></div>
</body>
</html>