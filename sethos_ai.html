<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TikTok Horror Experience - Saison 1: Les Profondeurs</title>
    <!-- Scripts de correctifs unifi√©s -->
    <script src="js-unified/unified_fixes.js"></script>
    <!-- Styles unifi√©s -->
    <link rel="stylesheet" href="css-unified/unified_styles.css">
    <!-- Socket.IO Version 4.5.4 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.4/socket.io.min.js"></script>
    <!-- Module Socket.IO unifi√© -->
    <script src="js-unified/unified_socket.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
        
        #loading { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: #000; 
            color: #fff; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            z-index: 1000;
        }
        
        #debug {
            position: fixed; 
            top: 10px; 
            left: 10px; 
            z-index: 10;
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px;
            border-radius: 5px;
        }
        
        #donation-panel {
            position: fixed;
            right: 10px;
            top: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 180px;
            font-size: 11px;
            display: none; /* Hide donation panel as requested */
        }
        
        #donation-panel h3 {
            margin-top: 0;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 40px; /* D√©plac√© plus bas pour √©viter le chevauchement */
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            max-width: 400px;
            z-index: 900;
        }
        
        .progress-bar {
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            margin-bottom: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9900);
            width: 0%;
            transition: width 1s ease-in-out;
        }
        
        #story-milestone {
            position: fixed;
            top: 80px; /* D√©plac√© encore plus bas */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 12px;
            z-index: 900;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
            padding: 5px 10px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            width: 40%;
            max-width: 400px;
            line-height: 1.3;
            display: none; /* Cach√© par d√©faut, sera affich√© dans le journal uniquement */
        }
        
        #donor-wall {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Align√© avec le journal d'exploration */
            max-height: 130px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Cach√© car remplac√© par top100 */
        }
        
        #top100-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* En bas de l'√©cran, directement sous le journal */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px;
            max-height: 150px;
            overflow: hidden;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Cach√© car remplac√© par leaderboard-panel */
        }
        
        #top100-panel h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 13px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .top100-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
            position: relative;
        }
        
        .top100-rank {
            width: 20px;
            text-align: center;
            color: #aaa;
        }
        
        .top100-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .top100-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #narrative-display {
            position: fixed;
            top: 50%; /* Centr√© verticalement */
            left: 50%;
            transform: translate(-50%, -50%); /* Centrage parfait */
            z-index: 950;
            color: white;
            text-align: center;
            width: 70%;
            max-width: 600px;
            text-shadow: 0 0 3px black, 0 0 5px black;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Fond plus opaque pour meilleure lisibilit√© */
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none; /* Pour √©viter d'interf√©rer avec les clics */
        }
        
        #narrative-display.visible {
            opacity: 0.95;
        }
        
        #clue-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 950;
            color: #ffcc00;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 3px solid #ffcc00;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease-out;
        }
        
        #clue-notification.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #event-counter {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            color: white;
            font-size: 120px;
            text-shadow: 0 0 20px red;
            opacity: 0;
            transition: all 0.3s ease-in-out;
            pointer-events: none;
        }
        
        #event-counter.visible {
            opacity: 1;
        }
        
        button, input { 
            margin: 5px 0; 
            display: block;
            border: none;
            background: #444;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #666;
        }
        
        #sim-donation {
            margin-top: 15px;
            width: 100%;
        }
        
        #vote-panel {
            position: fixed;
            right: 10px;
            bottom: 10px; /* En bas √† droite */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 160px;
            font-size: 10px;
            display: none;
        }
        
        .vote-option {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .vote-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .vote-bar {
            height: 5px;
            width: 100%;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .vote-fill {
            height: 100%;
            background: linear-gradient(90deg, #77ccff, #4488ff);
            width: 30%;
        }
        
        /* Animation pour les effects */
        @keyframes pulse {
            0% { opacity: 0.2; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.2; transform: scale(0.95); }
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        #leaderboard-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* Repositionn√© en bas sous le journal */
            top: auto; /* Annule la position top pr√©c√©dente */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 200px;
            max-height: 145px; /* Hauteur r√©duite pour √©viter le chevauchement (√©tait √† 150px) */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #leaderboard-panel h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #aaa;
            width: 20px;
            text-align: center;
        }
        
        .leaderboard-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .leaderboard-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #story-history-panel {
            position: fixed;
            left: 10px;
            bottom: 175px; /* Remont√© plus haut pour √©viter le chevauchement (√©tait √† 70px) */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* √âlargi pour mieux afficher les messages */
            max-height: 180px; /* L√©g√®rement plus grand */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #story-history-panel h3 {
            margin-top: 0;
            margin-bottom: 3px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .history-item {
            margin-bottom: 4px;
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .history-item-milestone {
            background-color: rgba(255, 204, 0, 0.2);
            border-left: 2px solid #ffcc00;
        }
        
        .history-item-discovery {
            background-color: rgba(119, 204, 255, 0.2);
            border-left: 2px solid #77ccff;
        }
        
        .history-item-event {
            background-color: rgba(255, 102, 102, 0.2);
            border-left: 2px solid #ff6666;
        }
        
        .history-timestamp {
            color: #aaa;
            font-size: 8px;
            margin-bottom: 2px;
            font-style: italic;
        }
        
        /* Style pour r√©server l'espace pour la cam√©ra */
        .camera-space {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 100px;
            z-index: 800;
            /* Background comment√© - juste pour visualiser l'espace r√©serv√© 
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            */
        }
        
        /* Assurons-nous que tous les panneaux ont une apparence coh√©rente */
        #leaderboard-panel, #story-history-panel, #vote-panel, #donor-wall {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.85; /* L√©g√®rement transparent pour voir le bateau derri√®re */
        }
        
        /* Animation de d√©filement automatique pour les panneaux */
        @keyframes autoscroll {
            0% { transform: translateY(0); }
            45% { transform: translateY(calc(-100% + 100px)); }
            55% { transform: translateY(calc(-100% + 100px)); } /* Pause au bas pendant 10% de l'animation */
            57% { transform: translateY(0); } /* Retour tr√®s rapide au d√©but (2% de l'animation) */
            100% { transform: translateY(0); } /* Pause au d√©but avant de recommencer */
        }
        
        .autoscroll-container {
            height: 100%;
            overflow: hidden;
            position: relative;
            max-height: inherit;
        }
        
        .autoscroll-content {
            animation: autoscroll 60s linear infinite; /* Remis √† "infinite" pour boucler */
            animation-play-state: running;
            padding-bottom: 20px; /* Add space at the bottom before repeating */
        }
        
        .autoscroll-content:hover {
            animation-play-state: paused;
        }
        
        /* Objectifs sur la barre en haut */
        #objectives-panel {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            display: flex;
            gap: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .objective {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .objective-icon {
            color: #ffcc00;
            font-size: 14px;
        }
        
        .objective-text {
            white-space: nowrap;
        }
        
        /* 
        Organisation des panneaux :
        - Haut: Objectifs
        - Droite: Progression narrative 
        - √Ä gauche milieu: Journal d'exploration
        - √Ä gauche bas: Classement des explorateurs
        - En bas √† droite: Panneau de vote
        - Centre haut (ajust√©): Barre de progression
        - Centre bas: Affichage narratif
        */
        
        /* Hover effect pour rendre les panneaux plus lisibles au survol */
        #leaderboard-panel:hover, #story-history-panel:hover, #donation-panel:hover, #vote-panel:hover, #donor-wall:hover {
            opacity: 0.95;
            z-index: 950; /* Augmente le z-index au survol pour s'assurer qu'il est au-dessus des autres */
        }
        
        /* Style pour les titres des panneaux */
        #leaderboard-panel h3, #story-history-panel h3, #donor-wall h4 {
            color: #ffcc00;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        #details-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 950;
            background: rgba(0,0,0,0.7);
            color: #ffcc00;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid rgba(255, 204, 0, 0.3);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            display: none; /* Cacher le bouton des d√©tails d'exploration */
        }
        
        #details-button:hover {
            background: rgba(50,50,0,0.7);
            border-color: rgba(255, 204, 0, 0.6);
        }
        
        /* Overlay d'authentification */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #33ff33;
            font-family: 'Courier New', monospace;
        }
        
        .auth-content {
            text-align: center;
            max-width: 500px;
            padding: 20px;
        }
        
        .auth-logo {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
        }
        
        .auth-message {
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        .auth-warning {
            color: #ff3333;
            margin-top: 20px;
            font-size: 12px;
            max-width: 80%;
            text-align: justify;
        }
        
        .donation-progress-container {
            width: 300px;
            margin: 0 auto;
        }
        
        .donation-label {
            color: #fff;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .donation-bar {
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #ff3366;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        #auth-donation-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff3366, #ff6699);
            transition: width 0.5s ease-in-out;
        }
        
        .auth-gauge {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .auth-gauge h3 {
            margin-top: 0;
            font-size: 14px;
            color: #ffcc00;
        }
        
        .tiktok-integration-notice {
            font-size: 12px;
            color: #ccc;
        }
        
        /* Notifications d'authentification */
        .auth-notification {
            position: fixed;
            right: -300px;
            top: 100px;
            background: linear-gradient(90deg, #330033, #5a0057);
            border-left: 3px solid #ff3366;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            padding: 15px;
            width: 250px;
            border-radius: 5px 0 0 5px;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .auth-notification.show {
            right: 0;
        }
        
        .auth-username {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .auth-amount {
            color: #ff3366;
            font-weight: bold;
            font-size: 18px;
        }
        
        /* Statut du syst√®me */
        .system-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #33ff33;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #ff3333;
        }
        
        .status-indicator.online {
            background-color: #33ff33;
        }
        
        /* Animation de pulsation pour la jauge */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .auth-gauge.pulse {
            animation: pulse 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
    <!-- Inclure les fichiers externes pour la gestion de l'authentification -->
    <script src="auth_gauge.js"></script>
    <script>
        // Utiliser la valeur de REQUIRED_AMOUNT d√©finie dans auth_gauge.js
        // au lieu de red√©clarer cette variable
        document.addEventListener('DOMContentLoaded', function() {
            // V√©rifier la connexion aux √©v√©nements story
            if (typeof setupStoryEventHandlers === 'function') {
                console.log('üü† SETHOS - Initialisation des gestionnaires d\'√©v√©nements story');
                setupStoryEventHandlers();
                
                // V√©rifier imm√©diatement les mises √† jour
                if (typeof checkServerUpdates === 'function') {
                    setTimeout(checkServerUpdates, 1000);
                }
            }
        });
    </script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TikTok Horror Experience - Saison 1: Les Profondeurs</title>
    <link rel="stylesheet" href="responsive.css">
    <link rel="stylesheet" href="auth_gauge.css">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
        
        #loading { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: #000; 
            color: #fff; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            z-index: 1000;
        }
        
        #debug {
            position: fixed; 
            top: 10px; 
            left: 10px; 
            z-index: 10;
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px;
            border-radius: 5px;
        }
        
        #donation-panel {
            position: fixed;
            right: 10px;
            top: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 180px;
            font-size: 11px;
            display: none; /* Hide donation panel as requested */
        }
        
        #donation-panel h3 {
            margin-top: 0;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 40px; /* D√©plac√© plus bas pour √©viter le chevauchement */
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            max-width: 400px;
            z-index: 900;
        }
        
        .progress-bar {
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            margin-bottom: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9900);
            width: 0%;
            transition: width 1s ease-in-out;
        }
        
        #story-milestone {
            position: fixed;
            top: 80px; /* D√©plac√© encore plus bas */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 12px;
            z-index: 900;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
            padding: 5px 10px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            width: 40%;
            max-width: 400px;
            line-height: 1.3;
            display: none; /* Cach√© par d√©faut, sera affich√© dans le journal uniquement */
        }
        
        #donor-wall {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Align√© avec le journal d'exploration */
            max-height: 130px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Cach√© car remplac√© par top100 */
        }
        
        #top100-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* En bas de l'√©cran, directement sous le journal */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px;
            max-height: 150px;
            overflow: hidden;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Cach√© car remplac√© par leaderboard-panel */
        }
        
        #top100-panel h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 13px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .top100-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
            position: relative;
        }
        
        .top100-rank {
            width: 20px;
            text-align: center;
            color: #aaa;
        }
        
        .top100-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .top100-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #narrative-display {
            position: fixed;
            top: 50%; /* Centr√© verticalement */
            left: 50%;
            transform: translate(-50%, -50%); /* Centrage parfait */
            z-index: 950;
            color: white;
            text-align: center;
            width: 70%;
            max-width: 600px;
            text-shadow: 0 0 3px black, 0 0 5px black;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Fond plus opaque pour meilleure lisibilit√© */
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none; /* Pour √©viter d'interf√©rer avec les clics */
        }
        
        #narrative-display.visible {
            opacity: 0.95;
        }
        
        #clue-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 950;
            color: #ffcc00;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 3px solid #ffcc00;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease-out;
        }
        
        #clue-notification.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #event-counter {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            color: white;
            font-size: 120px;
            text-shadow: 0 0 20px red;
            opacity: 0;
            transition: all 0.3s ease-in-out;
            pointer-events: none;
        }
        
        #event-counter.visible {
            opacity: 1;
        }
        
        button, input { 
            margin: 5px 0; 
            display: block;
            border: none;
            background: #444;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #666;
        }
        
        #sim-donation {
            margin-top: 15px;
            width: 100%;
        }
        
        #vote-panel {
            position: fixed;
            right: 10px;
            bottom: 10px; /* En bas √† droite */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 160px;
            font-size: 10px;
            display: none;
        }
        
        .vote-option {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .vote-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .vote-bar {
            height: 5px;
            width: 100%;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .vote-fill {
            height: 100%;
            background: linear-gradient(90deg, #77ccff, #4488ff);
            width: 30%;
        }
        
        /* Animation pour les effects */
        @keyframes pulse {
            0% { opacity: 0.2; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.2; transform: scale(0.95); }
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        #leaderboard-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* Repositionn√© en bas sous le journal */
            top: auto; /* Annule la position top pr√©c√©dente */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 200px;
            max-height: 145px; /* Hauteur r√©duite pour √©viter le chevauchement (√©tait √† 150px) */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #leaderboard-panel h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #aaa;
            width: 20px;
            text-align: center;
        }
        
        .leaderboard-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .leaderboard-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #story-history-panel {
            position: fixed;
            left: 10px;
            bottom: 175px; /* Remont√© plus haut pour √©viter le chevauchement (√©tait √† 70px) */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* √âlargi pour mieux afficher les messages */
            max-height: 180px; /* L√©g√®rement plus grand */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #story-history-panel h3 {
            margin-top: 0;
            margin-bottom: 3px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .history-item {
            margin-bottom: 4px;
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .history-item-milestone {
            background-color: rgba(255, 204, 0, 0.2);
            border-left: 2px solid #ffcc00;
        }
        
        .history-item-discovery {
            background-color: rgba(119, 204, 255, 0.2);
            border-left: 2px solid #77ccff;
        }
        
        .history-item-event {
            background-color: rgba(255, 102, 102, 0.2);
            border-left: 2px solid #ff6666;
        }
        
        .history-timestamp {
            color: #aaa;
            font-size: 8px;
            margin-bottom: 2px;
            font-style: italic;
        }
        
        /* Style pour r√©server l'espace pour la cam√©ra */
        .camera-space {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 100px;
            z-index: 800;
            /* Background comment√© - juste pour visualiser l'espace r√©serv√© 
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            */
        }
        
        /* Assurons-nous que tous les panneaux ont une apparence coh√©rente */
        #leaderboard-panel, #story-history-panel, #vote-panel, #donor-wall {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.85; /* L√©g√®rement transparent pour voir le bateau derri√®re */
        }
        
        /* Animation de d√©filement automatique pour les panneaux */
        @keyframes autoscroll {
            0% { transform: translateY(0); }
            45% { transform: translateY(calc(-100% + 100px)); }
            55% { transform: translateY(calc(-100% + 100px)); } /* Pause au bas pendant 10% de l'animation */
            57% { transform: translateY(0); } /* Retour tr√®s rapide au d√©but (2% de l'animation) */
            100% { transform: translateY(0); } /* Pause au d√©but avant de recommencer */
        }
        
        .autoscroll-container {
            height: 100%;
            overflow: hidden;
            position: relative;
            max-height: inherit;
        }
        
        .autoscroll-content {
            animation: autoscroll 60s linear infinite; /* Remis √† "infinite" pour boucler */
            animation-play-state: running;
            padding-bottom: 20px; /* Add space at the bottom before repeating */
        }
        
        .autoscroll-content:hover {
            animation-play-state: paused;
        }
        
        /* Objectifs sur la barre en haut */
        #objectives-panel {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            display: flex;
            gap: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .objective {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .objective-icon {
            color: #ffcc00;
            font-size: 14px;
        }
        
        .objective-text {
            white-space: nowrap;
        }
        
        /* 
        Organisation des panneaux :
        - Haut: Objectifs
        - Droite: Progression narrative 
        - √Ä gauche milieu: Journal d'exploration
        - √Ä gauche bas: Classement des explorateurs
        - En bas √† droite: Panneau de vote
        - Centre haut (ajust√©): Barre de progression
        - Centre bas: Affichage narratif
        */
        
        /* Hover effect pour rendre les panneaux plus lisibles au survol */
        #leaderboard-panel:hover, #story-history-panel:hover, #donation-panel:hover, #vote-panel:hover, #donor-wall:hover {
            opacity: 0.95;
            z-index: 950; /* Augmente le z-index au survol pour s'assurer qu'il est au-dessus des autres */
        }
        
        /* Style pour les titres des panneaux */
        #leaderboard-panel h3, #story-history-panel h3, #donor-wall h4 {
            color: #ffcc00;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        #details-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 950;
            background: rgba(0,0,0,0.7);
            color: #ffcc00;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid rgba(255, 204, 0, 0.3);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            display: none; /* Cacher le bouton des d√©tails d'exploration */
        }
        
        #details-button:hover {
            background: rgba(50,50,0,0.7);
            border-color: rgba(255, 204, 0, 0.6);
        }
        
        /* Overlay d'authentification */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #33ff33;
            font-family: 'Courier New', monospace;
        }
        
        .auth-content {
            text-align: center;
            max-width: 500px;
            padding: 20px;
        }
        
        .auth-logo {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
        }
        
        .auth-message {
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        .auth-warning {
            color: #ff3333;
            margin-top: 20px;
            font-size: 12px;
            max-width: 80%;
            text-align: justify;
        }
        
        .donation-progress-container {
            width: 300px;
            margin: 0 auto;
        }
        
        .donation-label {
            color: #fff;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .donation-bar {
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #ff3366;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        #auth-donation-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff3366, #ff6699);
            transition: width 0.5s ease-in-out;
        }
        
        .auth-gauge {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .auth-gauge h3 {
            margin-top: 0;
            font-size: 14px;
            color: #ffcc00;
        }
        
        .tiktok-integration-notice {
            font-size: 12px;
            color: #ccc;
        }
        
        /* Notifications d'authentification */
        .auth-notification {
            position: fixed;
            right: -300px;
            top: 100px;
            background: linear-gradient(90deg, #330033, #5a0057);
            border-left: 3px solid #ff3366;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            padding: 15px;
            width: 250px;
            border-radius: 5px 0 0 5px;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .auth-notification.show {
            right: 0;
        }
        
        .auth-username {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .auth-amount {
            color: #ff3366;
            font-weight: bold;
            font-size: 18px;
        }
        
        /* Statut du syst√®me */
        .system-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #33ff33;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #ff3333;
        }
        
        .status-indicator.online {
            background-color: #33ff33;
        }
        
        /* Animation de pulsation pour la jauge */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .auth-gauge.pulse {
            animation: pulse 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
</head>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TikTok Horror Experience - Saison 1: Les Profondeurs</title>
    <link rel="stylesheet" href="responsive.css">
    <link rel="stylesheet" href="auth_gauge.css">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
        
        #loading { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: #000; 
            color: #fff; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            z-index: 1000;
        }
        
        #debug {
            position: fixed; 
            top: 10px; 
            left: 10px; 
            z-index: 10;
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px;
            border-radius: 5px;
        }
        
        #donation-panel {
            position: fixed;
            right: 10px;
            top: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 180px;
            font-size: 11px;
            display: none; /* Hide donation panel as requested */
        }
        
        #donation-panel h3 {
            margin-top: 0;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 40px; /* D√©plac√© plus bas pour √©viter le chevauchement */
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            max-width: 400px;
            z-index: 900;
        }
        
        .progress-bar {
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            margin-bottom: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9900);
            width: 0%;
            transition: width 1s ease-in-out;
        }
        
        #story-milestone {
            position: fixed;
            top: 80px; /* D√©plac√© encore plus bas */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 12px;
            z-index: 900;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
            padding: 5px 10px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            width: 40%;
            max-width: 400px;
            line-height: 1.3;
            display: none; /* Cach√© par d√©faut, sera affich√© dans le journal uniquement */
        }
        
        #donor-wall {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Align√© avec le journal d'exploration */
            max-height: 130px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Cach√© car remplac√© par top100 */
        }
        
        #top100-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* En bas de l'√©cran, directement sous le journal */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px;
            max-height: 150px;
            overflow: hidden;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Cach√© car remplac√© par leaderboard-panel */
        }
        
        #top100-panel h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 13px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .top100-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
            position: relative;
        }
        
        .top100-rank {
            width: 20px;
            text-align: center;
            color: #aaa;
        }
        
        .top100-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .top100-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #narrative-display {
            position: fixed;
            top: 50%; /* Centr√© verticalement */
            left: 50%;
            transform: translate(-50%, -50%); /* Centrage parfait */
            z-index: 950;
            color: white;
            text-align: center;
            width: 70%;
            max-width: 600px;
            text-shadow: 0 0 3px black, 0 0 5px black;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Fond plus opaque pour meilleure lisibilit√© */
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none; /* Pour √©viter d'interf√©rer avec les clics */
        }
        
        #narrative-display.visible {
            opacity: 0.95;
        }
        
        #clue-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 950;
            color: #ffcc00;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 3px solid #ffcc00;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease-out;
        }
        
        #clue-notification.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #event-counter {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            color: white;
            font-size: 120px;
            text-shadow: 0 0 20px red;
            opacity: 0;
            transition: all 0.3s ease-in-out;
            pointer-events: none;
        }
        
        #event-counter.visible {
            opacity: 1;
        }
        
        button, input { 
            margin: 5px 0; 
            display: block;
            border: none;
            background: #444;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #666;
        }
        
        #sim-donation {
            margin-top: 15px;
            width: 100%;
        }
        
        #vote-panel {
            position: fixed;
            right: 10px;
            bottom: 10px; /* En bas √† droite */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 160px;
            font-size: 10px;
            display: none;
        }
        
        .vote-option {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .vote-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .vote-bar {
            height: 5px;
            width: 100%;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .vote-fill {
            height: 100%;
            background: linear-gradient(90deg, #77ccff, #4488ff);
            width: 30%;
        }
        
        /* Animation pour les effects */
        @keyframes pulse {
            0% { opacity: 0.2; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.2; transform: scale(0.95); }
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        #leaderboard-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* Repositionn√© en bas sous le journal */
            top: auto; /* Annule la position top pr√©c√©dente */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 200px;
            max-height: 145px; /* Hauteur r√©duite pour √©viter le chevauchement (√©tait √† 150px) */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #leaderboard-panel h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #aaa;
            width: 20px;
            text-align: center;
        }
        
        .leaderboard-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .leaderboard-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #story-history-panel {
            position: fixed;
            left: 10px;
            bottom: 175px; /* Remont√© plus haut pour √©viter le chevauchement (√©tait √† 70px) */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* √âlargi pour mieux afficher les messages */
            max-height: 180px; /* L√©g√®rement plus grand */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #story-history-panel h3 {
            margin-top: 0;
            margin-bottom: 3px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .history-item {
            margin-bottom: 4px;
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .history-item-milestone {
            background-color: rgba(255, 204, 0, 0.2);
            border-left: 2px solid #ffcc00;
        }
        
        .history-item-discovery {
            background-color: rgba(119, 204, 255, 0.2);
            border-left: 2px solid #77ccff;
        }
        
        .history-item-event {
            background-color: rgba(255, 102, 102, 0.2);
            border-left: 2px solid #ff6666;
        }
        
        .history-timestamp {
            color: #aaa;
            font-size: 8px;
            margin-bottom: 2px;
            font-style: italic;
        }
        
        /* Style pour r√©server l'espace pour la cam√©ra */
        .camera-space {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 100px;
            z-index: 800;
            /* Background comment√© - juste pour visualiser l'espace r√©serv√© 
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            */
        }
        
        /* Assurons-nous que tous les panneaux ont une apparence coh√©rente */
        #leaderboard-panel, #story-history-panel, #vote-panel, #donor-wall {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.85; /* L√©g√®rement transparent pour voir le bateau derri√®re */
        }
        
        /* Animation de d√©filement automatique pour les panneaux */
        @keyframes autoscroll {
            0% { transform: translateY(0); }
            45% { transform: translateY(calc(-100% + 100px)); }
            55% { transform: translateY(calc(-100% + 100px)); } /* Pause au bas pendant 10% de l'animation */
            57% { transform: translateY(0); } /* Retour tr√®s rapide au d√©but (2% de l'animation) */
            100% { transform: translateY(0); } /* Pause au d√©but avant de recommencer */
        }
        
        .autoscroll-container {
            height: 100%;
            overflow: hidden;
            position: relative;
            max-height: inherit;
        }
        
        .autoscroll-content {
            animation: autoscroll 60s linear infinite; /* Remis √† "infinite" pour boucler */
            animation-play-state: running;
            padding-bottom: 20px; /* Add space at the bottom before repeating */
        }
        
        .autoscroll-content:hover {
            animation-play-state: paused;
        }
        
        /* Objectifs sur la barre en haut */
        #objectives-panel {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            display: flex;
            gap: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .objective {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .objective-icon {
            color: #ffcc00;
            font-size: 14px;
        }
        
        .objective-text {
            white-space: nowrap;
        }
        
        /* 
        Organisation des panneaux :
        - Haut: Objectifs
        - Droite: Progression narrative 
        - √Ä gauche milieu: Journal d'exploration
        - √Ä gauche bas: Classement des explorateurs
        - En bas √† droite: Panneau de vote
        - Centre haut (ajust√©): Barre de progression
        - Centre bas: Affichage narratif
        */
        
        /* Hover effect pour rendre les panneaux plus lisibles au survol */
        #leaderboard-panel:hover, #story-history-panel:hover, #donation-panel:hover, #vote-panel:hover, #donor-wall:hover {
            opacity: 0.95;
            z-index: 950; /* Augmente le z-index au survol pour s'assurer qu'il est au-dessus des autres */
        }
        
        /* Style pour les titres des panneaux */
        #leaderboard-panel h3, #story-history-panel h3, #donor-wall h4 {
            color: #ffcc00;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        #details-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 950;
            background: rgba(0,0,0,0.7);
            color: #ffcc00;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid rgba(255, 204, 0, 0.3);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            display: none; /* Cacher le bouton des d√©tails d'exploration */
        }
        
        #details-button:hover {
            background: rgba(50,50,0,0.7);
            border-color: rgba(255, 204, 0, 0.6);
        }
        
        /* Overlay d'authentification */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #33ff33;
            font-family: 'Courier New', monospace;
        }
        
        .auth-content {
            text-align: center;
            max-width: 500px;
            padding: 20px;
        }
        
        .auth-logo {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
        }
        
        .auth-message {
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        .auth-warning {
            color: #ff3333;
            margin-top: 20px;
            font-size: 12px;
            max-width: 80%;
            text-align: justify;
        }
        
        .donation-progress-container {
            width: 300px;
            margin: 0 auto;
        }
        
        .donation-label {
            color: #fff;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .donation-bar {
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #ff3366;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        #auth-donation-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff3366, #ff6699);
            transition: width 0.5s ease-in-out;
        }
        
        .auth-gauge {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .auth-gauge h3 {
            margin-top: 0;
            font-size: 14px;
            color: #ffcc00;
        }
        
        .tiktok-integration-notice {
            font-size: 12px;
            color: #ccc;
        }
        
        /* Notifications d'authentification */
        .auth-notification {
            position: fixed;
            right: -300px;
            top: 100px;
            background: linear-gradient(90deg, #330033, #5a0057);
            border-left: 3px solid #ff3366;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            padding: 15px;
            width: 250px;
            border-radius: 5px 0 0 5px;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .auth-notification.show {
            right: 0;
        }
        
        .auth-username {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .auth-amount {
            color: #ff3366;
            font-weight: bold;
            font-size: 18px;
        }
        
        /* Statut du syst√®me */
        .system-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #33ff33;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #ff3333;
        }
        
        .status-indicator.online {
            background-color: #33ff33;
        }
        
        /* Animation de pulsation pour la jauge */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .auth-gauge.pulse {
            animation: pulse 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
</head>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TikTok Horror Experience - Saison 1: Les Profondeurs</title>
    <link rel="stylesheet" href="responsive.css">
    <link rel="stylesheet" href="auth_gauge.css">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
        
        #loading { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: #000; 
            color: #fff; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            z-index: 1000;
        }
        
        #debug {
            position: fixed; 
            top: 10px; 
            left: 10px; 
            z-index: 10;
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px;
            border-radius: 5px;
        }
        
        #donation-panel {
            position: fixed;
            right: 10px;
            top: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 180px;
            font-size: 11px;
            display: none; /* Hide donation panel as requested */
        }
        
        #donation-panel h3 {
            margin-top: 0;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 40px; /* D√©plac√© plus bas pour √©viter le chevauchement */
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            max-width: 400px;
            z-index: 900;
        }
        
        .progress-bar {
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            margin-bottom: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9900);
            width: 0%;
            transition: width 1s ease-in-out;
        }
        
        #story-milestone {
            position: fixed;
            top: 80px; /* D√©plac√© encore plus bas */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 12px;
            z-index: 900;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
            padding: 5px 10px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            width: 40%;
            max-width: 400px;
            line-height: 1.3;
            display: none; /* Cach√© par d√©faut, sera affich√© dans le journal uniquement */
        }
        
        #donor-wall {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Align√© avec le journal d'exploration */
            max-height: 130px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Cach√© car remplac√© par top100 */
        }
        
        #top100-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* En bas de l'√©cran, directement sous le journal */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px;
            max-height: 150px;
            overflow: hidden;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Cach√© car remplac√© par leaderboard-panel */
        }
        
        #top100-panel h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 13px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .top100-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
            position: relative;
        }
        
        .top100-rank {
            width: 20px;
            text-align: center;
            color: #aaa;
        }
        
        .top100-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .top100-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #narrative-display {
            position: fixed;
            top: 50%; /* Centr√© verticalement */
            left: 50%;
            transform: translate(-50%, -50%); /* Centrage parfait */
            z-index: 950;
            color: white;
            text-align: center;
            width: 70%;
            max-width: 600px;
            text-shadow: 0 0 3px black, 0 0 5px black;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Fond plus opaque pour meilleure lisibilit√© */
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none; /* Pour √©viter d'interf√©rer avec les clics */
        }
        
        #narrative-display.visible {
            opacity: 0.95;
        }
        
        #clue-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 950;
            color: #ffcc00;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 3px solid #ffcc00;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease-out;
        }
        
        #clue-notification.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #event-counter {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            color: white;
            font-size: 120px;
            text-shadow: 0 0 20px red;
            opacity: 0;
            transition: all 0.3s ease-in-out;
            pointer-events: none;
        }
        
        #event-counter.visible {
            opacity: 1;
        }
        
        button, input { 
            margin: 5px 0; 
            display: block;
            border: none;
            background: #444;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #666;
        }
        
        #sim-donation {
            margin-top: 15px;
            width: 100%;
        }
        
        #vote-panel {
            position: fixed;
            right: 10px;
            bottom: 10px; /* En bas √† droite */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 160px;
            font-size: 10px;
            display: none;
        }
        
        .vote-option {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .vote-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .vote-bar {
            height: 5px;
            width: 100%;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .vote-fill {
            height: 100%;
            background: linear-gradient(90deg, #77ccff, #4488ff);
            width: 30%;
        }
        
        /* Animation pour les effects */
        @keyframes pulse {
            0% { opacity: 0.2; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.2; transform: scale(0.95); }
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        #leaderboard-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* Repositionn√© en bas sous le journal */
            top: auto; /* Annule la position top pr√©c√©dente */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 200px;
            max-height: 145px; /* Hauteur r√©duite pour √©viter le chevauchement (√©tait √† 150px) */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #leaderboard-panel h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #aaa;
            width: 20px;
            text-align: center;
        }
        
        .leaderboard-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .leaderboard-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #story-history-panel {
            position: fixed;
            left: 10px;
            bottom: 175px; /* Remont√© plus haut pour √©viter le chevauchement (√©tait √† 70px) */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* √âlargi pour mieux afficher les messages */
            max-height: 180px; /* L√©g√®rement plus grand */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #story-history-panel h3 {
            margin-top: 0;
            margin-bottom: 3px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .history-item {
            margin-bottom: 4px;
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .history-item-milestone {
            background-color: rgba(255, 204, 0, 0.2);
            border-left: 2px solid #ffcc00;
        }
        
        .history-item-discovery {
            background-color: rgba(119, 204, 255, 0.2);
            border-left: 2px solid #77ccff;
        }
        
        .history-item-event {
            background-color: rgba(255, 102, 102, 0.2);
            border-left: 2px solid #ff6666;
        }
        
        .history-timestamp {
            color: #aaa;
            font-size: 8px;
            margin-bottom: 2px;
            font-style: italic;
        }
        
        /* Style pour r√©server l'espace pour la cam√©ra */
        .camera-space {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 100px;
            z-index: 800;
            /* Background comment√© - juste pour visualiser l'espace r√©serv√© 
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            */
        }
        
        /* Assurons-nous que tous les panneaux ont une apparence coh√©rente */
        #leaderboard-panel, #story-history-panel, #vote-panel, #donor-wall {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.85; /* L√©g√®rement transparent pour voir le bateau derri√®re */
        }
        
        /* Animation de d√©filement automatique pour les panneaux */
        @keyframes autoscroll {
            0% { transform: translateY(0); }
            45% { transform: translateY(calc(-100% + 100px)); }
            55% { transform: translateY(calc(-100% + 100px)); } /* Pause au bas pendant 10% de l'animation */
            57% { transform: translateY(0); } /* Retour tr√®s rapide au d√©but (2% de l'animation) */
            100% { transform: translateY(0); } /* Pause au d√©but avant de recommencer */
        }
        
        .autoscroll-container {
            height: 100%;
            overflow: hidden;
            position: relative;
            max-height: inherit;
        }
        
        .autoscroll-content {
            animation: autoscroll 60s linear infinite; /* Remis √† "infinite" pour boucler */
            animation-play-state: running;
            padding-bottom: 20px; /* Add space at the bottom before repeating */
        }
        
        .autoscroll-content:hover {
            animation-play-state: paused;
        }
        
        /* Objectifs sur la barre en haut */
        #objectives-panel {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            display: flex;
            gap: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .objective {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .objective-icon {
            color: #ffcc00;
            font-size: 14px;
        }
        
        .objective-text {
            white-space: nowrap;
        }
        
        /* 
        Organisation des panneaux :
        - Haut: Objectifs
        - Droite: Progression narrative 
        - √Ä gauche milieu: Journal d'exploration
        - √Ä gauche bas: Classement des explorateurs
        - En bas √† droite: Panneau de vote
        - Centre haut (ajust√©): Barre de progression
        - Centre bas: Affichage narratif
        */
        
        /* Hover effect pour rendre les panneaux plus lisibles au survol */
        #leaderboard-panel:hover, #story-history-panel:hover, #donation-panel:hover, #vote-panel:hover, #donor-wall:hover {
            opacity: 0.95;
            z-index: 950; /* Augmente le z-index au survol pour s'assurer qu'il est au-dessus des autres */
        }
        
        /* Style pour les titres des panneaux */
        #leaderboard-panel h3, #story-history-panel h3, #donor-wall h4 {
            color: #ffcc00;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        #details-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 950;
            background: rgba(0,0,0,0.7);
            color: #ffcc00;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid rgba(255, 204, 0, 0.3);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            display: none; /* Cacher le bouton des d√©tails d'exploration */
        }
        
        #details-button:hover {
            background: rgba(50,50,0,0.7);
            border-color: rgba(255, 204, 0, 0.6);
        }
        
        /* Overlay d'authentification */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #33ff33;
            font-family: 'Courier New', monospace;
        }
        
        .auth-content {
            text-align: center;
            max-width: 500px;
            padding: 20px;
        }
        
        .auth-logo {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
        }
        
        .auth-message {
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        .auth-warning {
            color: #ff3333;
            margin-top: 20px;
            font-size: 12px;
            max-width: 80%;
            text-align: justify;
        }
        
        .donation-progress-container {
            width: 300px;
            margin: 0 auto;
        }
        
        .donation-label {
            color: #fff;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .donation-bar {
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #ff3366;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        #auth-donation-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff3366, #ff6699);
            transition: width 0.5s ease-in-out;
        }
        
        .auth-gauge {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .auth-gauge h3 {
            margin-top: 0;
            font-size: 14px;
            color: #ffcc00;
        }
        
        .tiktok-integration-notice {
            font-size: 12px;
            color: #ccc;
        }
        
        /* Notifications d'authentification */
        .auth-notification {
            position: fixed;
            right: -300px;
            top: 100px;
            background: linear-gradient(90deg, #330033, #5a0057);
            border-left: 3px solid #ff3366;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            padding: 15px;
            width: 250px;
            border-radius: 5px 0 0 5px;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .auth-notification.show {
            right: 0;
        }
        
        .auth-username {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .auth-amount {
            color: #ff3366;
            font-weight: bold;
            font-size: 18px;
        }
        
        /* Statut du syst√®me */
        .system-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #33ff33;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #ff3333;
        }
        
        .status-indicator.online {
            background-color: #33ff33;
        }
        
        /* Animation de pulsation pour la jauge */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .auth-gauge.pulse {
            animation: pulse 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TikTok Horror Experience - Saison 1: Les Profondeurs</title>
    <link rel="stylesheet" href="responsive.css">
    <link rel="stylesheet" href="auth_gauge.css">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
        
        #loading { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: #000; 
            color: #fff; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            z-index: 1000;
        }
        
        #debug {
            position: fixed; 
            top: 10px; 
            left: 10px; 
            z-index: 10;
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px;
            border-radius: 5px;
        }
        
        #donation-panel {
            position: fixed;
            right: 10px;
            top: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 180px;
            font-size: 11px;
            display: none; /* Hide donation panel as requested */
        }
        
        #donation-panel h3 {
            margin-top: 0;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 40px; /* D√©plac√© plus bas pour √©viter le chevauchement */
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            max-width: 400px;
            z-index: 900;
        }
        
        .progress-bar {
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            margin-bottom: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9900);
            width: 0%;
            transition: width 1s ease-in-out;
        }
        
        #story-milestone {
            position: fixed;
            top: 80px; /* D√©plac√© encore plus bas */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 12px;
            z-index: 900;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
            padding: 5px 10px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            width: 40%;
            max-width: 400px;
            line-height: 1.3;
            display: none; /* Cach√© par d√©faut, sera affich√© dans le journal uniquement */
        }
        
        #donor-wall {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Align√© avec le journal d'exploration */
            max-height: 130px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Cach√© car remplac√© par top100 */
        }
        
        #top100-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* En bas de l'√©cran, directement sous le journal */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px;
            max-height: 150px;
            overflow: hidden;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Cach√© car remplac√© par leaderboard-panel */
        }
        
        #top100-panel h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 13px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .top100-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
            position: relative;
        }
        
        .top100-rank {
            width: 20px;
            text-align: center;
            color: #aaa;
        }
        
        .top100-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .top100-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #narrative-display {
            position: fixed;
            top: 50%; /* Centr√© verticalement */
            left: 50%;
            transform: translate(-50%, -50%); /* Centrage parfait */
            z-index: 950;
            color: white;
            text-align: center;
            width: 70%;
            max-width: 600px;
            text-shadow: 0 0 3px black, 0 0 5px black;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Fond plus opaque pour meilleure lisibilit√© */
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none; /* Pour √©viter d'interf√©rer avec les clics */
        }
        
        #narrative-display.visible {
            opacity: 0.95;
        }
        
        #clue-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 950;
            color: #ffcc00;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 3px solid #ffcc00;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease-out;
        }
        
        #clue-notification.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #event-counter {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            color: white;
            font-size: 120px;
            text-shadow: 0 0 20px red;
            opacity: 0;
            transition: all 0.3s ease-in-out;
            pointer-events: none;
        }
        
        #event-counter.visible {
            opacity: 1;
        }
        
        button, input { 
            margin: 5px 0; 
            display: block;
            border: none;
            background: #444;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #666;
        }
        
        #sim-donation {
            margin-top: 15px;
            width: 100%;
        }
        
        #vote-panel {
            position: fixed;
            right: 10px;
            bottom: 10px; /* En bas √† droite */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 160px;
            font-size: 10px;
            display: none;
        }
        
        .vote-option {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .vote-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .vote-bar {
            height: 5px;
            width: 100%;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .vote-fill {
            height: 100%;
            background: linear-gradient(90deg, #77ccff, #4488ff);
            width: 30%;
        }
        
        /* Animation pour les effects */
        @keyframes pulse {
            0% { opacity: 0.2; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.2; transform: scale(0.95); }
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        #leaderboard-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* Repositionn√© en bas sous le journal */
            top: auto; /* Annule la position top pr√©c√©dente */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 200px;
            max-height: 145px; /* Hauteur r√©duite pour √©viter le chevauchement (√©tait √† 150px) */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #leaderboard-panel h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #aaa;
            width: 20px;
            text-align: center;
        }
        
        .leaderboard-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .leaderboard-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #story-history-panel {
            position: fixed;
            left: 10px;
            bottom: 175px; /* Remont√© plus haut pour √©viter le chevauchement (√©tait √† 70px) */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* √âlargi pour mieux afficher les messages */
            max-height: 180px; /* L√©g√®rement plus grand */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #story-history-panel h3 {
            margin-top: 0;
            margin-bottom: 3px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .history-item {
            margin-bottom: 4px;
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .history-item-milestone {
            background-color: rgba(255, 204, 0, 0.2);
            border-left: 2px solid #ffcc00;
        }
        
        .history-item-discovery {
            background-color: rgba(119, 204, 255, 0.2);
            border-left: 2px solid #77ccff;
        }
        
        .history-item-event {
            background-color: rgba(255, 102, 102, 0.2);
            border-left: 2px solid #ff6666;
        }
        
        .history-timestamp {
            color: #aaa;
            font-size: 8px;
            margin-bottom: 2px;
            font-style: italic;
        }
        
        /* Style pour r√©server l'espace pour la cam√©ra */
        .camera-space {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 100px;
            z-index: 800;
            /* Background comment√© - juste pour visualiser l'espace r√©serv√© 
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            */
        }
        
        /* Assurons-nous que tous les panneaux ont une apparence coh√©rente */
        #leaderboard-panel, #story-history-panel, #vote-panel, #donor-wall {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.85; /* L√©g√®rement transparent pour voir le bateau derri√®re */
        }
        
        /* Animation de d√©filement automatique pour les panneaux */
        @keyframes autoscroll {
            0% { transform: translateY(0); }
            45% { transform: translateY(calc(-100% + 100px)); }
            55% { transform: translateY(calc(-100% + 100px)); } /* Pause au bas pendant 10% de l'animation */
            57% { transform: translateY(0); } /* Retour tr√®s rapide au d√©but (2% de l'animation) */
            100% { transform: translateY(0); } /* Pause au d√©but avant de recommencer */
        }
        
        .autoscroll-container {
            height: 100%;
            overflow: hidden;
            position: relative;
            max-height: inherit;
        }
        
        .autoscroll-content {
            animation: autoscroll 60s linear infinite; /* Remis √† "infinite" pour boucler */
            animation-play-state: running;
            padding-bottom: 20px; /* Add space at the bottom before repeating */
        }
        
        .autoscroll-content:hover {
            animation-play-state: paused;
        }
        
        /* Objectifs sur la barre en haut */
        #objectives-panel {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            display: flex;
            gap: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .objective {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .objective-icon {
            color: #ffcc00;
            font-size: 14px;
        }
        
        .objective-text {
            white-space: nowrap;
        }
        
        /* 
        Organisation des panneaux :
        - Haut: Objectifs
        - Droite: Progression narrative 
        - √Ä gauche milieu: Journal d'exploration
        - √Ä gauche bas: Classement des explorateurs
        - En bas √† droite: Panneau de vote
        - Centre haut (ajust√©): Barre de progression
        - Centre bas: Affichage narratif
        */
        
        /* Hover effect pour rendre les panneaux plus lisibles au survol */
        #leaderboard-panel:hover, #story-history-panel:hover, #donation-panel:hover, #vote-panel:hover, #donor-wall:hover {
            opacity: 0.95;
            z-index: 950; /* Augmente le z-index au survol pour s'assurer qu'il est au-dessus des autres */
        }
        
        /* Style pour les titres des panneaux */
        #leaderboard-panel h3, #story-history-panel h3, #donor-wall h4 {
            color: #ffcc00;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        #details-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 950;
            background: rgba(0,0,0,0.7);
            color: #ffcc00;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid rgba(255, 204, 0, 0.3);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            display: none; /* Cacher le bouton des d√©tails d'exploration */
        }
        
        #details-button:hover {
            background: rgba(50,50,0,0.7);
            border-color: rgba(255, 204, 0, 0.6);
        }
        
        /* Overlay d'authentification */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #33ff33;
            font-family: 'Courier New', monospace;
        }
        
        .auth-content {
            text-align: center;
            max-width: 500px;
            padding: 20px;
        }
        
        .auth-logo {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
        }
        
        .auth-message {
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        .auth-warning {
            color: #ff3333;
            margin-top: 20px;
            font-size: 12px;
            max-width: 80%;
            text-align: justify;
        }
        
        .donation-progress-container {
            width: 300px;
            margin: 0 auto;
        }
        
        .donation-label {
            color: #fff;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .donation-bar {
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #ff3366;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        #auth-donation-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff3366, #ff6699);
            transition: width 0.5s ease-in-out;
        }
        
        .auth-gauge {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .auth-gauge h3 {
            margin-top: 0;
            font-size: 14px;
            color: #ffcc00;
        }
        
        .tiktok-integration-notice {
            font-size: 12px;
            color: #ccc;
        }
        
        /* Notifications d'authentification */
        .auth-notification {
            position: fixed;
            right: -300px;
            top: 100px;
            background: linear-gradient(90deg, #330033, #5a0057);
            border-left: 3px solid #ff3366;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            padding: 15px;
            width: 250px;
            border-radius: 5px 0 0 5px;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .auth-notification.show {
            right: 0;
        }
        
        .auth-username {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .auth-amount {
            color: #ff3366;
            font-weight: bold;
            font-size: 18px;
        }
        
        /* Statut du syst√®me */
        .system-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #33ff33;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #ff3333;
        }
        
        .status-indicator.online {
            background-color: #33ff33;
        }
        
        /* Animation de pulsation pour la jauge */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .auth-gauge.pulse {
            animation: pulse 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
    <!-- Inclure les fichiers externes pour la gestion de l'authentification -->
    <script src="auth_gauge.js"></script>
    <script>
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TikTok Horror Experience - Saison 1: Les Profondeurs</title>
    <link rel="stylesheet" href="responsive.css">
    <link rel="stylesheet" href="auth_gauge.css">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
        
        #loading { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: #000; 
            color: #fff; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            z-index: 1000;
        }
        
        #debug {
            position: fixed; 
            top: 10px; 
            left: 10px; 
            z-index: 10;
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px;
            border-radius: 5px;
        }
        
        #donation-panel {
            position: fixed;
            right: 10px;
            top: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 180px;
            font-size: 11px;
            display: none; /* Hide donation panel as requested */
        }
        
        #donation-panel h3 {
            margin-top: 0;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 40px; /* D√©plac√© plus bas pour √©viter le chevauchement */
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            max-width: 400px;
            z-index: 900;
        }
        
        .progress-bar {
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            margin-bottom: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9900);
            width: 0%;
            transition: width 1s ease-in-out;
        }
        
        #story-milestone {
            position: fixed;
            top: 80px; /* D√©plac√© encore plus bas */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 12px;
            z-index: 900;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
            padding: 5px 10px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            width: 40%;
            max-width: 400px;
            line-height: 1.3;
            display: none; /* Cach√© par d√©faut, sera affich√© dans le journal uniquement */
        }
        
        #donor-wall {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Align√© avec le journal d'exploration */
            max-height: 130px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Cach√© car remplac√© par top100 */
        }
        
        #top100-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* En bas de l'√©cran, directement sous le journal */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px;
            max-height: 150px;
            overflow: hidden;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Cach√© car remplac√© par leaderboard-panel */
        }
        
        #top100-panel h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 13px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .top100-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
            position: relative;
        }
        
        .top100-rank {
            width: 20px;
            text-align: center;
            color: #aaa;
        }
        
        .top100-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .top100-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #narrative-display {
            position: fixed;
            top: 50%; /* Centr√© verticalement */
            left: 50%;
            transform: translate(-50%, -50%); /* Centrage parfait */
            z-index: 950;
            color: white;
            text-align: center;
            width: 70%;
            max-width: 600px;
            text-shadow: 0 0 3px black, 0 0 5px black;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Fond plus opaque pour meilleure lisibilit√© */
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none; /* Pour √©viter d'interf√©rer avec les clics */
        }
        
        #narrative-display.visible {
            opacity: 0.95;
        }
        
        #clue-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 950;
            color: #ffcc00;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 3px solid #ffcc00;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease-out;
        }
        
        #clue-notification.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #event-counter {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            color: white;
            font-size: 120px;
            text-shadow: 0 0 20px red;
            opacity: 0;
            transition: all 0.3s ease-in-out;
            pointer-events: none;
        }
        
        #event-counter.visible {
            opacity: 1;
        }
        
        button, input { 
            margin: 5px 0; 
            display: block;
            border: none;
            background: #444;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #666;
        }
        
        #sim-donation {
            margin-top: 15px;
            width: 100%;
        }
        
        #vote-panel {
            position: fixed;
            right: 10px;
            bottom: 10px; /* En bas √† droite */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 160px;
            font-size: 10px;
            display: none;
        }
        
        .vote-option {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .vote-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .vote-bar {
            height: 5px;
            width: 100%;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .vote-fill {
            height: 100%;
            background: linear-gradient(90deg, #77ccff, #4488ff);
            width: 30%;
        }
        
        /* Animation pour les effects */
        @keyframes pulse {
            0% { opacity: 0.2; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.2; transform: scale(0.95); }
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        #leaderboard-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* Repositionn√© en bas sous le journal */
            top: auto; /* Annule la position top pr√©c√©dente */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 200px;
            max-height: 145px; /* Hauteur r√©duite pour √©viter le chevauchement (√©tait √† 150px) */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #leaderboard-panel h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #aaa;
            width: 20px;
            text-align: center;
        }
        
        .leaderboard-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .leaderboard-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #story-history-panel {
            position: fixed;
            left: 10px;
            bottom: 175px; /* Remont√© plus haut pour √©viter le chevauchement (√©tait √† 70px) */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* √âlargi pour mieux afficher les messages */
            max-height: 180px; /* L√©g√®rement plus grand */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #story-history-panel h3 {
            margin-top: 0;
            margin-bottom: 3px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .history-item {
            margin-bottom: 4px;
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .history-item-milestone {
            background-color: rgba(255, 204, 0, 0.2);
            border-left: 2px solid #ffcc00;
        }
        
        .history-item-discovery {
            background-color: rgba(119, 204, 255, 0.2);
            border-left: 2px solid #77ccff;
        }
        
        .history-item-event {
            background-color: rgba(255, 102, 102, 0.2);
            border-left: 2px solid #ff6666;
        }
        
        .history-timestamp {
            color: #aaa;
            font-size: 8px;
            margin-bottom: 2px;
            font-style: italic;
        }
        
        /* Style pour r√©server l'espace pour la cam√©ra */
        .camera-space {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 100px;
            z-index: 800;
            /* Background comment√© - juste pour visualiser l'espace r√©serv√© 
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            */
        }
        
        /* Assurons-nous que tous les panneaux ont une apparence coh√©rente */
        #leaderboard-panel, #story-history-panel, #vote-panel, #donor-wall {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.85; /* L√©g√®rement transparent pour voir le bateau derri√®re */
        }
        
        /* Animation de d√©filement automatique pour les panneaux */
        @keyframes autoscroll {
            0% { transform: translateY(0); }
            45% { transform: translateY(calc(-100% + 100px)); }
            55% { transform: translateY(calc(-100% + 100px)); } /* Pause au bas pendant 10% de l'animation */
            57% { transform: translateY(0); } /* Retour tr√®s rapide au d√©but (2% de l'animation) */
            100% { transform: translateY(0); } /* Pause au d√©but avant de recommencer */
        }
        
        .autoscroll-container {
            height: 100%;
            overflow: hidden;
            position: relative;
            max-height: inherit;
        }
        
        .autoscroll-content {
            animation: autoscroll 60s linear infinite; /* Remis √† "infinite" pour boucler */
            animation-play-state: running;
            padding-bottom: 20px; /* Add space at the bottom before repeating */
        }
        
        .autoscroll-content:hover {
            animation-play-state: paused;
        }
        
        /* Objectifs sur la barre en haut */
        #objectives-panel {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            display: flex;
            gap: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .objective {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .objective-icon {
            color: #ffcc00;
            font-size: 14px;
        }
        
        .objective-text {
            white-space: nowrap;
        }
        
        /* 
        Organisation des panneaux :
        - Haut: Objectifs
        - Droite: Progression narrative 
        - √Ä gauche milieu: Journal d'exploration
        - √Ä gauche bas: Classement des explorateurs
        - En bas √† droite: Panneau de vote
        - Centre haut (ajust√©): Barre de progression
        - Centre bas: Affichage narratif
        */
        
        /* Hover effect pour rendre les panneaux plus lisibles au survol */
        #leaderboard-panel:hover, #story-history-panel:hover, #donation-panel:hover, #vote-panel:hover, #donor-wall:hover {
            opacity: 0.95;
            z-index: 950; /* Augmente le z-index au survol pour s'assurer qu'il est au-dessus des autres */
        }
        
        /* Style pour les titres des panneaux */
        #leaderboard-panel h3, #story-history-panel h3, #donor-wall h4 {
            color: #ffcc00;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        #details-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 950;
            background: rgba(0,0,0,0.7);
            color: #ffcc00;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid rgba(255, 204, 0, 0.3);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            display: none; /* Cacher le bouton des d√©tails d'exploration */
        }
        
        #details-button:hover {
            background: rgba(50,50,0,0.7);
            border-color: rgba(255, 204, 0, 0.6);
        }
        
        /* Overlay d'authentification */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #33ff33;
            font-family: 'Courier New', monospace;
        }
        
        .auth-content {
            text-align: center;
            max-width: 500px;
            padding: 20px;
        }
        
        .auth-logo {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
        }
        
        .auth-message {
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        .auth-warning {
            color: #ff3333;
            margin-top: 20px;
            font-size: 12px;
            max-width: 80%;
            text-align: justify;
        }
        
        .donation-progress-container {
            width: 300px;
            margin: 0 auto;
        }
        
        .donation-label {
            color: #fff;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .donation-bar {
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #ff3366;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        #auth-donation-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff3366, #ff6699);
            transition: width 0.5s ease-in-out;
        }
        
        .auth-gauge {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .auth-gauge h3 {
            margin-top: 0;
            font-size: 14px;
            color: #ffcc00;
        }
        
        .tiktok-integration-notice {
            font-size: 12px;
            color: #ccc;
        }
        
        /* Notifications d'authentification */
        .auth-notification {
            position: fixed;
            right: -300px;
            top: 100px;
            background: linear-gradient(90deg, #330033, #5a0057);
            border-left: 3px solid #ff3366;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            padding: 15px;
            width: 250px;
            border-radius: 5px 0 0 5px;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .auth-notification.show {
            right: 0;
        }
        
        .auth-username {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .auth-amount {
            color: #ff3366;
            font-weight: bold;
            font-size: 18px;
        }
        
        /* Statut du syst√®me */
        .system-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #33ff33;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #ff3333;
        }
        
        .status-indicator.online {
            background-color: #33ff33;
        }
        
        /* Animation de pulsation pour la jauge */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .auth-gauge.pulse {
            animation: pulse 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
    <!-- Inclure les fichiers externes pour la gestion de l'authentification -->
    <script src="auth_gauge.js"></script>
    <script>
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TikTok Horror Experience - Saison 1: Les Profondeurs</title>
    <link rel="stylesheet" href="responsive.css">
    <link rel="stylesheet" href="auth_gauge.css">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
        
        #loading { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: #000; 
            color: #fff; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            z-index: 1000;
        }
        
        #debug {
            position: fixed; 
            top: 10px; 
            left: 10px; 
            z-index: 10;
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px;
            border-radius: 5px;
        }
        
        #donation-panel {
            position: fixed;
            right: 10px;
            top: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 180px;
            font-size: 11px;
            display: none; /* Hide donation panel as requested */
        }
        
        #donation-panel h3 {
            margin-top: 0;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 40px; /* D√©plac√© plus bas pour √©viter le chevauchement */
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            max-width: 400px;
            z-index: 900;
        }
        
        .progress-bar {
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            margin-bottom: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9900);
            width: 0%;
            transition: width 1s ease-in-out;
        }
        
        #story-milestone {
            position: fixed;
            top: 80px; /* D√©plac√© encore plus bas */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 12px;
            z-index: 900;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
            padding: 5px 10px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            width: 40%;
            max-width: 400px;
            line-height: 1.3;
            display: none; /* Cach√© par d√©faut, sera affich√© dans le journal uniquement */
        }
        
        #donor-wall {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Align√© avec le journal d'exploration */
            max-height: 130px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Cach√© car remplac√© par top100 */
        }
        
        #top100-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* En bas de l'√©cran, directement sous le journal */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px;
            max-height: 150px;
            overflow: hidden;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Cach√© car remplac√© par leaderboard-panel */
        }
        
        #top100-panel h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 13px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .top100-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
            position: relative;
        }
        
        .top100-rank {
            width: 20px;
            text-align: center;
            color: #aaa;
        }
        
        .top100-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .top100-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #narrative-display {
            position: fixed;
            top: 50%; /* Centr√© verticalement */
            left: 50%;
            transform: translate(-50%, -50%); /* Centrage parfait */
            z-index: 950;
            color: white;
            text-align: center;
            width: 70%;
            max-width: 600px;
            text-shadow: 0 0 3px black, 0 0 5px black;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Fond plus opaque pour meilleure lisibilit√© */
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none; /* Pour √©viter d'interf√©rer avec les clics */
        }
        
        #narrative-display.visible {
            opacity: 0.95;
        }
        
        #clue-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 950;
            color: #ffcc00;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 3px solid #ffcc00;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease-out;
        }
        
        #clue-notification.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #event-counter {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            color: white;
            font-size: 120px;
            text-shadow: 0 0 20px red;
            opacity: 0;
            transition: all 0.3s ease-in-out;
            pointer-events: none;
        }
        
        #event-counter.visible {
            opacity: 1;
        }
        
        button, input { 
            margin: 5px 0; 
            display: block;
            border: none;
            background: #444;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #666;
        }
        
        #sim-donation {
            margin-top: 15px;
            width: 100%;
        }
        
        #vote-panel {
            position: fixed;
            right: 10px;
            bottom: 10px; /* En bas √† droite */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 160px;
            font-size: 10px;
            display: none;
        }
        
        .vote-option {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .vote-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .vote-bar {
            height: 5px;
            width: 100%;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .vote-fill {
            height: 100%;
            background: linear-gradient(90deg, #77ccff, #4488ff);
            width: 30%;
        }
        
        /* Animation pour les effects */
        @keyframes pulse {
            0% { opacity: 0.2; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.2; transform: scale(0.95); }
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        #leaderboard-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* Repositionn√© en bas sous le journal */
            top: auto; /* Annule la position top pr√©c√©dente */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 200px;
            max-height: 145px; /* Hauteur r√©duite pour √©viter le chevauchement (√©tait √† 150px) */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #leaderboard-panel h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #aaa;
            width: 20px;
            text-align: center;
        }
        
        .leaderboard-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .leaderboard-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #story-history-panel {
            position: fixed;
            left: 10px;
            bottom: 175px; /* Remont√© plus haut pour √©viter le chevauchement (√©tait √† 70px) */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* √âlargi pour mieux afficher les messages */
            max-height: 180px; /* L√©g√®rement plus grand */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #story-history-panel h3 {
            margin-top: 0;
            margin-bottom: 3px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .history-item {
            margin-bottom: 4px;
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .history-item-milestone {
            background-color: rgba(255, 204, 0, 0.2);
            border-left: 2px solid #ffcc00;
        }
        
        .history-item-discovery {
            background-color: rgba(119, 204, 255, 0.2);
            border-left: 2px solid #77ccff;
        }
        
        .history-item-event {
            background-color: rgba(255, 102, 102, 0.2);
            border-left: 2px solid #ff6666;
        }
        
        .history-timestamp {
            color: #aaa;
            font-size: 8px;
            margin-bottom: 2px;
            font-style: italic;
        }
        
        /* Style pour r√©server l'espace pour la cam√©ra */
        .camera-space {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 100px;
            z-index: 800;
            /* Background comment√© - juste pour visualiser l'espace r√©serv√© 
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            */
        }
        
        /* Assurons-nous que tous les panneaux ont une apparence coh√©rente */
        #leaderboard-panel, #story-history-panel, #vote-panel, #donor-wall {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.85; /* L√©g√®rement transparent pour voir le bateau derri√®re */
        }
        
        /* Animation de d√©filement automatique pour les panneaux */
        @keyframes autoscroll {
            0% { transform: translateY(0); }
            45% { transform: translateY(calc(-100% + 100px)); }
            55% { transform: translateY(calc(-100% + 100px)); } /* Pause au bas pendant 10% de l'animation */
            57% { transform: translateY(0); } /* Retour tr√®s rapide au d√©but (2% de l'animation) */
            100% { transform: translateY(0); } /* Pause au d√©but avant de recommencer */
        }
        
        .autoscroll-container {
            height: 100%;
            overflow: hidden;
            position: relative;
            max-height: inherit;
        }
        
        .autoscroll-content {
            animation: autoscroll 60s linear infinite; /* Remis √† "infinite" pour boucler */
            animation-play-state: running;
            padding-bottom: 20px; /* Add space at the bottom before repeating */
        }
        
        .autoscroll-content:hover {
            animation-play-state: paused;
        }
        
        /* Objectifs sur la barre en haut */
        #objectives-panel {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            display: flex;
            gap: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .objective {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .objective-icon {
            color: #ffcc00;
            font-size: 14px;
        }
        
        .objective-text {
            white-space: nowrap;
        }
        
        /* 
        Organisation des panneaux :
        - Haut: Objectifs
        - Droite: Progression narrative 
        - √Ä gauche milieu: Journal d'exploration
        - √Ä gauche bas: Classement des explorateurs
        - En bas √† droite: Panneau de vote
        - Centre haut (ajust√©): Barre de progression
        - Centre bas: Affichage narratif
        */
        
        /* Hover effect pour rendre les panneaux plus lisibles au survol */
        #leaderboard-panel:hover, #story-history-panel:hover, #donation-panel:hover, #vote-panel:hover, #donor-wall:hover {
            opacity: 0.95;
            z-index: 950; /* Augmente le z-index au survol pour s'assurer qu'il est au-dessus des autres */
        }
        
        /* Style pour les titres des panneaux */
        #leaderboard-panel h3, #story-history-panel h3, #donor-wall h4 {
            color: #ffcc00;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        #details-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 950;
            background: rgba(0,0,0,0.7);
            color: #ffcc00;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid rgba(255, 204, 0, 0.3);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            display: none; /* Cacher le bouton des d√©tails d'exploration */
        }
        
        #details-button:hover {
            background: rgba(50,50,0,0.7);
            border-color: rgba(255, 204, 0, 0.6);
        }
        
        /* Overlay d'authentification */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #33ff33;
            font-family: 'Courier New', monospace;
        }
        
        .auth-content {
            text-align: center;
            max-width: 500px;
            padding: 20px;
        }
        
        .auth-logo {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
        }
        
        .auth-message {
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        .auth-warning {
            color: #ff3333;
            margin-top: 20px;
            font-size: 12px;
            max-width: 80%;
            text-align: justify;
        }
        
        .donation-progress-container {
            width: 300px;
            margin: 0 auto;
        }
        
        .donation-label {
            color: #fff;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .donation-bar {
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #ff3366;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        #auth-donation-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff3366, #ff6699);
            transition: width 0.5s ease-in-out;
        }
        
        .auth-gauge {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .auth-gauge h3 {
            margin-top: 0;
            font-size: 14px;
            color: #ffcc00;
        }
        
        .tiktok-integration-notice {
            font-size: 12px;
            color: #ccc;
        }
        
        /* Notifications d'authentification */
        .auth-notification {
            position: fixed;
            right: -300px;
            top: 100px;
            background: linear-gradient(90deg, #330033, #5a0057);
            border-left: 3px solid #ff3366;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            padding: 15px;
            width: 250px;
            border-radius: 5px 0 0 5px;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .auth-notification.show {
            right: 0;
        }
        
        .auth-username {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .auth-amount {
            color: #ff3366;
            font-weight: bold;
            font-size: 18px;
        }
        
        /* Statut du syst√®me */
        .system-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #33ff33;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #ff3333;
        }
        
        .status-indicator.online {
            background-color: #33ff33;
        }
        
        /* Animation de pulsation pour la jauge */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .auth-gauge.pulse {
            animation: pulse 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
    <!-- Inclure les fichiers externes pour la gestion de l'authentification -->
    <script src="auth_gauge.js"></script>
    <script>
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TikTok Horror Experience - Saison 1: Les Profondeurs</title>
    <link rel="stylesheet" href="responsive.css">
    <link rel="stylesheet" href="auth_gauge.css">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
        
        #loading { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: #000; 
            color: #fff; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            z-index: 1000;
        }
        
        #debug {
            position: fixed; 
            top: 10px; 
            left: 10px; 
            z-index: 10;
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px;
            border-radius: 5px;
        }
        
        #donation-panel {
            position: fixed;
            right: 10px;
            top: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 180px;
            font-size: 11px;
            display: none; /* Hide donation panel as requested */
        }
        
        #donation-panel h3 {
            margin-top: 0;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 40px; /* D√©plac√© plus bas pour √©viter le chevauchement */
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            max-width: 400px;
            z-index: 900;
        }
        
        .progress-bar {
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            margin-bottom: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9900);
            width: 0%;
            transition: width 1s ease-in-out;
        }
        
        #story-milestone {
            position: fixed;
            top: 80px; /* D√©plac√© encore plus bas */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 12px;
            z-index: 900;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
            padding: 5px 10px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            width: 40%;
            max-width: 400px;
            line-height: 1.3;
            display: none; /* Cach√© par d√©faut, sera affich√© dans le journal uniquement */
        }
        
        #donor-wall {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Align√© avec le journal d'exploration */
            max-height: 130px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Cach√© car remplac√© par top100 */
        }
        
        #top100-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* En bas de l'√©cran, directement sous le journal */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px;
            max-height: 150px;
            overflow: hidden;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Cach√© car remplac√© par leaderboard-panel */
        }
        
        #top100-panel h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 13px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .top100-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
            position: relative;
        }
        
        .top100-rank {
            width: 20px;
            text-align: center;
            color: #aaa;
        }
        
        .top100-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .top100-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #narrative-display {
            position: fixed;
            top: 50%; /* Centr√© verticalement */
            left: 50%;
            transform: translate(-50%, -50%); /* Centrage parfait */
            z-index: 950;
            color: white;
            text-align: center;
            width: 70%;
            max-width: 600px;
            text-shadow: 0 0 3px black, 0 0 5px black;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Fond plus opaque pour meilleure lisibilit√© */
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none; /* Pour √©viter d'interf√©rer avec les clics */
        }
        
        #narrative-display.visible {
            opacity: 0.95;
        }
        
        #clue-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 950;
            color: #ffcc00;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 3px solid #ffcc00;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease-out;
        }
        
        #clue-notification.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #event-counter {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            color: white;
            font-size: 120px;
            text-shadow: 0 0 20px red;
            opacity: 0;
            transition: all 0.3s ease-in-out;
            pointer-events: none;
        }
        
        #event-counter.visible {
            opacity: 1;
        }
        
        button, input { 
            margin: 5px 0; 
            display: block;
            border: none;
            background: #444;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #666;
        }
        
        #sim-donation {
            margin-top: 15px;
            width: 100%;
        }
        
        #vote-panel {
            position: fixed;
            right: 10px;
            bottom: 10px; /* En bas √† droite */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 160px;
            font-size: 10px;
            display: none;
        }
        
        .vote-option {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .vote-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .vote-bar {
            height: 5px;
            width: 100%;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .vote-fill {
            height: 100%;
            background: linear-gradient(90deg, #77ccff, #4488ff);
            width: 30%;
        }
        
        /* Animation pour les effects */
        @keyframes pulse {
            0% { opacity: 0.2; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.2; transform: scale(0.95); }
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        #leaderboard-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* Repositionn√© en bas sous le journal */
            top: auto; /* Annule la position top pr√©c√©dente */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 200px;
            max-height: 145px; /* Hauteur r√©duite pour √©viter le chevauchement (√©tait √† 150px) */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #leaderboard-panel h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #aaa;
            width: 20px;
            text-align: center;
        }
        
        .leaderboard-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .leaderboard-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #story-history-panel {
            position: fixed;
            left: 10px;
            bottom: 175px; /* Remont√© plus haut pour √©viter le chevauchement (√©tait √† 70px) */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* √âlargi pour mieux afficher les messages */
            max-height: 180px; /* L√©g√®rement plus grand */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #story-history-panel h3 {
            margin-top: 0;
            margin-bottom: 3px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .history-item {
            margin-bottom: 4px;
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .history-item-milestone {
            background-color: rgba(255, 204, 0, 0.2);
            border-left: 2px solid #ffcc00;
        }
        
        .history-item-discovery {
            background-color: rgba(119, 204, 255, 0.2);
            border-left: 2px solid #77ccff;
        }
        
        .history-item-event {
            background-color: rgba(255, 102, 102, 0.2);
            border-left: 2px solid #ff6666;
        }
        
        .history-timestamp {
            color: #aaa;
            font-size: 8px;
            margin-bottom: 2px;
            font-style: italic;
        }
        
        /* Style pour r√©server l'espace pour la cam√©ra */
        .camera-space {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 100px;
            z-index: 800;
            /* Background comment√© - juste pour visualiser l'espace r√©serv√© 
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            */
        }
        
        /* Assurons-nous que tous les panneaux ont une apparence coh√©rente */
        #leaderboard-panel, #story-history-panel, #vote-panel, #donor-wall {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.85; /* L√©g√®rement transparent pour voir le bateau derri√®re */
        }
        
        /* Animation de d√©filement automatique pour les panneaux */
        @keyframes autoscroll {
            0% { transform: translateY(0); }
            45% { transform: translateY(calc(-100% + 100px)); }
            55% { transform: translateY(calc(-100% + 100px)); } /* Pause au bas pendant 10% de l'animation */
            57% { transform: translateY(0); } /* Retour tr√®s rapide au d√©but (2% de l'animation) */
            100% { transform: translateY(0); } /* Pause au d√©but avant de recommencer */
        }
        
        .autoscroll-container {
            height: 100%;
            overflow: hidden;
            position: relative;
            max-height: inherit;
        }
        
        .autoscroll-content {
            animation: autoscroll 60s linear infinite; /* Remis √† "infinite" pour boucler */
            animation-play-state: running;
            padding-bottom: 20px; /* Add space at the bottom before repeating */
        }
        
        .autoscroll-content:hover {
            animation-play-state: paused;
        }
        
        /* Objectifs sur la barre en haut */
        #objectives-panel {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            display: flex;
            gap: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .objective {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .objective-icon {
            color: #ffcc00;
            font-size: 14px;
        }
        
        .objective-text {
            white-space: nowrap;
        }
        
        /* 
        Organisation des panneaux :
        - Haut: Objectifs
        - Droite: Progression narrative 
        - √Ä gauche milieu: Journal d'exploration
        - √Ä gauche bas: Classement des explorateurs
        - En bas √† droite: Panneau de vote
        - Centre haut (ajust√©): Barre de progression
        - Centre bas: Affichage narratif
        */
        
        /* Hover effect pour rendre les panneaux plus lisibles au survol */
        #leaderboard-panel:hover, #story-history-panel:hover, #donation-panel:hover, #vote-panel:hover, #donor-wall:hover {
            opacity: 0.95;
            z-index: 950; /* Augmente le z-index au survol pour s'assurer qu'il est au-dessus des autres */
        }
        
        /* Style pour les titres des panneaux */
        #leaderboard-panel h3, #story-history-panel h3, #donor-wall h4 {
            color: #ffcc00;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        #details-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 950;
            background: rgba(0,0,0,0.7);
            color: #ffcc00;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid rgba(255, 204, 0, 0.3);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            display: none; /* Cacher le bouton des d√©tails d'exploration */
        }
        
        #details-button:hover {
            background: rgba(50,50,0,0.7);
            border-color: rgba(255, 204, 0, 0.6);
        }
        
        /* Overlay d'authentification */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #33ff33;
            font-family: 'Courier New', monospace;
        }
        
        .auth-content {
            text-align: center;
            max-width: 500px;
            padding: 20px;
        }
        
        .auth-logo {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
        }
        
        .auth-message {
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        .auth-warning {
            color: #ff3333;
            margin-top: 20px;
            font-size: 12px;
            max-width: 80%;
            text-align: justify;
        }
        
        .donation-progress-container {
            width: 300px;
            margin: 0 auto;
        }
        
        .donation-label {
            color: #fff;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .donation-bar {
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #ff3366;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        #auth-donation-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff3366, #ff6699);
            transition: width 0.5s ease-in-out;
        }
        
        .auth-gauge {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .auth-gauge h3 {
            margin-top: 0;
            font-size: 14px;
            color: #ffcc00;
        }
        
        .tiktok-integration-notice {
            font-size: 12px;
            color: #ccc;
        }
        
        /* Notifications d'authentification */
        .auth-notification {
            position: fixed;
            right: -300px;
            top: 100px;
            background: linear-gradient(90deg, #330033, #5a0057);
            border-left: 3px solid #ff3366;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            padding: 15px;
            width: 250px;
            border-radius: 5px 0 0 5px;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .auth-notification.show {
            right: 0;
        }
        
        .auth-username {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .auth-amount {
            color: #ff3366;
            font-weight: bold;
            font-size: 18px;
        }
        
        /* Statut du syst√®me */
        .system-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #33ff33;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #ff3333;
        }
        
        .status-indicator.online {
            background-color: #33ff33;
        }
        
        /* Animation de pulsation pour la jauge */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .auth-gauge.pulse {
            animation: pulse 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
    <!-- Inclure les fichiers externes pour la gestion de l'authentification -->
    <script src="auth_gauge.js"></script>
    <script>
        /**
         * Gestion de la jauge d'authentification du syst√®me
         */
        
        // Configuration
        const REQUIRED_AMOUNT = 10; // Montant requis pour d√©bloquer l'acc√®s (en unit√©s)
        let totalProgress = 0; // Variable globale pour suivre la progression
        
        /**
         * Initialisation de la jauge d'authentification
         */
        function initAuthGauge() {
            console.log("Initialisation de la jauge d'authentification");
            
            // R√©cup√©rer les √©l√©ments pour v√©rifier qu'ils existent
            const fillBar = document.getElementById('auth-donation-fill');
            const percentText = document.getElementById('auth-donation-percent');
            
            if (fillBar) {
                console.log("√âl√©ment 'auth-donation-fill' trouv√©");
            } else {
                console.error("√âl√©ment 'auth-donation-fill' introuvable");
            }
            
            if (percentText) {
                console.log("√âl√©ment 'auth-donation-percent' trouv√©");
            } else {
                console.error("√âl√©ment 'auth-donation-percent' introuvable");
            }
            
            // Mettre √† jour l'affichage initial
            updateAuthGauge(0);
            
            // √âcouter les messages d'authentification externes
            window.addEventListener('message', function(event) {
                console.log("Message re√ßu:", event.data);
                // V√©rifier si le message contient des donn√©es d'authentification
                if (event.data && event.data.type === 'auth_progress') {
                    processAuthProgress(event.data.data);
                }
            });
        
            // V√©rifier la progression √† intervalles r√©guliers
            setInterval(checkAuthProgress, 5000);
            
            // Faire une v√©rification imm√©diate
            setTimeout(checkAuthProgress, 1000);
        }
        
        /**
         * Mise √† jour visuelle de la jauge d'authentification
         */
        function updateAuthGauge(amount) {
            console.log("Mise √† jour de la jauge d'authentification avec:", amount);
            
            // Obtenir les √©l√©ments de la jauge
            const fillBar = document.getElementById('auth-donation-fill');
            const percentText = document.getElementById('auth-donation-percent');
            
            // Calculer le pourcentage de progression
            const percentage = Math.min((amount / REQUIRED_AMOUNT) * 100, 100);
            console.log("Pourcentage calcul√©:", percentage);
            
            if (fillBar) {
                console.log("Mise √† jour de la barre de remplissage");
                // Mettre √† jour la barre de progression
                fillBar.style.width = percentage + '%';
            } else {
                console.error("√âl√©ment 'auth-donation-fill' introuvable");
            }
            
            if (percentText) {
                console.log("Mise √† jour du texte de pourcentage");
                // Mettre √† jour le texte du pourcentage
                percentText.textContent = Math.floor(percentage) + '%';
            } else {
                console.error("√âl√©ment 'auth-donation-percent' introuvable");
            }
            
            // V√©rifier si le seuil est atteint pour d√©bloquer
            if (amount >= REQUIRED_AMOUNT) {
                unlockAuthScreen();
            }
        }
        
        /**
         * Traitement d'une progression d'authentification
         */
        function processAuthProgress(progressData) {
            console.log("Traitement des donn√©es de progression:", progressData);
            
            // V√©rifier que les donn√©es contiennent les informations n√©cessaires
            if (progressData && progressData.username && progressData.amount) {
                // Convertir le montant en unit√©s si n√©cessaire
                const amount = parseFloat(progressData.amount);
                if (isNaN(amount)) {
                    console.error("Montant invalide:", progressData.amount);
                    return;
                }
        
                console.log("Ajout de", amount, "au total");
                // Mettre √† jour le total
                totalProgress += amount;
                
                // Mettre √† jour l'affichage
                updateAuthGauge(totalProgress);
                
                // Afficher une notification
                showAuthNotification(progressData.username, amount);
            } else {
                console.error("Donn√©es de progression incompl√®tes:", progressData);
            }
        }
        
        /**
         * Affichage d'une notification pour une progression d'authentification
         */
        function showAuthNotification(username, amount) {
            // Cr√©er un √©l√©ment de notification
            const notification = document.createElement('div');
            notification.className = 'auth-notification';
            notification.innerHTML = `
                <span class="auth-username">${username}</span>
                <span class="auth-amount">+${amount.toFixed(2)} unit√©s</span>
            `;
            
            // Ajouter la notification au DOM
            document.body.appendChild(notification);
            
            // Animer la notification
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);
            
            // Supprimer la notification apr√®s un d√©lai
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 500);
            }, 5000);
        }
        
        /**
         * V√©rification de la progression d'authentification √† intervalles r√©guliers
         */
        function checkAuthProgress() {
            console.log("V√©rification de la progression locale");
            
            // Utiliser une m√©thode alternative pour lire le fichier local
            fetch('/latest_auth_progress.json')
                .then(response => {
                    console.log("R√©ponse du serveur pour le fichier local:", response.status);
                    if (!response.ok) {
                        throw new Error('Fichier non disponible');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log("Donn√©es locales r√©cup√©r√©es:", data);
                    if (data && data.username && data.amount) {
                        // Traiter le don local
                        processAuthProgress(data);
                        // R√©initialiser le fichier pour √©viter de traiter le m√™me don plusieurs fois
                        resetLocalAuthProgress();
                    } else if (Object.keys(data).length === 0) {
                        console.log("Fichier local vide, pas de nouvelle progression");
                    } else {
                        console.error("Fichier local incomplet:", data);
                    }
                })
                .catch(error => {
                    // Silencieux en cas d'erreur - le fichier n'existe peut-√™tre pas encore
                    console.log('Pas de nouveau progr√®s d\'authentification local:', error.message);
                });
        }
        
        /**
         * R√©initialise le fichier de progression locale apr√®s traitement
         */
        function resetLocalAuthProgress() {
            // Appel au serveur pour r√©initialiser le fichier
            fetch('/api/reset-auth-progress', {
                method: 'POST'
            }).catch(error => {
                console.error('Erreur lors de la r√©initialisation de la progression:', error);
            });
        }
        
        /**
         * D√©bloque l'√©cran d'authentification quand le seuil est atteint
         */
        function unlockAuthScreen() {
            const authOverlay = document.getElementById('auth-overlay');
            if (authOverlay && authOverlay.style.display !== 'none') {
                // Animation de disparition
                authOverlay.style.opacity = '0';
                setTimeout(() => {
                    authOverlay.style.display = 'none';
                    // Masquer l'√©cran de chargement pour afficher l'exp√©rience 3D
                    const loadingScreen = document.getElementById('loading');
                    if (loadingScreen) {
                        loadingScreen.style.display = 'none';
                    }
                    
                    // Initialiser le jeu apr√®s l'authentification
                    if (typeof initializeAfterAuth === 'function') {
                        initializeAfterAuth();
                    } else {
                        // Initialiser ou afficher l'exp√©rience du bateau si elle est d√©j√† charg√©e
                        if (window.scene && window.camera && window.renderer) {
                            console.log("Exp√©rience 3D d√©j√† charg√©e, activation");
                            // Ajouter ici tout code n√©cessaire pour d√©marrer l'animation du bateau
                        } else {
                            console.log("Initialisation de l'exp√©rience 3D");
                            // Initialiser la sc√®ne Three.js si pas encore fait
                            initScene();
                        }
                    }
                }, 1000);
                
                console.log("Authentification r√©ussie, acc√®s d√©bloqu√©");
            }
        }
        
        // Initialiser la jauge d'authentification au chargement de la page
        document.addEventListener('DOMContentLoaded', initAuthGauge);
    </script>
</head>
<body>
    <!-- Overlay d'authentification -->
    <div class="auth-overlay" id="auth-overlay">
        <div class="auth-content">
            <div class="auth-logo">THE-DEPTHS v3.6.7</div>
            <div class="auth-message">
                AVERTISSEMENT: Vous √™tes sur le point d'acc√©der √† un r√©seau non autoris√©.<br><br>
                Ce terminal sert d'interface aux communications internes du groupe THE-DEPTHS.<br>
                Toute intrusion non autoris√©e sera trac√©e et signal√©e aux administrateurs.<br><br>
                Cet acc√®s est seulement destin√© aux membres confirm√©s.
            </div>
            
            <div class="auth-gauge">
                <h3 style="text-align: center;">Progression vers l'authentification</h3>
                <div class="donation-progress-container">
                    <div class="donation-label" style="text-align: center; display: block; width: 100%;">Progression : <span id="auth-donation-percent">0%</span></div>
                    <div class="donation-bar">
                        <div id="auth-donation-fill" style="width: 0%;"></div>
                    </div>
                </div>
                <div class="tiktok-integration-notice" style="text-align: center; width: 100%;">
                    Connexion aux syst√®mes de s√©curit√© en cours...
                </div>
            </div>
            
            <div style="text-align: center; width: 100%;">
                <button id="auth-accept" style="background: #111; color: #777; border: 1px solid #666; padding: 10px 20px; cursor: not-allowed; margin-top: 20px; opacity: 0.6; display: inline-block;">
                    AUTHENTIFICATION VERROUILL√âE
            </button>
            </div>
            
            <div class="auth-warning">
                SYST√àME DE S√âCURIT√â: L'acc√®s √† cette interface est strictement contr√¥l√©. Une authentification externe est n√©cessaire pour d√©bloquer le terminal.
            </div>
        </div>
    </div>
    
    <!-- Indicateur de statut du syst√®me -->
    <div class="system-status" id="system-status">
        <div class="status-indicator" id="status-light"></div>
        <span id="status-text">SYST√àME HORS LIGNE</span>
    </div>
    
    <div id="loading">
        <h2>Exploration des Profondeurs</h2>
            <div style="width: 200px; height: 20px; background: #333; border-radius: 10px; overflow: hidden; margin: 20px 0;">
                <div id="load-progress" style="width: 0%; height: 100%; background: linear-gradient(90deg, #ff0066, #ffcc00);"></div>
            </div>
            <div>Chargement de l'exp√©rience...</div>
    </div>
    
    <div id="details-button" onclick="window.open('exploration_details.html', '_blank')">
        <span>üìä</span>
        <span>D√©tails d'Exploration</span>
    </div>
    
    <div id="progress-display">
        <div style="display: flex; justify-content: space-between;">
            <span>PROGRESSION: </span>
            <span id="progress-percent">0%</span>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="story-progress"></div>
        </div>
        <div style="display: flex; justify-content: space-between;">
            <span>D√âBUT</span>
            <span>FIN</span>
        </div>
        <div style="text-align: center; font-size: 10px; color: #ffcc00; margin-top: 3px; text-shadow: 0 0 2px #000;">
            Votre participation stabilise la connexion et r√©v√®le de nouveaux myst√®res
        </div>
    </div>
    
    <div id="debug" style="display: none;">
        <h3>Contr√¥les Debug</h3>
        <button id="giftBtn">Simuler cadeau</button>
        <input id="commentInput" type="text" placeholder="Commentaire">
        <button id="commentBtn">Envoyer</button>
        <button id="likeBtn">Simuler likes</button>
        <button id="toggle-debug">Afficher contr√¥les avanc√©s</button>
        <div id="advanced-debug" style="display: none; margin-top: 10px;">
            <button id="debug-milestone">D√©bloquer milestone</button>
            <button id="debug-entity">Invoquer entit√©</button>
            <button id="debug-clue">R√©v√©ler indice</button>
            <button id="debug-event">D√©clencher √©v√©nement</button>
            <button id="debug-vote">Lancer vote</button>
        </div>
    </div>
    
    <div id="donation-panel">
        <h3 style="margin-top: 0; text-align: center;">Les Profondeurs</h3>
        <button id="open-donation-simulator" style="width:100%; margin-bottom:5px; font-size:10px; padding:4px;">
            Ouvrir le Simulateur de Dons
        </button>
        <div style="font-size:9px; margin-bottom:5px; text-align:center;">
            Pour simuler un don, utilisez le simulateur
        </div>
        <button id="open-tiktok-config" style="width:100%; margin-bottom:10px; font-size:10px; padding:4px; background-color:#ff3366;">
            Configurer API TikTok
        </button>
        <div style="display: flex; justify-content: space-between;">
            <span>Progression narrative:</span>
            <span id="progress-percent">0%</span>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="story-progress"></div>
        </div>
        <div style="display: flex; justify-content: space-between;">
            <span>Prochain palier:</span>
            <span id="next-milestone-amount">500 unit√©s</span>
        </div>
        <div id="story-milestone">
            "Le passage vers le secteur 2 semble bloqu√©. Une intervention externe est n√©cessaire pour r√©tablir l'acc√®s..."
        </div>
        <div style="margin-top: 15px;">
            <div style="display: flex; justify-content: space-between;">
                <span>Total des contributions:</span>
                <span id="total-donations">0 unit√©s</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
                <span>Myst√®res r√©solus:</span>
                <span id="solved-mysteries">0/13</span>
            </div>
        </div>
    </div>
    
    <div id="donor-wall">
        <h4 style="margin-top: 0;">Contributeurs R√©cents</h4>
        <div id="donor-list">
            <!-- Les contributeurs seront ajout√©s ici dynamiquement -->
        </div>
    </div>
    
    <div id="top100-panel">
        <h4>Top 100 Explorateurs</h4>
        <div id="top100-list">
            <!-- La liste des 100 meilleurs sera ici -->
        </div>
    </div>
    
    <div id="narrative-display"></div>
    
    <div id="clue-notification">Indice trouv√©: Enigme #172</div>
    
    <div id="event-counter"></div>
    
    <div id="vote-panel">
        <h4 style="margin-top: 0;">Vote Communautaire</h4>
        <p id="vote-question">Quelle porte le voyageur devrait-il ouvrir ensuite?</p>
        <div class="vote-option" data-option="1">
            <div style="display: flex; justify-content: space-between;">
                <span>Porte avec symbole spirale</span>
                <span>30%</span>
            </div>
            <div class="vote-bar">
                <div class="vote-fill" style="width: 30%"></div>
            </div>
        </div>
        <div class="vote-option" data-option="2">
            <div style="display: flex; justify-content: space-between;">
                <span>Porte rouge clignotante</span>
                <span>45%</span>
            </div>
            <div class="vote-bar">
                <div class="vote-fill" style="width: 45%"></div>
            </div>
        </div>
        <div class="vote-option" data-option="3">
            <div style="display: flex; justify-content: space-between;">
                <span>Porte avec marques de griffes</span>
                <span>25%</span>
            </div>
            <div class="vote-bar">
                <div class="vote-fill" style="width: 25%"></div>
            </div>
        </div>
        <p style="font-size: 12px; text-align: center; margin-top: 10px;">Votre interaction compte comme un vote. Fin dans <span id="vote-timer">02:45</span></p>
    </div>

    <!-- Charger Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // D√©finir les variables globales
        window.scene = null;
        window.camera = null;
        window.renderer = null;
        window.boat = null;
        window.doors = [];
        window.segments = [];
        window.boatSpeed = 0.05;
        window.moveDirection = { x: 0, z: 1 };
        // Variable pour stocker les r√©f√©rences aux fen√™tres ouvertes
        window.detailWindows = [];
        
        // Variables pour le syst√®me de narration et de dons
        window.totalDonations = 0;
        window.currentSeason = 1;
        window.currentEpisode = 1;
        window.currentMilestoneIndex = 0;
        window.storyProgress = 0;
        window.mysteryElements = {};
        window.discoveredClues = [];
        window.solvedMysteries = 0;
        window.activatedDoors = 0;
        window.specialDoors = {};
        window.activeVote = null;
        
        // Constantes
        const TUNNEL_RADIUS = 5;
        const TUNNEL_LENGTH = 20;
        const WATER_LEVEL = -2;
        
        // D√©finition des paliers de donation pour le progr√®s narratif
        const STORY_MILESTONES = [
            { amount: 100, title: "Prologue: L'entr√©e", description: "Les premi√®res portes commencent √† r√©v√©ler d'√©tranges ph√©nom√®nes...", unlocksFunction: unlockPrologue },
            { amount: 500, title: "Secteur 2: Murmures", description: "Des voix lointaines r√©sonnent dans l'eau. Elles semblent raconter des fragments d'histoires...", unlocksFunction: unlockSector2 },
            { amount: 1500, title: "Secteur 3: M√©moires", description: "Des symboles apparaissent sur certaines portes. Ils semblent former un code √† d√©chiffrer...", unlocksFunction: unlockSector3 },
            { amount: 3000, title: "Secteur 4: R√©sonance", description: "L'eau commence √† vibrer √† intervalles r√©guliers. Une pr√©sence se fait sentir dans les profondeurs...", unlocksFunction: unlockSector4 },
            { amount: 5000, title: "Confrontation Mineure: L'Observateur", description: "Une entit√© myst√©rieuse semble suivre le bateau. Ses intentions sont inconnues...", unlocksFunction: unlockMinorEntity },
            { amount: 8000, title: "Secteur 5: Distorsion", description: "La r√©alit√© semble se plier. Certaines portes m√®nent √† des lieux impossibles...", unlocksFunction: unlockSector5 },
            { amount: 12000, title: "Secteur 6: Convergence", description: "Les indices commencent √† converger. Un sch√©ma plus large se dessine...", unlocksFunction: unlockSector6 },
            { amount: 18000, title: "Confrontation Majeure: Le Gardien", description: "Une pr√©sence ancienne bloque le chemin. Elle doit √™tre confront√©e pour continuer...", unlocksFunction: unlockMajorEntity },
            { amount: 25000, title: "Secteur 7: V√©rit√©", description: "Les derniers fragments du myst√®re se d√©voilent. La v√©rit√© est presque √† port√©e...", unlocksFunction: unlockSector7 },
            { amount: 35000, title: "Finale: R√©v√©lation", description: "Le myst√®re final des Profondeurs est sur le point d'√™tre r√©v√©l√©...", unlocksFunction: unlockFinale }
        ];
        
        // D√©finition des niveaux de contributeurs
        const DONOR_TIERS = [
            { min: 1, max: 49, name: "Explorateur", class: "donor-common" },
            { min: 50, max: 199, name: "Chercheur", class: "donor-rare" },
            { min: 200, max: 999, name: "√âclaireur", class: "donor-epic" },
            { min: 1000, max: Infinity, name: "Illumin√©", class: "donor-legendary" }
        ];
        
        // Base de donn√©es des √©l√©ments narratifs
        const STORY_ELEMENTS = {
            clues: [
                { id: "C001", text: "Num√©ro grav√©: 7-3-9-4-2", category: "sequence", linkedMystery: "M003" },
                { id: "C002", text: "Inscription: 'Le cercle s'√©largit mais revient toujours au centre'", category: "phrase", linkedMystery: "M001" },
                { id: "C003", text: "Symbole r√©current: ≈ìil travers√© par une ligne verticale", category: "symbol", linkedMystery: "M002" },
                { id: "C004", text: "Date r√©p√©titive: 22.07.1976", category: "date", linkedMystery: "M005" },
                { id: "C005", text: "Coordonn√©es fragment√©es: 47¬∞N 13...", category: "location", linkedMystery: "M004" },
                { id: "C006", text: "Mot invers√©: RUEGREMBUS", category: "word", linkedMystery: "M002" },
                { id: "C007", text: "Sch√©ma circulaire avec 9 points", category: "pattern", linkedMystery: "M001" },
                { id: "C008", text: "R√©f√©rence: 'Projet Abyssus'", category: "name", linkedMystery: "M007" },
                { id: "C009", text: "√âquation: 2x¬≤ + 3x - ‚àö(4) = 0", category: "math", linkedMystery: "M003" },
                { id: "C010", text: "Fragment audio: voix distordue r√©p√©tant 'le sixi√®me cycle'", category: "audio", linkedMystery: "M006" },
                { id: "C011", text: "Phrase cod√©e: VGSPJVYMREGIVPIVW", category: "cipher", linkedMystery: "M005" },
                { id: "C012", text: "Motif de lumi√®res: court-court-long-long-court", category: "pattern", linkedMystery: "M004" }
            ],
            mysteries: [
                { id: "M001", title: "Le Motif Circulaire", requiredClues: ["C002", "C007"], solved: false, reward: "R√©v√®le l'origine du tunnel" },
                { id: "M002", title: "L'Entit√© Observatrice", requiredClues: ["C003", "C006"], solved: false, reward: "D√©bloque une porte sp√©ciale" },
                { id: "M003", title: "La S√©quence Math√©matique", requiredClues: ["C001", "C009"], solved: false, reward: "Permet de pr√©voir certains √©v√©nements" },
                { id: "M004", title: "Les Signaux", requiredClues: ["C005", "C012"], solved: false, reward: "R√©v√®le un mode de communication" },
                { id: "M005", title: "L'Incident Initial", requiredClues: ["C004", "C011"], solved: false, reward: "Explique pourquoi le tunnel existe" },
                { id: "M006", title: "Les Cycles Temporels", requiredClues: ["C010"], solved: false, reward: "D√©bloque une vision du pass√©/futur" },
                { id: "M007", title: "Les Origines du Projet", requiredClues: ["C008"], solved: false, reward: "R√©v√®le qui a cr√©√© cette exp√©rience" }
            ],
            narrativeFragments: [
                "Les enregistrements indiquent que le projet a √©t√© abandonn√© suite √† une 'contamination'.",
                "Le tunnel n'a pas √©t√© construit. Il est apparu spontan√©ment le 22 juillet 1976.",
                "Certains chercheurs affirment avoir vu leur propre reflet vieilli de plusieurs d√©cennies.",
                "L'eau n'est pas r√©ellement de l'eau. Sa composition mol√©culaire est inconnue.",
                "Les portes apparaissaient et disparaissaient m√™me avant notre arriv√©e.",
                "Les tests ont r√©v√©l√© que le temps s'√©coule diff√©remment √† diverses profondeurs.",
                "√âquipe d'exploration #7: 4 entr√©s, 5 revenus. Anomalie consign√©e.",
                "Les manifestations semblent r√©agir aux √©motions collectives des observateurs.",
                "Th√©orie: nous ne sommes pas dans un lieu physique mais dans une projection mentale collective.",
                "Le sixi√®me cycle s'ach√®vera quand le t√©moin final comprendra sa fonction."
            ]
        };
        
        // ==========================================
        // FONCTIONS D'INITIALISATION
        // ==========================================
        
        // Gestion du redimensionnement de la fen√™tre
        function onWindowResize() {
            // Mettre √† jour la cam√©ra
            window.camera.aspect = window.innerWidth / window.innerHeight;
            window.camera.updateProjectionMatrix();
            
            // Mettre √† jour le renderer
            window.renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Initialisation de l'application
        function init() {
            // Cr√©er la sc√®ne Three.js
            window.scene = new THREE.Scene();
            
            // Cr√©er la cam√©ra
            window.camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            window.camera.position.set(0, 1, -5);
            
            // Cr√©er le renderer
            window.renderer = new THREE.WebGLRenderer({ antialias: false });
            window.renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(window.renderer.domElement);
            
            // Ajouter une lumi√®re ambiante
            const light = new THREE.AmbientLight(0x444444);
            window.scene.add(light);
            
            // Effet de brouillard pour l'atmosph√®re
            window.scene.fog = new THREE.FogExp2(0x000000, 0.035);
            
            // Cr√©er le bateau
            window.boat = createBoat();
            
            // Cr√©er le tunnel initial
            for (let i = 0; i < 3; i++) {
                createSegment(i * TUNNEL_LENGTH);
            }
            
            // G√©rer le redimensionnement
            window.addEventListener('resize', onWindowResize);
            
            // Configurer le debug et les contr√¥les de simulation
            setupDebug();
            setupDonationSystem();
            setupVoteSystem();
            
            // Masquer l'√©cran de chargement
            const loadingScreen = document.getElementById('loading');
            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 500);
            }, 2000);
            
            // Afficher le message d'introduction apr√®s un d√©lai
            setTimeout(showNarrativeMessage, 3000, "Bienvenue dans Les Profondeurs. Les portes cachent des secrets. √Ä vous de les d√©couvrir...", 8000);
            
            // Initialiser les variables de narration
            updateMilestoneDisplay();
            
            // Cr√©er le panneau d'objectifs
            createObjectivesPanel();
            
            // Initialiser les panneaux avec d√©filement automatique (activation directe)
            const historyList = document.getElementById('story-history-list');
            const leaderboardList = document.getElementById('leaderboard-list');
            const top100List = document.getElementById('top100-list');
            
            // Activer l'auto-d√©filement pour l'historique
            if (historyList) {
                const historyPanel = document.getElementById('story-history-panel');
                if (historyPanel) historyPanel.style.display = 'block';
            }
            
            // Activer l'auto-d√©filement pour le leaderboard
            if (leaderboardList) {
                const leaderboardPanel = document.getElementById('leaderboard-panel');
                if (leaderboardPanel) leaderboardPanel.style.display = 'block';
            }
            
            // Activer l'auto-d√©filement pour le top100
            if (top100List) {
                const top100Panel = document.getElementById('top100-panel');
                if (top100Panel) top100Panel.style.display = 'block';
            }
            
            // Ajouter quelques entr√©es initiales dans l'historique si vide
            if (!window.storyHistory || window.storyHistory.length === 0) {
                addToStoryHistory('milestone', 'Bienvenue dans Les Profondeurs');
                addToStoryHistory('discovery', 'Explorez les tunnels √† la recherche d\'indices');
                addToStoryHistory('event', 'Attention aux entit√©s myst√©rieuses');
            }
            
            // D√©marrer l'animation
            animate();
            
            // Ajouter un gestionnaire pour le bouton d√©tails d'exploration
            const detailsButton = document.getElementById('details-button');
            if (detailsButton) {
                detailsButton.addEventListener('click', function() {
                    const detailWindow = window.open('exploration_details.html', '_blank');
                    if (detailWindow) {
                        window.detailWindows.push(detailWindow);
                    }
                });
            }
        }
        
        // Animation de chargement
        function simulateLoading() {
                let progress = 5;
                const loadProgressBar = document.getElementById('load-progress');
                
                const interval = setInterval(() => {
                    progress += Math.floor(Math.random() * 8) + 3;
                    if (progress >= 100) {
                        progress = 100;
                        clearInterval(interval);
                    }
                    loadProgressBar.style.width = progress + '%';
                }, 300);
        }
        
        // Configuration du panneau de debug
        function setupDebug() {
            if (window.location.search.includes('debug=true')) {
                const debugPanel = document.getElementById('debug');
                debugPanel.style.display = 'block';
                
                // Toggle des contr√¥les avanc√©s
                document.getElementById('toggle-debug').addEventListener('click', () => {
                    const advancedDebug = document.getElementById('advanced-debug');
                    advancedDebug.style.display = advancedDebug.style.display === 'none' ? 'block' : 'none';
                });
                
                // Bouton pour simuler un cadeau/don
                document.getElementById('giftBtn').addEventListener('click', () => {
                    const randomAmount = Math.floor(Math.random() * 100) + 5;
                    simulateDonation("Viewer" + Math.floor(Math.random() * 1000), randomAmount);
                });
                
                // Bouton pour envoyer un commentaire
                document.getElementById('commentBtn').addEventListener('click', () => {
                    const text = document.getElementById('commentInput').value.toLowerCase();
                    handleComment(text);
                    document.getElementById('commentInput').value = '';
                });
                
                // Bouton pour simuler des likes
                document.getElementById('likeBtn').addEventListener('click', () => {
                    // Petit effet visuel
                    window.camera.position.x += (Math.random() - 0.5) * 0.1;
                    window.camera.position.y += (Math.random() - 0.5) * 0.1;
                });
                
                // Contr√¥les avanc√©s
                document.getElementById('debug-milestone').addEventListener('click', () => {
                    unlockNextMilestone("Debug");
                });
                
                document.getElementById('debug-entity').addEventListener('click', () => {
                    spawnSpecialEntity();
                });
                
                document.getElementById('debug-clue').addEventListener('click', () => {
                    revealRandomClue();
                });
                
                document.getElementById('debug-event').addEventListener('click', () => {
                    triggerSpecialEvent();
                });
                
                document.getElementById('debug-vote').addEventListener('click', () => {
                    startVote();
                });
            }
        }
        
        // Configuration du syst√®me de dons
        function setupDonationSystem() {
            // V√©rifier si le bouton de simulation de dons existe avant d'ajouter l'√©couteur
            const simDonationBtn = document.getElementById('sim-donation');
            if (simDonationBtn) {
                simDonationBtn.addEventListener('click', () => {
                    const amountInput = document.getElementById('donation-amount');
                    const amount = parseInt(amountInput.value);
                    
                    if (amount && amount > 0) {
                        const username = "Viewer" + Math.floor(Math.random() * 10000);
                        simulateDonation(username, amount);
                        amountInput.value = '';
                    }
                });
            }
            
            // Configuration du bouton d'ouverture du simulateur de dons
            const openDonationSimBtn = document.getElementById('open-donation-simulator');
            if (openDonationSimBtn) {
                openDonationSimBtn.addEventListener('click', () => {
                    openDonationSimulator();
                });
            }
            
            // Configuration du bouton d'ouverture de la configuration TikTok
            const openTikTokConfigBtn = document.getElementById('open-tiktok-config');
            if (openTikTokConfigBtn) {
                openTikTokConfigBtn.addEventListener('click', () => {
                    openTikTokConfig();
                });
            }
            
            // Initialisation des valeurs
            updateDonationDisplay();
            
            // Charger la configuration TikTok s'il y en a une
            loadTikTokConfig();
        }
        
        // Fonction pour ouvrir le simulateur de dons (sans cr√©er de fen√™tre popup)
        function openDonationSimulator() {
            // V√©rifier si un panneau de simulation existe d√©j√† et le supprimer s'il est d√©j√† affich√©
            const existingPanel = document.getElementById('inline-donation-panel');
            if (existingPanel) {
                existingPanel.remove();
                return;
            }
            
            // Cr√©er un panneau flottant pour le simulateur de dons int√©gr√©
            const panel = document.createElement('div');
            panel.id = 'inline-donation-panel';
            panel.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 300px;
                background: rgba(0, 0, 0, 0.9);
                border: 1px solid #ff3366;
                z-index: 1000;
                padding: 15px;
                color: white;
                border-radius: 5px;
                box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            `;
            
            // Ajouter le contenu du simulateur
            panel.innerHTML = `
                <h3 style="text-align: center; margin-top: 0;">Simulateur de Dons</h3>
                <button id="close-simulator" style="position: absolute; top: 5px; right: 5px; background: none; border: none; color: #fff; cursor: pointer; font-size: 16px;">√ó</button>
                <div style="margin-bottom: 15px;">
                    <label>Nom d'utilisateur:</label>
                    <input type="text" id="sim-username" value="Utilisateur${Math.floor(Math.random() * 1000)}" style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label>Montant:</label>
                    <input type="number" id="sim-amount" value="5" min="1" max="1000" style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label>Message (optionnel):</label>
                    <input type="text" id="sim-message" placeholder="Message avec votre don..." style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <button id="donate-2" style="flex: 1; margin-right: 5px; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+2‚Ç¨</button>
                    <button id="donate-5" style="flex: 1; margin-right: 5px; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+5‚Ç¨</button>
                    <button id="donate-10" style="flex: 1; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+10‚Ç¨</button>
                </div>
                <button id="send-donation" style="width: 100%; margin-top: 15px; background: #ff3366; border: none; color: white; padding: 10px; cursor: pointer;">Simuler le Don</button>
            `;
            
            // Ajouter le panneau au document
            document.body.appendChild(panel);
            
            // G√©rer la fermeture du panneau
            document.getElementById('close-simulator').addEventListener('click', () => {
                panel.remove();
            });
            
            // G√©rer les boutons de montant pr√©d√©finis
            document.getElementById('donate-2').addEventListener('click', () => {
                document.getElementById('sim-amount').value = "2";
            });
            
            document.getElementById('donate-5').addEventListener('click', () => {
                document.getElementById('sim-amount').value = "5";
            });
            
            document.getElementById('donate-10').addEventListener('click', () => {
                document.getElementById('sim-amount').value = "10";
            });
            
            // G√©rer l'envoi du don
            document.getElementById('send-donation').addEventListener('click', async () => {
                const username = document.getElementById('sim-username').value || `Utilisateur${Math.floor(Math.random() * 1000)}`;
                const amount = parseFloat(document.getElementById('sim-amount').value) || 5;
                const message = document.getElementById('sim-message').value || '';
                
                if (amount <= 0) {
                    alert('Veuillez entrer un montant positif.');
                    return;
                }
                
                try {
                    // Simuler le don via l'API
                    const response = await fetch('/api/simulate/donation', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ username, amount, message })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        // Fermer le panneau apr√®s un don r√©ussi
                        panel.remove();
                        
                        // Appliquer directement le don √† l'interface actuelle
                        simulateDonation(username, amount);
                    } else {
                        console.error('Erreur lors de la simulation du don:', data.message);
                        alert('Erreur lors de la simulation du don: ' + data.message);
                    }
                } catch (error) {
                    console.error('Erreur lors de la simulation du don:', error);
                    alert('Erreur lors de la simulation du don.');
                }
            });
        }
        
        // Ouvrir la page de configuration de l'API TikTok
        function openTikTokConfig() {
            const width = 800;
            const height = 700;
            const left = (window.innerWidth - width) / 2;
            const top = (window.innerHeight - height) / 2;
            
            const popup = window.open('tiktok_api_config.html', 'TikTokConfig', 
                `width=${width},height=${height},left=${left},top=${top},resizable=yes`);
            
            if (popup) {
                window.tikTokConfigPopup = popup;
            }
        }
        
        // Charger la configuration TikTok depuis localStorage
        function loadTikTokConfig() {
            const savedConfig = localStorage.getItem('tiktokApiConfig');
            
            if (savedConfig) {
                try {
                    window.tikTokConfig = JSON.parse(savedConfig);
                    console.log('Configuration TikTok charg√©e:', window.tikTokConfig);
                } catch (error) {
                    console.error('Erreur lors du chargement de la configuration TikTok:', error);
                }
            }
        }
        
        // Mettre √† jour la configuration TikTok (appel√© depuis la page de configuration)
        function updateTikTokConfig(config) {
            window.tikTokConfig = config;
            console.log('Configuration TikTok mise √† jour:', config);
        }
        
        // Traiter un √©v√©nement TikTok (appel√© depuis la page de configuration ou par l'API)
        function processTikTokEvent(event) {
            console.log('√âv√©nement TikTok re√ßu:', event);
            
            switch (event.type) {
                case 'donation':
                    // Convertir le montant en pi√®ces/diamants en euros
                    const convertedAmount = event.convertedAmount || 
                        (event.amount * (window.tikTokConfig?.donationConversion || 0.01));
                    
                    // Simuler un don avec le montant converti
                    simulateDonation(event.username, convertedAmount, event.giftName || 'Don TikTok');
                    
                    // Am√©lioration: V√©rifier si c'est un don majeur pour des effets sp√©ciaux
                    if (convertedAmount >= 50) {
                        triggerSpecialEvent(event.username);
                    } else if (convertedAmount >= 20) {
                        spawnSpecialEntity();
                    }
                    break;
                    
                case 'subscription':
                    // Traiter l'abonnement comme un don avec un montant fixe
                    const subValue = event.value || 
                        (window.tikTokConfig?.subscriptionValue || 4.99);
                    
                    simulateDonation(event.username, subValue, 'Abonnement');
                    
                    // Am√©lioration: Ajouter un indice sp√©cial pour les abonn√©s
                    revealSpecialClue(event.username);
                    break;
                    
                case 'comment':
                    // Traiter les commentaires pour d√©tecter les mots-cl√©s
                    if (window.tikTokConfig?.enableComments) {
                        handleComment(event.comment, event.username);
                    }
                    break;
                    
                case 'follow':
                    // Ajouter au journal d'exploration
                    addToStoryHistory('event', `${event.username} suit maintenant le stream!`);
                    break;
                    
                case 'share':
                    // R√©compenser le partage avec un petit don virtuel
                    simulateDonation(event.username, 1, 'Partage');
                    
                    // Ajouter au journal d'exploration
                    addToStoryHistory('event', `${event.username} a partag√© le stream!`);
                    break;
                    
                case 'like':
                    // Reconna√Ætre les likes en masse
                    if (event.likeCount && event.likeCount > 5) {
                        // D√©clencher des effets mineurs d'ambiance
                        triggerAmbientEffect(event.likeCount);
                        
                        // Ajouter au journal d'exploration pour les likes importants
                        addToStoryHistory('event', `${event.username} a envoy√© ${event.likeCount} likes!`);
                    }
                    break;
                    
                case 'importantComment':
                    // Traiter les commentaires importants sp√©cifiquement
                    handleImportantComment(event.comment, event.username);
                    break;
                    
                case 'memberJoin':
                    // Membre rejoignant le stream
                    addToStoryHistory('discovery', `${event.username} a rejoint l'exploration!`);
                    break;
            }
        }
        
        // Fonction pour r√©v√©ler un indice sp√©cial aux abonn√©s
        function revealSpecialClue(username) {
            // S√©lectionner un indice pas encore d√©couvert
            const unrevealedClues = STORY_ELEMENTS.clues.filter(clue => !window.discoveredClues.includes(clue.id));
            
            if (unrevealedClues.length > 0) {
                const randomIndex = Math.floor(Math.random() * unrevealedClues.length);
                const clue = unrevealedClues[randomIndex];
                
                // R√©v√©ler un indice pour l'utilisateur
                revealClue(clue.id, username);
                
                // Ajouter un message sp√©cial dans le journal
                addToStoryHistory('discovery', `Indice sp√©cial r√©v√©l√© √† ${username}: "${clue.text}"`);
            }
        }
        
        // Fonction pour g√©rer les commentaires importants
        function handleImportantComment(comment, username) {
            // √âvaluer si le commentaire contient des mots-cl√©s li√©s √† l'histoire
            const storyKeywords = [
                'myst√®re', 'cr√©ature', 'secret', 'porte', 'symbole', 'code', 
                '√©nigme', 'indice', 'lumi√®re', 'ombre', 'profondeur',
                'ab√Æme', 'portail', 'anciens', 'artefact', 'cl√©'
            ];
            
            const lowerComment = comment.toLowerCase();
            const matchedKeywords = storyKeywords.filter(keyword => lowerComment.includes(keyword));
            
            if (matchedKeywords.length >= 2) {
                // Commentaire tr√®s pertinent pour l'histoire
                addToStoryHistory('discovery', `Observation de ${username}: "${comment}"`);
                
                // Potentiellement r√©v√©ler un indice bas√© sur ce commentaire
                if (Math.random() < 0.3) {
                    // 30% de chance de r√©v√©ler un indice
                    setTimeout(() => {
                        revealRandomClue(username);
                    }, 3000 + Math.random() * 5000);
                }
                
                // Pour les commentaires tr√®s pertinents, ajouter un effet visuel subtil
                flashCameraEffect(0.3);
            }
        }
        
        // Fonction pour d√©clencher des effets d'ambiance bas√©s sur l'activit√© TikTok
        function triggerAmbientEffect(intensity) {
            // L'intensit√© repr√©sente combien l'effet doit √™tre prononc√©, bas√© sur les likes/interactions
            intensity = Math.min(intensity / 10, 1.0); // Normaliser entre 0 et 1
            
            // Types d'effets d'ambiance
            const effects = [
                'flicker', // Effet de vacillement des lumi√®res
                'ripple',  // Effet d'ondulation sur l'eau
                'mist',    // Effet de brume temporaire
                'whisper'  // Sons subtils d'ambiance
            ];
            
            // S√©lectionner un effet al√©atoire
            const effect = effects[Math.floor(Math.random() * effects.length)];
            
            // Appliquer l'effet selon le type
            switch (effect) {
                case 'flicker':
                    // Faire vaciller les lumi√®res dans le tunnel
                    flickerLights(intensity);
                    break;
                case 'ripple':
                    // Cr√©er des ondulations sur l'eau
                    createWaterRipple(intensity);
                    break;
                case 'mist':
                    // Ajouter une brume temporaire
                    addTemporaryMist(intensity);
                    break;
                case 'whisper':
                    // Jouer des sons d'ambiance
                    playAmbientSound(intensity);
                    break;
            }
        }
        
        // Faire vaciller les lumi√®res du tunnel
        function flickerLights(intensity) {
            // Trouver toutes les lumi√®res dans la sc√®ne
            const lights = [];
            window.scene.traverse(function(object) {
                if (object.userData && object.userData.light) {
                    lights.push(object.userData.light);
                }
            });
            
            // Aucune lumi√®re trouv√©e
            if (lights.length === 0) return;
            
            // Sauvegarder les intensit√©s d'origine
            const originalIntensities = lights.map(light => light.intensity);
            
            // Nombre de vacillements
            const flickerCount = Math.floor(3 + intensity * 7);
            
            // Fonction pour un vacillement al√©atoire
            function singleFlicker(index) {
                if (index >= flickerCount) {
                    // Restaurer les intensit√©s d'origine
                    lights.forEach((light, i) => { 
                        if (light) light.intensity = originalIntensities[i]; 
                    });
                    return;
                }
                
                // Appliquer un vacillement al√©atoire √† chaque lumi√®re
                lights.forEach((light, i) => {
                    if (light) {
                        const randomFactor = 0.3 + Math.random() * 0.7;
                        light.intensity = originalIntensities[i] * randomFactor;
                    }
                });
                
                // Planifier le prochain vacillement
                setTimeout(() => singleFlicker(index + 1), 50 + Math.random() * 150);
            }
            
            // D√©marrer la s√©quence de vacillement
            singleFlicker(0);
        }
        
        // Cr√©er des ondulations sur l'eau
        function createWaterRipple(intensity) {
            if (!window.waterMesh) return;
            
            // Cr√©er un effet d'ondulation sur l'eau
            const rippleDuration = 2000 + intensity * 3000; // 2-5 secondes selon l'intensit√©
            const startTime = Date.now();
            const originalY = window.waterMesh.position.y;
            
            // Fonction d'animation pour l'ondulation
            function animateRipple() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / rippleDuration;
                
                if (progress >= 1) {
                    // Restaurer la position de l'eau
                    window.waterMesh.position.y = originalY;
                    return;
                }
                
                // Calcul de l'ondulation
                const amplitude = 0.05 * intensity;
                const frequency = 6 + intensity * 4;
                const ripple = amplitude * Math.sin(frequency * progress * Math.PI) * (1 - progress);
                
                // Appliquer l'ondulation
                window.waterMesh.position.y = originalY + ripple;
                
                // Continuer l'animation
                requestAnimationFrame(animateRipple);
            }
            
            // D√©marrer l'animation
            animateRipple();
        }
        
        // Ajouter de la brume temporaire
        function addTemporaryMist(intensity) {
            // V√©rifier si la brume existe d√©j√†
            if (window.mistMesh) return;
            
            // Cr√©er une sph√®re de brume semi-transparente
            const mistGeometry = new THREE.SphereGeometry(10, 16, 16);
            const mistMaterial = new THREE.MeshBasicMaterial({
                color: 0xccccff,
                transparent: true,
                opacity: 0
            });
            
            const mistMesh = new THREE.Mesh(mistGeometry, mistMaterial);
            mistMesh.position.set(window.boat.position.x, 0, window.boat.position.z);
            window.scene.add(mistMesh);
            window.mistMesh = mistMesh;
            
            // Dur√©e de la brume
            const mistDuration = 3000 + intensity * 4000; // 3-7 secondes
            const startTime = Date.now();
            
            // Fonction d'animation pour la brume
            function animateMist() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / mistDuration;
                
                if (progress >= 1) {
                    // Supprimer la brume
                    window.scene.remove(mistMesh);
                    window.mistMesh = null;
                    return;
                }
                
                // Animation de l'opacit√© (apparition puis disparition)
                let opacity;
                if (progress < 0.3) {
                    // Apparition
                    opacity = (progress / 0.3) * 0.3 * intensity;
                } else if (progress > 0.7) {
                    // Disparition
                    opacity = ((1 - progress) / 0.3) * 0.3 * intensity;
                } else {
                    // Plateau
                    opacity = 0.3 * intensity;
                }
                
                // Appliquer l'opacit√©
                mistMaterial.opacity = opacity;
                
                // Continuer l'animation
                requestAnimationFrame(animateMist);
            }
            
            // D√©marrer l'animation
            animateMist();
        }
        
        // Jouer un son d'ambiance
        function playAmbientSound(intensity) {
            // Si le son est d√©sactiv√©, ne rien faire
            if (!window.audioEnabled) return;
            
            // S√©lectionner un son d'ambiance al√©atoire
            const ambientSounds = [
                'whisper', 'creak', 'drip', 'distant_echo'
            ];
            
            const sound = ambientSounds[Math.floor(Math.random() * ambientSounds.length)];
            const volume = 0.1 + intensity * 0.2; // Volume entre 0.1 et 0.3
            
            // Cr√©er un √©l√©ment audio
            const audio = new Audio();
            audio.volume = volume;
            
            // D√©finir la source du son
            switch (sound) {
                case 'whisper':
                    audio.src = 'sounds/whisper.mp3';
                    break;
                case 'creak':
                    audio.src = 'sounds/creak.mp3';
                    break;
                case 'drip':
                    audio.src = 'sounds/drip.mp3';
                    break;
                case 'distant_echo':
                    audio.src = 'sounds/echo.mp3';
                    break;
            }
            
            // Jouer le son
            try {
                audio.play().catch(error => {
                    console.warn('Impossible de jouer le son:', error);
                });
            } catch (error) {
                console.warn('Erreur lors de la lecture du son:', error);
            }
        }
        
        // Configuration du syst√®me de vote
        function setupVoteSystem() {
            // Gestion des clics sur les options de vote
            document.querySelectorAll('.vote-option').forEach(option => {
                option.addEventListener('click', (e) => {
                    const optionIndex = e.currentTarget.getAttribute('data-option');
                    voteForOption(optionIndex);
                });
            });
        }
        
        // ==========================================
        // FONCTIONS DE CR√âATION D'OBJETS 3D
        // ==========================================
        
        // Cr√©er une barque avec un mod√®le Three.js d√©taill√©
        function createBoat() {
            const boat = new THREE.Group();
            
            // Coque principale - forme d'une barque traditionnelle
            const hullShape = new THREE.Shape();
            // D√©finir un contour en forme de barque vue de dessus
            hullShape.moveTo(-0.7, -1.2);
            hullShape.quadraticCurveTo(-0.2, -1.5, 0, -1.5);
            hullShape.quadraticCurveTo(0.2, -1.5, 0.7, -1.2);
            hullShape.quadraticCurveTo(0.9, -0.8, 0.9, 0);
            hullShape.quadraticCurveTo(0.9, 0.8, 0.7, 1.2);
            hullShape.quadraticCurveTo(0.2, 1.5, 0, 1.5);
            hullShape.quadraticCurveTo(-0.2, 1.5, -0.7, 1.2);
            hullShape.quadraticCurveTo(-0.9, 0.8, -0.9, 0);
            hullShape.quadraticCurveTo(-0.9, -0.8, -0.7, -1.2);
            
            // Extruder la forme pour cr√©er la coque 3D
            const extrudeSettings = {
                steps: 2,
                depth: 0.5,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.1,
                bevelOffset: 0,
                bevelSegments: 3
            };
            
            const hullGeometry = new THREE.ExtrudeGeometry(hullShape, extrudeSettings);
            
            // Cr√©er un mat√©riau pour la coque avec texture de bois
            const hullMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.7,
                metalness: 0.2
            });
            
            // Cr√©er un effet de veine de bois (proc√©dural)
            const woodTexture = createWoodTexture();
            hullMaterial.map = woodTexture;
            
            const hull = new THREE.Mesh(hullGeometry, hullMaterial);
            hull.rotation.x = Math.PI / 2; // Orienter correctement la barque
            boat.add(hull);
            
            // Ajouter des bancs transversaux
            const benchMaterial = new THREE.MeshStandardMaterial({
                color: 0x964B00,
                roughness: 0.8,
                metalness: 0.1
            });
            
            // Banc avant
            const frontBenchGeometry = new THREE.BoxGeometry(1.4, 0.1, 0.25);
            const frontBench = new THREE.Mesh(frontBenchGeometry, benchMaterial);
            frontBench.position.set(0, 0.3, 0.9);
            boat.add(frontBench);
            
            // Banc arri√®re
            const backBenchGeometry = new THREE.BoxGeometry(1.4, 0.1, 0.25);
            const backBench = new THREE.Mesh(backBenchGeometry, benchMaterial);
            backBench.position.set(0, 0.3, -0.9);
            boat.add(backBench);
            
            // Banc milieu
            const middleBenchGeometry = new THREE.BoxGeometry(1.4, 0.1, 0.25);
            const middleBench = new THREE.Mesh(middleBenchGeometry, benchMaterial);
            middleBench.position.set(0, 0.3, 0);
            boat.add(middleBench);
            
            // Ajouter une lanterne pour l'ambiance
            const lanternBase = new THREE.CylinderGeometry(0.05, 0.05, 0.2, 8);
            const lanternGlobe = new THREE.SphereGeometry(0.1, 8, 8);
            const lanternMaterial = new THREE.MeshStandardMaterial({
                color: 0x553311,
                roughness: 0.5
            });
            const lanternGlassMaterial = new THREE.MeshStandardMaterial({
                color: 0xffaa55,
                emissive: 0xff6622,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.7
            });
            
            const lanternBaseObj = new THREE.Mesh(lanternBase, lanternMaterial);
            const lanternGlobeObj = new THREE.Mesh(lanternGlobe, lanternGlassMaterial);
            lanternGlobeObj.position.y = 0.15;
            
            const lantern = new THREE.Group();
            lantern.add(lanternBaseObj);
            lantern.add(lanternGlobeObj);
            lantern.position.set(0, 0.4, 0.9);
            boat.add(lantern);
            
            // Ajouter une lumi√®re dans la lanterne
            const lanternLight = new THREE.PointLight(0xff6622, 1, 3);
            lanternLight.position.set(0, 0.15, 0);
            lantern.add(lanternLight);
            
            // Position et √©chelle finale de la barque
            boat.scale.set(0.7, 0.7, 0.7);
            boat.position.y = WATER_LEVEL + 0.4;
            window.scene.add(boat);
            
            // Variables pour l'animation narrative de la barque
            boat.userData = {
                lanternLight: lanternLight,
                lanternOriginalIntensity: 1,
                narrativeState: "normal"
            };
            
            return boat;
        }
        
        // Fonction pour cr√©er une texture de bois
        function createWoodTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            
            // Fond
            context.fillStyle = "#8B4513";
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Veines de bois
            for (let i = 0; i < 30; i++) {
                // Position et √©paisseur variables
                const y = Math.random() * canvas.height;
                const width = 1 + Math.random() * 3;
                
                // Couleur de veine l√©g√®rement variable
                const brightness = 100 + Math.floor(Math.random() * 50);
                const color = `rgb(${brightness}, ${brightness * 0.6}, ${brightness * 0.4})`;
                
                context.beginPath();
                context.moveTo(0, y);
                
                // Cr√©er une ligne ondul√©e
                for (let x = 0; x < canvas.width; x += canvas.width/20) {
                    const newY = y + (Math.random() - 0.5) * 15;
                    context.lineTo(x, newY);
                }
                
                context.strokeStyle = color;
                context.lineWidth = width;
                context.stroke();
            }
            
            // Noeuds du bois
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 3 + Math.random() * 8;
                
                const gradient = context.createRadialGradient(x, y, 1, x, y, radius);
                gradient.addColorStop(0, "#4B2809");
                gradient.addColorStop(1, "#8B4513");
                
                context.beginPath();
                context.arc(x, y, radius, 0, Math.PI * 2);
                context.fillStyle = gradient;
                context.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }
        
        // Cr√©er un segment de tunnel avec rebords et portes
        function createSegment(zPosition) {
            const segment = new THREE.Group();
            segment.position.z = zPosition;
            
            // Tunnel principal
            const tunnelGeometry = new THREE.CylinderGeometry(
                TUNNEL_RADIUS, TUNNEL_RADIUS, TUNNEL_LENGTH, 16, 1, true
            );
            const tunnelMaterial = new THREE.MeshPhongMaterial({
                color: 0x333333, 
                side: THREE.BackSide
            });
            const tunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
            tunnel.rotation.x = Math.PI / 2;
            segment.add(tunnel);
            
            // Sol/eau au centre
            const waterWidth = TUNNEL_RADIUS * 1.2; // R√©duire pour laisser de la place aux rebords
            const floorGeometry = new THREE.PlaneGeometry(
                waterWidth, TUNNEL_LENGTH
            );
            const waterMaterial = new THREE.MeshPhongMaterial({
                color: 0x006666,
                transparent: true,
                opacity: 0.7
            });
            const floor = new THREE.Mesh(floorGeometry, waterMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = WATER_LEVEL;
            segment.add(floor);
            
            // Ajouter un effet de miroitement √† l'eau
            segment.userData.water = floor;
            segment.userData.waterBaseColor = new THREE.Color(0x006666);
            
            // Ajouter des rebords et des portes r√©guli√®rement
            for (let z = 0; z < TUNNEL_LENGTH; z += 5) {
                // Position en z
                const doorZ = z - TUNNEL_LENGTH / 2;
                
                // D√©terminer si cette porte est sp√©ciale (narrative)
                const isSpecialDoor = Math.random() < 0.05 + (window.storyProgress * 0.02);
                
                // Porte gauche
                const leftDoor = createDoor(isSpecialDoor);
                leftDoor.position.set(-TUNNEL_RADIUS + 0.2, WATER_LEVEL + 1.5, doorZ);
                leftDoor.rotation.y = Math.PI/2; // Rotation pour que la porte soit perpendiculaire √† la paroi du tunnel
                leftDoor.rotation.z = 0; // Assurer que la porte est verticale
                segment.add(leftDoor);
                
                if (isSpecialDoor) {
                    registerSpecialDoor(leftDoor);
                }
                
                window.doors.push(leftDoor);
                
                // Porte droite - perpendiculaire √† la paroi et verticale
                const rightDoor = createDoor(isSpecialDoor);
                rightDoor.position.set(TUNNEL_RADIUS - 0.2, WATER_LEVEL + 1.5, doorZ);
                rightDoor.rotation.y = -Math.PI/2; // Rotation pour que la porte soit perpendiculaire √† la paroi du tunnel
                rightDoor.rotation.z = 0; // Assurer que la porte est verticale
                segment.add(rightDoor);
                
                if (isSpecialDoor) {
                    registerSpecialDoor(rightDoor);
                }
                
                window.doors.push(rightDoor);
                
                // Rebords pour marcher (gauche et droite)
                createWalkway(segment, -TUNNEL_RADIUS + 0.6, WATER_LEVEL + 0.1, doorZ - 2.5, 5);
                createWalkway(segment, TUNNEL_RADIUS - 0.6, WATER_LEVEL + 0.1, doorZ - 2.5, 5);
                
                // Lumi√®res murales
                createWallLight(segment, -TUNNEL_RADIUS + 0.1, WATER_LEVEL + 2, doorZ - 1.5);
                createWallLight(segment, TUNNEL_RADIUS - 0.1, WATER_LEVEL + 2, doorZ - 1.5);
            }
            
            // Lumi√®re g√©n√©rale du tunnel (faible)
            const ambientLight = new THREE.PointLight(0x333333, 0.3, TUNNEL_RADIUS * 2);
            ambientLight.position.set(0, 0, 0);
            segment.add(ambientLight);
            
            // Stocker la position et les donn√©es suppl√©mentaires
            segment.userData = { 
                ...segment.userData,
                zPosition: zPosition,
                narrativeZone: determineNarrativeZone(zPosition),
                ambientLight: ambientLight
            };
            
            window.scene.add(segment);
            window.segments.push(segment);
            return segment;
        }
        
        // Cr√©er un rebord pour marcher
        function createWalkway(parent, x, y, z, length) {
            // Plateforme pour marcher
            const walkwayGeometry = new THREE.BoxGeometry(1, 0.2, length);
            const walkwayMaterial = new THREE.MeshPhongMaterial({color: 0x555555});
            const walkway = new THREE.Mesh(walkwayGeometry, walkwayMaterial);
            walkway.position.set(x, y, z + length/2);
            parent.add(walkway);
            
            // Support m√©tallique
            for (let i = 0; i < length; i += 1.5) {
                const supportGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 6);
                const supportMaterial = new THREE.MeshPhongMaterial({color: 0x777777});
                const support = new THREE.Mesh(supportGeometry, supportMaterial);
                support.position.set(x, y - 0.35, z + i);
                parent.add(support);
            }
            
            return walkway;
        }
        
        // Cr√©er une lumi√®re murale
        function createWallLight(parent, x, y, z) {
            // Groupe pour la lumi√®re
            const lightGroup = new THREE.Group();
            lightGroup.position.set(x, y, z);
            
            // Support mural
            const baseGeometry = new THREE.BoxGeometry(0.1, 0.3, 0.3);
            const baseMaterial = new THREE.MeshPhongMaterial({color: 0x333333});
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            
            // Orientation selon le c√¥t√©
            if (x < 0) { // C√¥t√© gauche
                base.rotation.y = 0;
                lightGroup.rotation.y = 0;
            } else { // C√¥t√© droit
                base.rotation.y = Math.PI;
                lightGroup.rotation.y = Math.PI;
            }
            
            lightGroup.add(base);
            
            // Ampoule/Globe
            const bulbGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            
            // La couleur varie en fonction de la progression de l'histoire
            const colorProgress = Math.min(window.storyProgress, 1);
            const bulbColor = new THREE.Color().setHSL(
                0.1 - (colorProgress * 0.1), // De jaune vers rouge
                0.7,
                0.5 + (colorProgress * 0.2) // Devient plus brillant
            );
            
            const bulbMaterial = new THREE.MeshBasicMaterial({
                color: bulbColor
                // emissive et emissiveIntensity sont retir√©s car non support√©s par MeshBasicMaterial
            });
            
            const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
            bulb.position.x = (x < 0) ? 0.1 : -0.1; // Position selon le c√¥t√©
            lightGroup.add(bulb);
            
            // Lumi√®re
            const intensity = 0.5 + Math.random() * 0.5;
            const light = new THREE.PointLight(bulbColor, intensity, 3);
            light.position.copy(bulb.position);
            lightGroup.add(light);
            
            // Ajouter des donn√©es pour les animations
            lightGroup.userData = {
                bulb: bulb,
                light: light,
                originalIntensity: intensity,
                flicker: Math.random() < 0.3, // 30% de chance de scintillement
                flickerSpeed: 0.5 + Math.random() * 2,
                originalColor: bulbColor.clone()
            };
            
            parent.add(lightGroup);
            return lightGroup;
        }
        
        // Cr√©er une porte avec une orientation correcte et th√©matique
        function createDoor(isSpecial = false) {
            const door = new THREE.Group();
            
            // Couleurs diff√©rentes selon le type de porte
            let doorColor, frameColor, detailsColor;
            let doorSymbol = null;
            
            if (isSpecial) {
                // Porte sp√©ciale avec couleur et caract√©ristiques uniques
                const specialType = Math.floor(Math.random() * 5);
                
                switch(specialType) {
                    case 0: // Porte myst√©rieuse avec symboles
                        frameColor = 0x443322;
                        doorColor = 0x221100;
                        detailsColor = 0xaa8866;
                        doorSymbol = "symbol";
                        break;
                    case 1: // Porte rouge sang
                        frameColor = 0x662222;
                        doorColor = 0x990000;
                        detailsColor = 0xaa3333;
                        doorSymbol = "blood";
                        break;
                    case 2: // Porte luminescente
                        frameColor = 0x443355;
                        doorColor = 0x334466;
                        detailsColor = 0x88aaff;
                        doorSymbol = "glow";
                        break;
                    case 3: // Porte m√©tallique rouill√©e
                        frameColor = 0x775533;
                        doorColor = 0x996633;
                        detailsColor = 0xcc8844;
                        doorSymbol = "rust";
                        break;
                    case 4: // Porte avec marques de griffes
                        frameColor = 0x554433;
                        doorColor = 0x443322;
                        detailsColor = 0x333333;
                        doorSymbol = "claw";
                        break;
                }
            } else {
                // Porte standard
                frameColor = 0x553322;
                doorColor = 0x332211;
                detailsColor = 0x888888;
            }
            
            // Cadre de porte
            const frameGeometry = new THREE.BoxGeometry(2, 3, 0.2);
            const frameMaterial = new THREE.MeshPhongMaterial({color: frameColor});
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            door.add(frame);
            
            // La porte elle-m√™me (panneau)
            const doorGeometry = new THREE.BoxGeometry(1.8, 2.8, 0.1);
            const doorMaterial = new THREE.MeshPhongMaterial({color: doorColor});
            const doorMesh = new THREE.Mesh(doorGeometry, doorMaterial);
            // Positionner la porte correctement pour l'animation
            doorMesh.position.z = -0.15; 
            door.add(doorMesh);
            
            // Poign√©e de porte
            const handleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const handleMaterial = new THREE.MeshPhongMaterial({color: detailsColor});
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.set(0.5, 0, -0.15); // √Ä droite de la porte vue de face
            door.add(handle);
            
            // Ajout de num√©ro ou symbole de porte
            const doorNumber = Math.floor(Math.random() * 900) + 100;
            
            // Plaque de num√©ro/symbole
            const plateGeometry = new THREE.PlaneGeometry(0.4, 0.2);
            const plateMaterial = new THREE.MeshPhongMaterial({
                color: detailsColor,
                side: THREE.DoubleSide
            });
            const plate = new THREE.Mesh(plateGeometry, plateMaterial);
            plate.position.set(0, 1, -0.11);
            door.add(plate);
            
            // Ajouter un symbole sp√©cial si c'est une porte sp√©ciale
            if (isSpecial && doorSymbol) {
                // Cr√©er le symbole selon le type
                switch(doorSymbol) {
                    case "symbol":
                        // Ajouter un symbole √©sot√©rique
                        addSymbolToDoor(door, plate);
                        break;
                    case "blood":
                        // Ajouter des taches de sang
                        addBloodToDoor(door, doorMesh);
                        break;
                    case "glow":
                        // Ajouter un effet lumineux
                        addGlowToDoor(door, doorMesh);
                        break;
                    case "rust":
                        // Ajouter des taches de rouille
                        addRustToDoor(door, doorMesh);
                        break;
                    case "claw":
                        // Ajouter des marques de griffes
                        addClawMarksToDoor(door, doorMesh);
                        break;
                }
            }
            
            // Donn√©es pour l'animation et statut narratif
            door.userData = {
                doorMesh: doorMesh,
                animating: false,
                doorNumber: doorNumber,
                isSpecial: isSpecial,
                doorSymbol: doorSymbol,
                activated: false,
                containsClue: isSpecial && (Math.random() < 0.6), // 60% des portes sp√©ciales contiennent un indice
                containsEntity: isSpecial && (Math.random() < 0.3), // 30% des portes sp√©ciales contiennent une entit√©
                entityType: isSpecial ? Math.floor(Math.random() * 7) : null,
                narrativeElement: null
            };
            
            return door;
        }
        
        // Ajouter un symbole √©sot√©rique √† une porte
        function addSymbolToDoor(door, plate) {
            // Cr√©er un canvas pour dessiner le symbole
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Fond transparent
            ctx.fillStyle = 'rgba(0, 0, 0, 0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Choisir un symbole al√©atoire
            const symbolType = Math.floor(Math.random() * 5);
            
            // Dessiner le symbole en blanc
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.fillStyle = 'white';
            
            switch(symbolType) {
                case 0: // Cercle avec triangle
                    ctx.beginPath();
                    ctx.arc(64, 64, 40, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(64, 34);
                    ctx.lineTo(94, 94);
                    ctx.lineTo(34, 94);
                    ctx.closePath();
                    ctx.stroke();
                    break;
                    
                case 1: // Spirale
                    ctx.beginPath();
                    let radius = 5;
                    let angle = 0;
                    let x = 64;
                    let y = 64;
                    
                    for (let i = 0; i < 200; i++) {
                        angle += 0.1;
                        radius += 0.2;
                        const newX = 64 + Math.cos(angle) * radius;
                        const newY = 64 + Math.sin(angle) * radius;
                        ctx.lineTo(newX, newY);
                        x = newX;
                        y = newY;
                        
                        if (radius > 40) break;
                    }
                    ctx.stroke();
                    break;
                    
                case 2: // ≈íil
                    ctx.beginPath();
                    ctx.ellipse(64, 64, 45, 25, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(64, 64, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(64, 39);
                    ctx.lineTo(64, 89);
                    ctx.stroke();
                    break;
                    
                case 3: // Runes
                    for (let i = 0; i < 3; i++) {
                        const startX = 34 + i * 30;
                        ctx.beginPath();
                        
                        // Runes al√©atoires
                        switch(Math.floor(Math.random() * 5)) {
                            case 0: // F-like
                                ctx.moveTo(startX, 44);
                                ctx.lineTo(startX, 94);
                                ctx.moveTo(startX, 44);
                                ctx.lineTo(startX + 20, 44);
                                ctx.moveTo(startX, 69);
                                ctx.lineTo(startX + 15, 69);
                                break;
                            case 1: // X-like
                                ctx.moveTo(startX - 10, 44);
                                ctx.lineTo(startX + 10, 94);
                                ctx.moveTo(startX + 10, 44);
                                ctx.lineTo(startX - 10, 94);
                                break;
                            case 2: // O with line
                                ctx.arc(startX, 69, 25, 0, Math.PI * 2);
                                ctx.moveTo(startX - 25, 69);
                                ctx.lineTo(startX + 25, 69);
                                break;
                            case 3: // Arrow
                                ctx.moveTo(startX, 44);
                                ctx.lineTo(startX, 94);
                                ctx.moveTo(startX - 10, 54);
                                ctx.lineTo(startX, 44);
                                ctx.lineTo(startX + 10, 54);
                                break;
                            case 4: // Wave
                                ctx.moveTo(startX - 15, 69);
                                for (let j = 0; j < 30; j++) {
                                    ctx.lineTo(startX - 15 + j, 69 + Math.sin(j * 0.3) * 15);
                                }
                                break;
                        }
                        
                        ctx.stroke();
                    }
                    break;
                    
                case 4: // Constellation
                    // Points
                    const points = [];
                    for (let i = 0; i < 7; i++) {
                        points.push({
                            x: 30 + Math.random() * 68,
                            y: 30 + Math.random() * 68,
                            r: 2 + Math.random() * 3
                        });
                    }
                    
                    // Dessiner les points
                    points.forEach(point => {
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, point.r, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Relier certains points
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) {
                        if (Math.random() < 0.7) { // 70% de chance de relier deux points
                            ctx.lineTo(points[i].x, points[i].y);
                        } else {
                            ctx.moveTo(points[i].x, points[i].y);
                        }
                    }
                    ctx.stroke();
                    break;
            }
            
            // Cr√©er une texture √† partir du canvas
            const symbolTexture = new THREE.CanvasTexture(canvas);
            
            // Cr√©er un mat√©riau avec cette texture
            const symbolMaterial = new THREE.MeshBasicMaterial({
                map: symbolTexture,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            
            // Remplacer le mat√©riau de la plaque
            plate.material = symbolMaterial;
            
            // Agrandir la plaque pour le symbole
            plate.scale.set(2, 2, 1);
            
            // Stocker les donn√©es pour animation
            door.userData.symbolType = symbolType;
            door.userData.symbolTexture = symbolTexture;
        }
        
        // Ajouter des taches de sang √† une porte
        function addBloodToDoor(door, doorMesh) {
            // Cr√©er un canvas pour dessiner les taches
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Copier la couleur de base de la porte
            ctx.fillStyle = '#990000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner des taches de sang al√©atoires
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 10 + Math.random() * 50;
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, 'rgba(120, 0, 0, 0.9)');
                gradient.addColorStop(0.7, 'rgba(80, 0, 0, 0.6)');
                gradient.addColorStop(1, 'rgba(80, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Dessiner des tra√Æn√©es de sang coulant
            for (let i = 0; i < 5; i++) {
                const startX = Math.random() * canvas.width;
                const startY = Math.random() * (canvas.height / 2); // Commencer dans la moiti√© sup√©rieure
                
                ctx.strokeStyle = 'rgba(100, 0, 0, 0.8)';
                ctx.lineWidth = 3 + Math.random() * 8;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                
                let currentX = startX;
                let currentY = startY;
                
                // Cr√©er une ligne descendante avec zigzags al√©atoires
                const length = 50 + Math.random() * 200;
                for (let j = 0; j < length; j += 10) {
                    currentY += 10;
                    currentX += (Math.random() - 0.5) * 15;
                    
                    // R√©duire progressivement l'√©paisseur de la ligne
                    ctx.lineWidth = Math.max(1, ctx.lineWidth - 0.2);
                    
                    ctx.lineTo(currentX, currentY);
                    
                    if (currentY > canvas.height) break;
                }
                
                ctx.stroke();
            }
            
            // Cr√©er une texture √† partir du canvas
            const bloodTexture = new THREE.CanvasTexture(canvas);
            
            // Appliquer la texture √† la porte
            const bloodMaterial = new THREE.MeshStandardMaterial({
                map: bloodTexture,
                color: 0x990000,
                roughness: 0.7,
                metalness: 0.2
            });
            
            doorMesh.material = bloodMaterial;
        }
        
        // Ajouter un effet lumineux √† une porte
        function addGlowToDoor(door, doorMesh) {
            // Cr√©er un mat√©riau avec √©mission pour l'effet lumineux
            const glowMaterial = new THREE.MeshStandardMaterial({
                color: 0x334466,
                emissive: 0x88aaff,
                emissiveIntensity: 0.5,
                roughness: 0.4,
                metalness: 0.6
            });
            
            doorMesh.material = glowMaterial;
            
            // Ajouter une lumi√®re pour renforcer l'effet
            const glowLight = new THREE.PointLight(0x88aaff, 0.8, 1);
            glowLight.position.set(0, 0, -0.1);
            doorMesh.add(glowLight);
            
            // Stocker la lumi√®re pour l'animation
            door.userData.glowLight = glowLight;
            door.userData.originalIntensity = 0.8;
        }
        
        // Ajouter des taches de rouille √† une porte
        function addRustToDoor(door, doorMesh) {
            // Cr√©er un canvas pour dessiner la rouille
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Couleur de base m√©tallique
            ctx.fillStyle = '#996633';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Ajouter une texture m√©tallique de base
            for (let i = 0; i < 20; i++) {
                ctx.strokeStyle = `rgba(153, 122, 102, ${Math.random() * 0.3})`;
                ctx.lineWidth = 1 + Math.random() * 2;
                
                ctx.beginPath();
                ctx.moveTo(0, Math.random() * canvas.height);
                ctx.lineTo(canvas.width, Math.random() * canvas.height);
                ctx.stroke();
            }
            
            // Ajouter des taches de rouille
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 5 + Math.random() * 40;
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, 'rgba(180, 60, 20, 0.9)');
                gradient.addColorStop(0.6, 'rgba(160, 80, 30, 0.6)');
                gradient.addColorStop(1, 'rgba(153, 102, 51, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Ajouter quelques trous de rouille
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 2 + Math.random() * 6;
                
                ctx.fillStyle = 'rgba(30, 20, 10, 0.8)';
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Ajouter un halo de rouille intense autour du trou
                const holeGradient = ctx.createRadialGradient(x, y, radius, x, y, radius * 3);
                holeGradient.addColorStop(0, 'rgba(180, 60, 20, 0.9)');
                holeGradient.addColorStop(1, 'rgba(180, 60, 20, 0)');
                
                ctx.fillStyle = holeGradient;
                ctx.beginPath();
                ctx.arc(x, y, radius * 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Cr√©er une texture √† partir du canvas
            const rustTexture = new THREE.CanvasTexture(canvas);
            
            // Appliquer la texture √† la porte
            const rustMaterial = new THREE.MeshStandardMaterial({
                map: rustTexture,
                roughness: 0.9,
                metalness: 0.4
            });
            
            doorMesh.material = rustMaterial;
        }
        
        // Ajouter des marques de griffes √† une porte
        function addClawMarksToDoor(door, doorMesh) {
            // Cr√©er un canvas pour dessiner les marques
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Couleur de base de la porte
            ctx.fillStyle = '#443322';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner des marques de griffes
            const clawSets = Math.floor(Math.random() * 3) + 2; // 2-4 sets de griffes
            
            for (let set = 0; set < clawSets; set++) {
                const startX = 50 + Math.random() * (canvas.width - 100);
                const startY = 50 + Math.random() * (canvas.height - 100);
                const angle = Math.random() * Math.PI / 4 - Math.PI / 8; // Angle al√©atoire l√©ger
                const length = 100 + Math.random() * 200;
                
                // 3-5 griffes par set
                const claws = Math.floor(Math.random() * 3) + 3;
                const spacing = 10 + Math.random() * 15;
                
                for (let claw = 0; claw < claws; claw++) {
                    // Calculer le d√©calage perpendiculaire √† l'angle
                    const offsetX = Math.sin(angle) * spacing * (claw - (claws - 1) / 2);
                    const offsetY = -Math.cos(angle) * spacing * (claw - (claws - 1) / 2);
                    
                    ctx.strokeStyle = '#221100';
                    ctx.lineWidth = 3 + Math.random() * 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(startX + offsetX, startY + offsetY);
                    
                    // Ligne principale
                    const endX = startX + Math.cos(angle) * length + offsetX;
                    const endY = startY + Math.sin(angle) * length + offsetY;
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    // Ajouter une ligne plus claire pour montrer le bois expos√©
                    ctx.strokeStyle = 'rgba(200, 150, 100, 0.7)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(startX + offsetX + 1, startY + offsetY + 1);
                    ctx.lineTo(endX + 1, endY + 1);
                    ctx.stroke();
                }
            }
            
            // Cr√©er une texture √† partir du canvas
            const clawTexture = new THREE.CanvasTexture(canvas);
            
            // Appliquer la texture √† la porte
            const clawMaterial = new THREE.MeshStandardMaterial({
                map: clawTexture,
                roughness: 0.8,
                metalness: 0.1
            });
            
            doorMesh.material = clawMaterial;
        }
        
        // D√©terminer la zone narrative en fonction de la position
        function determineNarrativeZone(zPosition) {
            // La progression narrative est d√©termin√©e par la distance parcourue
            // Plus on s'enfonce dans le tunnel, plus l'histoire avance
            const absolutePosition = Math.abs(zPosition);
            
            // Secteurs d√©termin√©s par les paliers de milestone
            if (absolutePosition < 50) return "prologue";
            if (absolutePosition < 150) return "secteur2";
            if (absolutePosition < 300) return "secteur3";
            if (absolutePosition < 500) return "secteur4";
            if (absolutePosition < 800) return "secteur5";
            if (absolutePosition < 1200) return "secteur6";
            if (absolutePosition < 1800) return "secteur7";
            return "finale";
        }
        
        // Enregistrer une porte sp√©ciale
        function registerSpecialDoor(door) {
            const doorId = "door_" + Math.floor(Math.random() * 10000);
            window.specialDoors[doorId] = door;
            door.userData.doorId = doorId;
            
            // Si nous avons des indices non d√©couverts, attribuer l'un d'eux √† cette porte
            const availableClues = STORY_ELEMENTS.clues.filter(
                clue => !window.discoveredClues.includes(clue.id)
            );
            
            if (availableClues.length > 0 && door.userData.containsClue) {
                const randomClue = availableClues[Math.floor(Math.random() * availableClues.length)];
                door.userData.narrativeElement = {
                    type: "clue",
                    data: randomClue
                };
            }
        }
        
        // ==========================================
        // FONCTIONS D'ANIMATION ET INTERACTION
        // ==========================================
        
        // Animer une porte et r√©v√©ler son contenu
        function animateDoor(door) {
            if (!door || door.userData.animating) return;
            
            door.userData.animating = true;
            const doorMesh = door.userData.doorMesh;
            const originalPosition = -0.15; // Position initiale
            
            // Incr√©menter le compteur de portes activ√©es
            window.activatedDoors++;
            
            // Si c'est une porte sp√©ciale, la marquer comme activ√©e
            if (door.userData.isSpecial && !door.userData.activated) {
                door.userData.activated = true;
                
                // R√©v√©ler un indice ou d√©clencher un √©v√©nement narratif si applicable
                if (door.userData.narrativeElement) {
                    handleNarrativeElement(door.userData.narrativeElement);
                }
            }
            
            // Cr√©er ou r√©cup√©rer l'√©l√©ment myst√©rieux derri√®re la porte
            let mysteryElement = null;
            
            if (!door.userData.mysteryElement) {
                // D√©terminer le type d'√©l√©ment myst√©rieux
                const entityType = door.userData.entityType || Math.floor(Math.random() * 7);
                
                // Si la porte est sp√©ciale, plus de chance d'avoir une entit√© complexe
                const mysteryType = door.userData.isSpecial ? 
                    Math.min(6, Math.floor(Math.random() * 8)) : // Favorise les entit√©s 0-6
                    Math.floor(Math.random() * 7); // Distribution uniforme
                
                mysteryElement = createMysteryElement(mysteryType, entityType);
                
                // Positionner l'√©l√©ment derri√®re la porte
                const doorPosition = new THREE.Vector3();
                door.getWorldPosition(doorPosition);
                
                // Ajuster la position en fonction de l'orientation de la porte
                const doorDirection = new THREE.Vector3(0, 0, -1);
                doorDirection.applyQuaternion(door.quaternion);
                
                // Placer l'√©l√©ment derri√®re la porte √† une distance appropri√©e
                mysteryElement.position.copy(doorPosition);
                mysteryElement.position.add(doorDirection.multiplyScalar(1.5));
                
                // Attacher l'√©l√©ment √† la porte
                door.userData.mysteryElement = mysteryElement;
                door.userData.mysteryType = mysteryType;
                
                // Ajouter l'√©l√©ment √† la sc√®ne
                window.scene.add(mysteryElement);
                
                // Stocker dans la liste globale pour les mises √† jour
                window.mysteryElements[mysteryElement.uuid] = mysteryElement;
            } else {
                mysteryElement = door.userData.mysteryElement;
            }
            
            // Animation d'ouverture puis de fermeture
            let openAmount = 0;
            let opening = true;
            let revealSound = false;
            let effectTriggered = false;
            
            const interval = setInterval(() => {
                if (opening) {
                    // Phase d'ouverture
                    openAmount += 0.02;
                    
                    // Jouer un son/effet √† mi-ouverture
                    if (openAmount >= 0.15 && !revealSound) {
                        playMysterySound(door.userData.mysteryType || 0);
                        revealSound = true;
                    }
                    
                    // Limitation de l'ouverture maximale
                    if (openAmount >= 0.3) {
                        opening = false;
                        
                        // D√©clencher un effet sp√©cial une seule fois
                        if (!effectTriggered) {
                            triggerMysteryEffect(door.userData.mysteryType || 0, mysteryElement);
                            effectTriggered = true;
                        }
                    }
                } else {
                    // Phase de fermeture
                    openAmount -= 0.02;
                    
                    // V√©rification fin de fermeture
                    if (openAmount <= 0) {
                        openAmount = 0;
                        clearInterval(interval);
                        door.userData.animating = false;
                        
                        // Ne pas supprimer l'√©l√©ment myst√©rieux pour permettre des interactions continues
                        // avec le m√™me √©l√©ment si la porte est rouverte
                    }
                }
                
                // Appliquer le mouvement de la porte correctement
                doorMesh.position.z = originalPosition - openAmount;
            }, 50);
        }
        
        // Cr√©er un √©l√©ment myst√©rieux
        function createMysteryElement(type, entityVariant = 0) {
            const group = new THREE.Group();
            
            switch (type) {
                case 0: // Yeux brillants
                    const glowingEyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const glowingEyeMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
                    
                    const glowingLeftEye = new THREE.Mesh(glowingEyeGeometry, glowingEyeMaterial);
                    glowingLeftEye.position.x = 0.2;
                    group.add(glowingLeftEye);
                    
                    const glowingRightEye = new THREE.Mesh(glowingEyeGeometry, glowingEyeMaterial);
                    glowingRightEye.position.x = -0.2;
                    group.add(glowingRightEye);
                    
                    // Animation de clignotement
                    group.userData.update = (time) => {
                        const blink = Math.sin(time * 10) > 0.7;
                        glowingLeftEye.visible = glowingRightEye.visible = blink;
                    };
                    break;
                    
                case 1: // Tentacule ondulante
                    const tentacleGeometry = new THREE.CylinderGeometry(0.1, 0.02, 1.5, 8);
                    const tentacleMaterial = new THREE.MeshPhongMaterial({
                        color: 0x660066,
                        specular: 0x555555,
                        shininess: 30
                    });
                    
                    // Cr√©er plusieurs segments pour la tentacule
                    const segments = 5;
                    const tentacleSegments = [];
                    
                    for (let i = 0; i < segments; i++) {
                        const segment = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.1 - (i * 0.02), 0.08 - (i * 0.02), 0.4, 8),
                            tentacleMaterial
                        );
                        segment.position.y = -i * 0.3;
                        if (i > 0) {
                            segment.position.z = 0.1;
                        }
                        
                        if (i > 0) {
                            tentacleSegments[i-1].add(segment);
                        } else {
                            group.add(segment);
                        }
                        
                        tentacleSegments.push(segment);
                    }
                    
                    // Animation d'ondulation
                    group.userData.update = (time) => {
                        tentacleSegments.forEach((segment, index) => {
                            segment.rotation.x = Math.sin(time * 3 + index * 0.5) * 0.3;
                            segment.rotation.z = Math.cos(time * 2 + index * 0.5) * 0.3;
                        });
                    };
                    break;
                    
                case 2: // Silhouette sombre
                    const torsoGeometry = new THREE.BoxGeometry(0.5, 0.8, 0.3);
                    const headGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                    const limbGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
                    
                    const shadowMaterial = new THREE.MeshBasicMaterial({
                        color: 0x000000,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const torso = new THREE.Mesh(torsoGeometry, shadowMaterial);
                    group.add(torso);
                    
                    const head = new THREE.Mesh(headGeometry, shadowMaterial);
                    head.position.y = 0.5;
                    group.add(head);
                    
                    // Membres
                    const arms = [];
                    for (let i = 0; i < 2; i++) {
                        const arm = new THREE.Mesh(limbGeometry, shadowMaterial);
                        arm.position.set(i === 0 ? -0.3 : 0.3, 0.1, 0);
                        arm.rotation.z = i === 0 ? Math.PI/4 : -Math.PI/4;
                        group.add(arm);
                        arms.push(arm);
                    }
                    
                    const legs = [];
                    for (let i = 0; i < 2; i++) {
                        const leg = new THREE.Mesh(limbGeometry, shadowMaterial);
                        leg.position.set(i === 0 ? -0.15 : 0.15, -0.6, 0);
                        group.add(leg);
                        legs.push(leg);
                    }
                    
                    // Animation d'agitation
                    group.userData.update = (time) => {
                        head.rotation.y = Math.sin(time * 2) * 0.5;
                        arms.forEach((arm, index) => {
                            arm.rotation.x = Math.sin(time * 3 + index) * 0.2;
                        });
                        legs.forEach((leg, index) => {
                            leg.rotation.x = Math.sin(time * 2 + index * Math.PI) * 0.1;
                        });
                        
                        group.position.y = Math.sin(time * 2) * 0.05;
                    };
                    break;
                    
                case 3: // Objet flottant lumineux
                    const coreGeometry = new THREE.OctahedronGeometry(0.2, 1);
                    const coreMaterial = new THREE.MeshBasicMaterial({
                        color: 0x88ffff,
                        wireframe: true
                    });
                    
                    const core = new THREE.Mesh(coreGeometry, coreMaterial);
                    group.add(core);
                    
                    // Lumi√®re interne
                    const coreLight = new THREE.PointLight(0x88ffff, 1, 3);
                    core.add(coreLight);
                    
                    // Particules orbitales
                    const particles = [];
                    const particleGeometry = new THREE.SphereGeometry(0.03, 4, 4);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff
                    });
                    
                    for (let i = 0; i < 8; i++) {
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        particle.userData = {
                            orbitRadius: 0.3 + Math.random() * 0.2,
                            orbitSpeed: 0.5 + Math.random() * 2,
                            orbitOffset: Math.random() * Math.PI * 2,
                            elevation: (Math.random() - 0.5) * 0.3
                        };
                        group.add(particle);
                        particles.push(particle);
                    }
                    
                    // Animation d'orbite
                    group.userData.update = (time) => {
                        core.rotation.x = time * 0.5;
                        core.rotation.y = time * 0.8;
                        
                        particles.forEach(particle => {
                            const orbit = particle.userData;
                            particle.position.x = Math.cos(time * orbit.orbitSpeed + orbit.orbitOffset) * orbit.orbitRadius;
                            particle.position.z = Math.sin(time * orbit.orbitSpeed + orbit.orbitOffset) * orbit.orbitRadius;
                            particle.position.y = orbit.elevation + Math.sin(time * 2) * 0.1;
                        });
                        
                        coreLight.intensity = 0.7 + Math.sin(time * 5) * 0.3;
                    };
                    break;
                    
                case 4: // Visage fantomatique
                    const faceGeometry = new THREE.PlaneGeometry(0.6, 0.8);
                    
                    // Cr√©er une texture dynamique pour le visage
                    const canvas = document.createElement('canvas');
                    canvas.width = 256;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    
                    // Fond transparent
                    ctx.fillStyle = 'rgba(0, 0, 0, 0)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Dessiner un visage de base
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(128, 120, 90, 120, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Yeux
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.ellipse(90, 100, 20, 25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.ellipse(166, 100, 20, 25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bouche
                    ctx.beginPath();
                    ctx.ellipse(128, 160, 40, 20, 0, 0, Math.PI);
                    ctx.fill();
                    
                    const faceTexture = new THREE.CanvasTexture(canvas);
                    const faceMaterial = new THREE.MeshBasicMaterial({
                        map: faceTexture,
                        transparent: true,
                        opacity: 0.7,
                        side: THREE.DoubleSide
                    });
                    
                    const face = new THREE.Mesh(faceGeometry, faceMaterial);
                    group.add(face);
                    
                    // Animation du visage
                    group.userData.canvas = canvas;
                    group.userData.texture = faceTexture;
                    group.userData.context = ctx;
                    
                    group.userData.update = (time) => {
                        const ctx = group.userData.context;
                        const canvas = group.userData.canvas;
                        
                        // Effacer et redessiner
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Visage de base
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.beginPath();
                        ctx.ellipse(128, 120, 90, 120, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Yeux anim√©s
                        const eyeScaleY = Math.max(0.1, Math.sin(time * 4) * 0.5 + 0.5);
                        
                        ctx.fillStyle = '#000000';
                        ctx.beginPath();
                        ctx.ellipse(90, 100, 20, 25 * eyeScaleY, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.ellipse(166, 100, 20, 25 * eyeScaleY, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Bouche anim√©e
                        const mouthOpen = 0.3 + Math.sin(time * 2) * 0.2;
                        ctx.beginPath();
                        ctx.ellipse(128, 160, 40, 20 * mouthOpen, 0, 0, Math.PI);
                        ctx.fill();
                        
                        // Mettre √† jour la texture
                        group.userData.texture.needsUpdate = true;
                        
                        // Mouvement flottant
                        group.position.y = Math.sin(time * 1.5) * 0.1;
                        face.rotation.y = Math.sin(time) * 0.2;
                    };
                    break;
                    
                case 5: // Portail √©nerg√©tique
                    const ringGeometry = new THREE.TorusGeometry(0.3, 0.03, 16, 32);
                    const ringMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffaa00,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    group.add(ring);
                    
                    // Ajouter des anneaux suppl√©mentaires
                    const rings = [ring];
                    for (let i = 1; i < 3; i++) {
                        const newRing = new THREE.Mesh(
                            new THREE.TorusGeometry(0.3, 0.02, 16, 32),
                            new THREE.MeshBasicMaterial({
                                color: 0xffaa00,
                                transparent: true,
                                opacity: 0.5 - (i * 0.1)
                            })
                        );
                        rings.push(newRing);
                        group.add(newRing);
                    }
                    
                    // Centre du portail
                    const centerGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                    const centerMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.5
                    });
                    
                    const center = new THREE.Mesh(centerGeometry, centerMaterial);
                    group.add(center);
                    
                    // Lumi√®re du portail
                    const portalLight = new THREE.PointLight(0xffaa00, 1, 3);
                    group.add(portalLight);
                    
                    // Animation du portail
                    group.userData.update = (time) => {
                        rings.forEach((ring, i) => {
                            ring.rotation.x = time * (1 + i * 0.2);
                            ring.rotation.y = time * (0.5 + i * 0.1);
                            
                            const scalePulse = 1 + Math.sin(time * (3 + i)) * 0.1;
                            ring.scale.set(scalePulse, scalePulse, 1);
                        });
                        
                        center.scale.setScalar(0.8 + Math.sin(time * 4) * 0.2);
                        portalLight.intensity = 0.7 + Math.sin(time * 5) * 0.3;
                    };
                    break;
                    
                case 6: // Cr√©ature obscure
                    // Remplacer CapsuleGeometry (non disponible en r128) par une combinaison de cylindre et sph√®res
                    const body = new THREE.Group();
                    
                    // Cylindre pour le corps
                    const bodyMainGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 12);
                    const bodyMaterial = new THREE.MeshPhongMaterial({
                        color: 0x330000,
                        specular: 0x111111,
                        shininess: 50
                    });
                    const bodyMain = new THREE.Mesh(bodyMainGeometry, bodyMaterial);
                    body.add(bodyMain);
                    
                    // Sph√®res pour arrondir les extr√©mit√©s (effet capsule)
                    const topSphereGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                    const topSphere = new THREE.Mesh(topSphereGeometry, bodyMaterial);
                    topSphere.position.y = 0.2;
                    body.add(topSphere);
                    
                    const bottomSphereGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                    const bottomSphere = new THREE.Mesh(bottomSphereGeometry, bodyMaterial);
                    bottomSphere.position.y = -0.2;
                    body.add(bottomSphere);
                    
                    group.add(body);
                    
                    // Membres
                    const limbs = [];
                    const limbMaterial = new THREE.MeshPhongMaterial({
                        color: 0x220000,
                        specular: 0x111111,
                        shininess: 30
                    });
                    
                    for (let i = 0; i < 6; i++) {
                        const limbGeometry = new THREE.CylinderGeometry(0.03, 0.01, 0.5, 5);
                        const limb = new THREE.Mesh(limbGeometry, limbMaterial);
                        
                        const angle = (i / 6) * Math.PI * 2;
                        limb.position.set(
                            Math.cos(angle) * 0.2,
                            0,
                            Math.sin(angle) * 0.2
                        );
                        
                        limb.rotation.x = Math.PI / 2;
                        limb.rotation.z = angle;
                        
                        body.add(limb);
                        limbs.push(limb);
                    }
                    
                    // Yeux
                    const creatureEyeGeometry = new THREE.SphereGeometry(0.03, 8, 8);
                    const creatureEyeMaterial = new THREE.MeshBasicMaterial({
                        color: 0xff0000
                    });
                    
                    const creatureLeftEye = new THREE.Mesh(creatureEyeGeometry, creatureEyeMaterial);
                    creatureLeftEye.position.set(0.1, 0.2, 0.15);
                    body.add(creatureLeftEye);
                    
                    const creatureRightEye = new THREE.Mesh(creatureEyeGeometry, creatureEyeMaterial);
                    creatureRightEye.position.set(-0.1, 0.2, 0.15);
                    body.add(creatureRightEye);
                    
                    // Animation de la cr√©ature
                    group.userData.update = (time) => {
                        body.rotation.y = Math.sin(time) * 0.3;
                        
                        limbs.forEach((limb, i) => {
                            limb.rotation.x = Math.PI/2 + Math.sin(time * 3 + i) * 0.3;
                        });
                        
                        creatureLeftEye.scale.setScalar(0.8 + Math.sin(time * 5) * 0.2);
                        creatureRightEye.scale.setScalar(0.8 + Math.sin(time * 5 + 1) * 0.2);
                    };
                    break;
            }
            
            // Personnaliser l'entit√© selon sa variante
            customizeEntityByVariant(group, entityVariant);
            
            return group;
        }
        
        // Personnaliser l'entit√© en fonction de sa variante (pour la diversit√©)
        function customizeEntityByVariant(entity, variant) {
            // Appliquer des modifications selon le type de variante
            switch(variant) {
                case 1: // Variante plus grande
                    entity.scale.set(1.3, 1.3, 1.3);
                    break;
                case 2: // Variante color√©e diff√©remment
                    entity.traverse(child => {
                        if (child.isMesh && child.material) {
                            // Changer la teinte
                            if (child.material.color) {
                                const color = child.material.color;
                                color.setHSL((color.getHSL({}).h + 0.2) % 1, color.getHSL({}).s, color.getHSL({}).l);
                            }
                        }
                    });
                    break;
                case 3: // Variante d√©form√©e
                    entity.rotation.set(Math.PI/6, 0, Math.PI/8);
                    entity.scale.set(0.9, 1.2, 0.9);
                    break;
                case 4: // Variante avec lueur
                    const glow = new THREE.PointLight(0xaaccff, 0.5, 2);
                    entity.add(glow);
                    break;
                case 5: // Variante multiple (clones)
                    for (let i = 0; i < 2; i++) {
                        const clone = entity.clone();
                        clone.position.set(
                            (Math.random() - 0.5) * 0.5,
                            (Math.random() - 0.5) * 0.5,
                            (Math.random() - 0.5) * 0.5
                        );
                        clone.scale.set(0.7, 0.7, 0.7);
                        entity.add(clone);
                    }
                    break;
                case 6: // Variante plus angoissante/agressive
                    // Augmenter la vitesse d'animation
                    const originalUpdate = entity.userData.update;
                    if (originalUpdate) {
                        entity.userData.update = (time) => {
                            originalUpdate(time * 1.5); // Animation plus rapide
                        };
                    }
                    break;
                // Cas par d√©faut: aucune modification
            }
        }
        
        // Jouer un son myst√©rieux (simulation)
        function playMysterySound(type) {
            // Ici, on ne fait que simuler le son avec console.log
            // Dans une application r√©elle, vous utiliseriez l'API Web Audio
            const sounds = [
                "Chuchotements inqui√©tants",
                "Crissement humide",
                "Respiration profonde",
                "Bourdonnement √©lectrique",
                "G√©missement spectral",
                "Vrombissement √©nerg√©tique",
                "Grognement mena√ßant"
            ];
            
            console.log(`Son: ${sounds[Math.min(type, sounds.length - 1)]}`);
            
            // D√©clencher un √©v√©nement al√©atoire bas√© sur la progression narrative
            if (Math.random() < window.storyProgress * 0.05) {
                setTimeout(() => {
                    console.log("√âv√©nement sonore sp√©cial d√©clench√©!");
                    // Effet suppl√©mentaire possible ici
                }, 1000 + Math.random() * 2000);
            }
        }
        
        // D√©clencher un effet sp√©cial selon le type d'√©l√©ment myst√©rieux
        function triggerMysteryEffect(type, element) {
            // Effets vari√©s selon le type
            switch(type) {
                case 0: // Yeux - Flash rapide de lumi√®re rouge
                    flashLightEffect(0xff0000);
                    break;
                case 1: // Tentacule - Secousse de cam√©ra
                    cameraShakeEffect(0.5);
                    break;
                case 2: // Silhouette - Assombrissement temporaire
                    darkenEffect(1.5);
                    break;
                case 3: // Objet flottant - Pulse lumineux
                    pulseLightEffect(0x88ffff, 3);
                    break;
            }
        }
        
        // Effet de flash de lumi√®re
        function flashLightEffect(color) {
            const flashLight = new THREE.PointLight(color, 2, 10);
            flashLight.position.set(0, 0, 0);
            window.scene.add(flashLight);
            
            // Animation du flash
            let intensity = 2;
            const interval = setInterval(() => {
                intensity -= 0.1;
                flashLight.intensity = intensity;
                
                if (intensity <= 0) {
                    clearInterval(interval);
                    window.scene.remove(flashLight);
                }
            }, 50);
        }
        
        // Effet de secousse de cam√©ra
        function cameraShakeEffect(intensity) {
            const originalPosition = window.camera.position.clone();
            
            const interval = setInterval(() => {
                const shakeX = (Math.random() - 0.5) * intensity;
                const shakeY = (Math.random() - 0.5) * intensity;
                
                window.camera.position.set(
                    originalPosition.x + shakeX,
                    originalPosition.y + shakeY,
                    originalPosition.z
                );
                
                intensity -= 0.01;
                if (intensity <= 0) {
                    clearInterval(interval);
                    window.camera.position.copy(originalPosition);
                }
            }, 50);
        }
        
        // Effet d'assombrissement temporaire
        function darkenEffect(duration) {
            const originalIntensity = window.ambientLight.intensity;
            window.ambientLight.intensity = 0.1;
            
            setTimeout(() => {
                window.ambientLight.intensity = originalIntensity;
            }, duration * 1000);
        }
        
        // Effet de pulse lumineux
        function pulseLightEffect(color, duration) {
            const pulseLight = new THREE.PointLight(color, 1, 10);
            pulseLight.position.set(0, 0, 0);
            window.scene.add(pulseLight);
            
            let intensity = 1;
            const interval = setInterval(() => {
                intensity = 1 + Math.sin(Date.now() * 0.005) * 0.5;
                pulseLight.intensity = intensity;
                
                duration -= 0.1;
                if (duration <= 0) {
                    clearInterval(interval);
                    window.scene.remove(pulseLight);
                }
            }, 50);
        }
        
        // ==========================================
        // FONCTIONS DE GESTION DE L'EXP√âRIENCE
        // ==========================================
        
        // G√©rer un √©l√©ment narratif
        function handleNarrativeElement(element) {
            switch (element.type) {
                case "clue":
                    // Afficher l'indice
                    showClue(element.data);
                    break;
                case "event":
                    // D√©clencher un √©v√©nement narratif
                    triggerNarrativeEvent(element.data);
                    break;
            }
        }
        
        // Afficher un indice
        function showClue(clue) {
            // Afficher l'indice dans l'interface utilisateur
            console.log(`Indice d√©couvert: ${clue.title}`);
            console.log(clue.description);
            
            // Marquer l'indice comme d√©couvert
            window.discoveredClues.push(clue.id);
        }
        
        // D√©clencher un √©v√©nement narratif
        function triggerNarrativeEvent(event) {
            // D√©clencher l'√©v√©nement narratif
            console.log(`√âv√©nement narratif d√©clench√©: ${event.title}`);
            console.log(event.description);
            
            // Appliquer les effets de l'√©v√©nement
            event.effects.forEach(effect => {
                switch (effect.type) {
                    case "light":
                        // Modifier l'intensit√© de la lumi√®re
                        window.ambientLight.intensity = effect.intensity;
                        break;
                    case "sound":
                        // Jouer un son
                        playSound(effect.sound);
                        break;
                    case "camera":
                        // Effet de cam√©ra
                        cameraShakeEffect(effect.intensity);
                        break;
                    case "door":
                        // Modifier une porte
                        modifyDoor(effect.doorId, effect.modification);
                        break;
                }
            });
        }
        
        // Jouer un son
        function playSound(sound) {
            // Ici, on ne fait que simuler le son avec console.log
            // Dans une application r√©elle, vous utiliseriez l'API Web Audio
            console.log(`Son: ${sound}`);
        }
        
        // Modifier une porte
        function modifyDoor(doorId, modification) {
            const door = window.specialDoors[doorId];
            if (!door) return;
            
            switch (modification.type) {
                case "glow":
                    // Ajouter un effet lumineux
                    addGlowToDoor(door, door.userData.doorMesh);
                    break;
                case "rust":
                    // Ajouter des taches de rouille
                    addRustToDoor(door, door.userData.doorMesh);
                    break;
                case "clawMarks":
                    // Ajouter des marques de griffes
                    addClawMarksToDoor(door, door.userData.doorMesh);
                    break;
            }
        }
        
        // ==========================================
        // FONCTIONS DE GESTION DES √âV√âNEMENTS
        // ==========================================
        
        // G√©rer les √©v√©nements narratifs
        function handleStoryUpdates(updates) {
            // Traiter les mises √† jour narratives
            updates.forEach(update => {
                switch (update.type) {
                    case "clue":
                        // Afficher un indice
                        showClue(update.data);
                        break;
                    case "event":
                        // D√©clencher un √©v√©nement narratif
                        triggerNarrativeEvent(update.data);
                        break;
                }
            });
        }
        
        // G√©rer les donations
        function handleDonations(donations) {
            // Traiter les donations
            donations.forEach(donation => {
                // Mettre √† jour la jauge d'authentification
                updateAuthGauge(donation.amount);
                
                // Afficher une notification
                showDonationNotification(donation);
            });
        }
        
        // Afficher une notification de donation
        function showDonationNotification(donation) {
            // Afficher une notification dans l'interface utilisateur
            console.log(`Donation re√ßue: ${donation.amount} SATS de ${donation.sender}`);
        }
        
        // ==========================================
        // FONCTIONS DE GESTION DE L'INTERFACE UTILISATEUR
        // ==========================================
        
        // Mettre √† jour la jauge d'authentification
        function updateAuthGauge(amount) {
            // Mettre √† jour la jauge d'authentification
            window.authGauge.update(amount);
        }
        
        // Mettre √† jour le compte √† rebours
        function updateCountdown(remainingTime) {
            // Mettre √† jour le compte √† rebours
            const minutes = Math.floor(remainingTime / 60);
            const seconds = remainingTime % 60;
            const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            document.getElementById('vote-timer').textContent = formattedTime;
        }
        
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TikTok Horror Experience - Saison 1: Les Profondeurs</title>
    <link rel="stylesheet" href="responsive.css">
    <link rel="stylesheet" href="auth_gauge.css">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
        
        #loading { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: #000; 
            color: #fff; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            z-index: 1000;
        }
        
        #debug {
            position: fixed; 
            top: 10px; 
            left: 10px; 
            z-index: 10;
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px;
            border-radius: 5px;
        }
        
        #donation-panel {
            position: fixed;
            right: 10px;
            top: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 180px;
            font-size: 11px;
            display: none; /* Hide donation panel as requested */
        }
        
        #donation-panel h3 {
            margin-top: 0;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 40px; /* D√©plac√© plus bas pour √©viter le chevauchement */
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            max-width: 400px;
            z-index: 900;
        }
        
        .progress-bar {
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            margin-bottom: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9900);
            width: 0%;
            transition: width 1s ease-in-out;
        }
        
        #story-milestone {
            position: fixed;
            top: 80px; /* D√©plac√© encore plus bas */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 12px;
            z-index: 900;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
            padding: 5px 10px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            width: 40%;
            max-width: 400px;
            line-height: 1.3;
            display: none; /* Cach√© par d√©faut, sera affich√© dans le journal uniquement */
        }
        
        #donor-wall {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Align√© avec le journal d'exploration */
            max-height: 130px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Cach√© car remplac√© par top100 */
        }
        
        #top100-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* En bas de l'√©cran, directement sous le journal */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px;
            max-height: 150px;
            overflow: hidden;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Cach√© car remplac√© par leaderboard-panel */
        }
        
        #top100-panel h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 13px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .top100-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
            position: relative;
        }
        
        .top100-rank {
            width: 20px;
            text-align: center;
            color: #aaa;
        }
        
        .top100-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .top100-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #narrative-display {
            position: fixed;
            top: 50%; /* Centr√© verticalement */
            left: 50%;
            transform: translate(-50%, -50%); /* Centrage parfait */
            z-index: 950;
            color: white;
            text-align: center;
            width: 70%;
            max-width: 600px;
            text-shadow: 0 0 3px black, 0 0 5px black;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Fond plus opaque pour meilleure lisibilit√© */
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none; /* Pour √©viter d'interf√©rer avec les clics */
        }
        
        #narrative-display.visible {
            opacity: 0.95;
        }
        
        #clue-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 950;
            color: #ffcc00;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 3px solid #ffcc00;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease-out;
        }
        
        #clue-notification.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #event-counter {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            color: white;
            font-size: 120px;
            text-shadow: 0 0 20px red;
            opacity: 0;
            transition: all 0.3s ease-in-out;
            pointer-events: none;
        }
        
        #event-counter.visible {
            opacity: 1;
        }
        
        button, input { 
            margin: 5px 0; 
            display: block;
            border: none;
            background: #444;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #666;
        }
        
        #sim-donation {
            margin-top: 15px;
            width: 100%;
        }
        
        #vote-panel {
            position: fixed;
            right: 10px;
            bottom: 10px; /* En bas √† droite */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 160px;
            font-size: 10px;
            display: none;
        }
        
        .vote-option {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .vote-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .vote-bar {
            height: 5px;
            width: 100%;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .vote-fill {
            height: 100%;
            background: linear-gradient(90deg, #77ccff, #4488ff);
            width: 30%;
        }
        
        /* Animation pour les effects */
        @keyframes pulse {
            0% { opacity: 0.2; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.2; transform: scale(0.95); }
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        #leaderboard-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* Repositionn√© en bas sous le journal */
            top: auto; /* Annule la position top pr√©c√©dente */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 200px;
            max-height: 145px; /* Hauteur r√©duite pour √©viter le chevauchement (√©tait √† 150px) */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #leaderboard-panel h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #aaa;
            width: 20px;
            text-align: center;
        }
        
        .leaderboard-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .leaderboard-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #story-history-panel {
            position: fixed;
            left: 10px;
            bottom: 175px; /* Remont√© plus haut pour √©viter le chevauchement (√©tait √† 70px) */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* √âlargi pour mieux afficher les messages */
            max-height: 180px; /* L√©g√®rement plus grand */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #story-history-panel h3 {
            margin-top: 0;
            margin-bottom: 3px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .history-item {
            margin-bottom: 4px;
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .history-item-milestone {
            background-color: rgba(255, 204, 0, 0.2);
            border-left: 2px solid #ffcc00;
        }
        
        .history-item-discovery {
            background-color: rgba(119, 204, 255, 0.2);
            border-left: 2px solid #77ccff;
        }
        
        .history-item-event {
            background-color: rgba(255, 102, 102, 0.2);
            border-left: 2px solid #ff6666;
        }
        
        .history-timestamp {
            color: #aaa;
            font-size: 8px;
            margin-bottom: 2px;
            font-style: italic;
        }
        
        /* Style pour r√©server l'espace pour la cam√©ra */
        .camera-space {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 100px;
            z-index: 800;
            /* Background comment√© - juste pour visualiser l'espace r√©serv√© 
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            */
        }
        
        /* Assurons-nous que tous les panneaux ont une apparence coh√©rente */
        #leaderboard-panel, #story-history-panel, #vote-panel, #donor-wall {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.85; /* L√©g√®rement transparent pour voir le bateau derri√®re */
        }
        
        /* Animation de d√©filement automatique pour les panneaux */
        @keyframes autoscroll {
            0% { transform: translateY(0); }
            45% { transform: translateY(calc(-100% + 100px)); }
            55% { transform: translateY(calc(-100% + 100px)); } /* Pause au bas pendant 10% de l'animation */
            57% { transform: translateY(0); } /* Retour tr√®s rapide au d√©but (2% de l'animation) */
            100% { transform: translateY(0); } /* Pause au d√©but avant de recommencer */
        }
        
        .autoscroll-container {
            height: 100%;
            overflow: hidden;
            position: relative;
            max-height: inherit;
        }
        
        .autoscroll-content {
            animation: autoscroll 60s linear infinite; /* Remis √† "infinite" pour boucler */
            animation-play-state: running;
            padding-bottom: 20px; /* Add space at the bottom before repeating */
        }
        
        .autoscroll-content:hover {
            animation-play-state: paused;
        }
        
        /* Objectifs sur la barre en haut */
        #objectives-panel {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            display: flex;
            gap: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .objective {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .objective-icon {
            color: #ffcc00;
            font-size: 14px;
        }
        
        .objective-text {
            white-space: nowrap;
        }
        
        /* 
        Organisation des panneaux :
        - Haut: Objectifs
        - Droite: Progression narrative 
        - √Ä gauche milieu: Journal d'exploration
        - √Ä gauche bas: Classement des explorateurs
        - En bas √† droite: Panneau de vote
        - Centre haut (ajust√©): Barre de progression
        - Centre bas: Affichage narratif
        */
        
        /* Hover effect pour rendre les panneaux plus lisibles au survol */
        #leaderboard-panel:hover, #story-history-panel:hover, #donation-panel:hover, #vote-panel:hover, #donor-wall:hover {
            opacity: 0.95;
            z-index: 950; /* Augmente le z-index au survol pour s'assurer qu'il est au-dessus des autres */
        }
        
        /* Style pour les titres des panneaux */
        #leaderboard-panel h3, #story-history-panel h3, #donor-wall h4 {
            color: #ffcc00;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        #details-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 950;
            background: rgba(0,0,0,0.7);
            color: #ffcc00;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid rgba(255, 204, 0, 0.3);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            display: none; /* Cacher le bouton des d√©tails d'exploration */
        }
        
        #details-button:hover {
            background: rgba(50,50,0,0.7);
            border-color: rgba(255, 204, 0, 0.6);
        }
        
        /* Overlay d'authentification */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #33ff33;
            font-family: 'Courier New', monospace;
        }
        
        .auth-content {
            text-align: center;
            max-width: 500px;
            padding: 20px;
        }
        
        .auth-logo {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
        }
        
        .auth-message {
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        .auth-warning {
            color: #ff3333;
            margin-top: 20px;
            font-size: 12px;
            max-width: 80%;
            text-align: justify;
        }
        
        .donation-progress-container {
            width: 300px;
            margin: 0 auto;
        }
        
        .donation-label {
            color: #fff;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .donation-bar {
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #ff3366;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        #auth-donation-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff3366, #ff6699);
            transition: width 0.5s ease-in-out;
        }
        
        .auth-gauge {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .auth-gauge h3 {
            margin-top: 0;
            font-size: 14px;
            color: #ffcc00;
        }
        
        .tiktok-integration-notice {
            font-size: 12px;
            color: #ccc;
        }
        
        /* Notifications d'authentification */
        .auth-notification {
            position: fixed;
            right: -300px;
            top: 100px;
            background: linear-gradient(90deg, #330033, #5a0057);
            border-left: 3px solid #ff3366;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            padding: 15px;
            width: 250px;
            border-radius: 5px 0 0 5px;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .auth-notification.show {
            right: 0;
        }
        
        .auth-username {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .auth-amount {
            color: #ff3366;
            font-weight: bold;
            font-size: 18px;
        }
        
        /* Statut du syst√®me */
        .system-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #33ff33;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #ff3333;
        }
        
        .status-indicator.online {
            background-color: #33ff33;
        }
        
        /* Animation de pulsation pour la jauge */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .auth-gauge.pulse {
            animation: pulse 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
    <!-- Inclure les fichiers externes pour la gestion de l'authentification -->
    <script src="auth_gauge.js"></script>
    <script>
        /**
         * Gestion de la jauge d'authentification du syst√®me
         */
        
        // Configuration
        const REQUIRED_AMOUNT = 10; // Montant requis pour d√©bloquer l'acc√®s (en unit√©s)
        let totalProgress = 0; // Variable globale pour suivre la progression
        
        /**
         * Initialisation de la jauge d'authentification
         */
        function initAuthGauge() {
            console.log("Initialisation de la jauge d'authentification");
            
            // R√©cup√©rer les √©l√©ments pour v√©rifier qu'ils existent
            const fillBar = document.getElementById('auth-donation-fill');
            const percentText = document.getElementById('auth-donation-percent');
            
            if (fillBar) {
                console.log("√âl√©ment 'auth-donation-fill' trouv√©");
            } else {
                console.error("√âl√©ment 'auth-donation-fill' introuvable");
            }
            
            if (percentText) {
                console.log("√âl√©ment 'auth-donation-percent' trouv√©");
            } else {
                console.error("√âl√©ment 'auth-donation-percent' introuvable");
            }
            
            // Mettre √† jour l'affichage initial
            updateAuthGauge(0);
            
            // √âcouter les messages d'authentification externes
            window.addEventListener('message', function(event) {
                console.log("Message re√ßu:", event.data);
                // V√©rifier si le message contient des donn√©es d'authentification
                if (event.data && event.data.type === 'auth_progress') {
                    processAuthProgress(event.data.data);
                }
            });
        
            // V√©rifier la progression √† intervalles r√©guliers
            setInterval(checkAuthProgress, 5000);
            
            // Faire une v√©rification imm√©diate
            setTimeout(checkAuthProgress, 1000);
        }
        
        /**
         * Mise √† jour visuelle de la jauge d'authentification
         */
        function updateAuthGauge(amount) {
            console.log("Mise √† jour de la jauge d'authentification avec:", amount);
            
            // Obtenir les √©l√©ments de la jauge
            const fillBar = document.getElementById('auth-donation-fill');
            const percentText = document.getElementById('auth-donation-percent');
            
            // Calculer le pourcentage de progression
            const percentage = Math.min((amount / REQUIRED_AMOUNT) * 100, 100);
            console.log("Pourcentage calcul√©:", percentage);
            
            if (fillBar) {
                console.log("Mise √† jour de la barre de remplissage");
                // Mettre √† jour la barre de progression
                fillBar.style.width = percentage + '%';
            } else {
                console.error("√âl√©ment 'auth-donation-fill' introuvable");
            }
            
            if (percentText) {
                console.log("Mise √† jour du texte de pourcentage");
                // Mettre √† jour le texte du pourcentage
                percentText.textContent = Math.floor(percentage) + '%';
            } else {
                console.error("√âl√©ment 'auth-donation-percent' introuvable");
            }
            
            // V√©rifier si le seuil est atteint pour d√©bloquer
            if (amount >= REQUIRED_AMOUNT) {
                unlockAuthScreen();
            }
        }
        
        /**
         * Traitement d'une progression d'authentification
         */
        function processAuthProgress(progressData) {
            console.log("Traitement des donn√©es de progression:", progressData);
            
            // V√©rifier que les donn√©es contiennent les informations n√©cessaires
            if (progressData && progressData.username && progressData.amount) {
                // Convertir le montant en unit√©s si n√©cessaire
                const amount = parseFloat(progressData.amount);
                if (isNaN(amount)) {
                    console.error("Montant invalide:", progressData.amount);
                    return;
                }
        
                console.log("Ajout de", amount, "au total");
                // Mettre √† jour le total
                totalProgress += amount;
                
                // Mettre √† jour l'affichage
                updateAuthGauge(totalProgress);
                
                // Afficher une notification
                showAuthNotification(progressData.username, amount);
            } else {
                console.error("Donn√©es de progression incompl√®tes:", progressData);
            }
        }
        
        /**
         * Affichage d'une notification pour une progression d'authentification
         */
        function showAuthNotification(username, amount) {
            // Cr√©er un √©l√©ment de notification
            const notification = document.createElement('div');
            notification.className = 'auth-notification';
            notification.innerHTML = `
                <span class="auth-username">${username}</span>
                <span class="auth-amount">+${amount.toFixed(2)} unit√©s</span>
            `;
            
            // Ajouter la notification au DOM
            document.body.appendChild(notification);
            
            // Animer la notification
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);
            
            // Supprimer la notification apr√®s un d√©lai
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 500);
            }, 5000);
        }
        
        /**
         * V√©rification de la progression d'authentification √† intervalles r√©guliers
         */
        function checkAuthProgress() {
            console.log("V√©rification de la progression locale");
            
            // Utiliser une m√©thode alternative pour lire le fichier local
            fetch('/latest_auth_progress.json')
                .then(response => {
                    console.log("R√©ponse du serveur pour le fichier local:", response.status);
                    if (!response.ok) {
                        throw new Error('Fichier non disponible');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log("Donn√©es locales r√©cup√©r√©es:", data);
                    if (data && data.username && data.amount) {
                        // Traiter le don local
                        processAuthProgress(data);
                        // R√©initialiser le fichier pour √©viter de traiter le m√™me don plusieurs fois
                        resetLocalAuthProgress();
                    } else if (Object.keys(data).length === 0) {
                        console.log("Fichier local vide, pas de nouvelle progression");
                    } else {
                        console.error("Fichier local incomplet:", data);
                    }
                })
                .catch(error => {
                    // Silencieux en cas d'erreur - le fichier n'existe peut-√™tre pas encore
                    console.log('Pas de nouveau progr√®s d\'authentification local:', error.message);
                });
        }
        
        /**
         * R√©initialise le fichier de progression locale apr√®s traitement
         */
        function resetLocalAuthProgress() {
            // Appel au serveur pour r√©initialiser le fichier
            fetch('/api/reset-auth-progress', {
                method: 'POST'
            }).catch(error => {
                console.error('Erreur lors de la r√©initialisation de la progression:', error);
            });
        }
        
        /**
         * D√©bloque l'√©cran d'authentification quand le seuil est atteint
         */
        function unlockAuthScreen() {
            const authOverlay = document.getElementById('auth-overlay');
            if (authOverlay && authOverlay.style.display !== 'none') {
                // Animation de disparition
                authOverlay.style.opacity = '0';
                setTimeout(() => {
                    authOverlay.style.display = 'none';
                    // Masquer l'√©cran de chargement pour afficher l'exp√©rience 3D
                    const loadingScreen = document.getElementById('loading');
                    if (loadingScreen) {
                        loadingScreen.style.display = 'none';
                    }
                    
                    // Initialiser le jeu apr√®s l'authentification
                    if (typeof initializeAfterAuth === 'function') {
                        initializeAfterAuth();
                    } else {
                        // Initialiser ou afficher l'exp√©rience du bateau si elle est d√©j√† charg√©e
                        if (window.scene && window.camera && window.renderer) {
                            console.log("Exp√©rience 3D d√©j√† charg√©e, activation");
                            // Ajouter ici tout code n√©cessaire pour d√©marrer l'animation du bateau
                        } else {
                            console.log("Initialisation de l'exp√©rience 3D");
                            // Initialiser la sc√®ne Three.js si pas encore fait
                            initScene();
                        }
                    }
                }, 1000);
                
                console.log("Authentification r√©ussie, acc√®s d√©bloqu√©");
            }
        }
        
        // Initialiser la jauge d'authentification au chargement de la page
        document.addEventListener('DOMContentLoaded', initAuthGauge);
    </script>
</head>
<body>
    <!-- Overlay d'authentification -->
    <div class="auth-overlay" id="auth-overlay">
        <div class="auth-content">
            <div class="auth-logo">THE-DEPTHS v3.6.7</div>
            <div class="auth-message">
                AVERTISSEMENT: Vous √™tes sur le point d'acc√©der √† un r√©seau non autoris√©.<br><br>
                Ce terminal sert d'interface aux communications internes du groupe THE-DEPTHS.<br>
                Toute intrusion non autoris√©e sera trac√©e et signal√©e aux administrateurs.<br><br>
                Cet acc√®s est seulement destin√© aux membres confirm√©s.
            </div>
            
            <div class="auth-gauge">
                <h3 style="text-align: center;">Progression vers l'authentification</h3>
                <div class="donation-progress-container">
                    <div class="donation-label" style="text-align: center; display: block; width: 100%;">Progression : <span id="auth-donation-percent">0%</span></div>
                    <div class="donation-bar">
                        <div id="auth-donation-fill" style="width: 0%;"></div>
                    </div>
                </div>
                <div class="tiktok-integration-notice" style="text-align: center; width: 100%;">
                    Connexion aux syst√®mes de s√©curit√© en cours...
                </div>
            </div>
            
            <div style="text-align: center; width: 100%;">
                <button id="auth-accept" style="background: #111; color: #777; border: 1px solid #666; padding: 10px 20px; cursor: not-allowed; margin-top: 20px; opacity: 0.6; display: inline-block;">
                    AUTHENTIFICATION VERROUILL√âE
            </button>
            </div>
            
            <div class="auth-warning">
                SYST√àME DE S√âCURIT√â: L'acc√®s √† cette interface est strictement contr√¥l√©. Une authentification externe est n√©cessaire pour d√©bloquer le terminal.
            </div>
        </div>
    </div>
    
    <!-- Indicateur de statut du syst√®me -->
    <div class="system-status" id="system-status">
        <div class="status-indicator" id="status-light"></div>
        <span id="status-text">SYST√àME HORS LIGNE</span>
    </div>
    
    <div id="loading">
        <h2>Exploration des Profondeurs</h2>
            <div style="width: 200px; height: 20px; background: #333; border-radius: 10px; overflow: hidden; margin: 20px 0;">
                <div id="load-progress" style="width: 0%; height: 100%; background: linear-gradient(90deg, #ff0066, #ffcc00);"></div>
            </div>
            <div>Chargement de l'exp√©rience...</div>
    </div>
    
    <div id="details-button" onclick="window.open('exploration_details.html', '_blank')">
        <span>üìä</span>
        <span>D√©tails d'Exploration</span>
    </div>
    
    <div id="progress-display">
        <div style="display: flex; justify-content: space-between;">
            <span>PROGRESSION: </span>
            <span id="progress-percent">0%</span>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="story-progress"></div>
        </div>
        <div style="display: flex; justify-content: space-between;">
            <span>D√âBUT</span>
            <span>FIN</span>
        </div>
        <div style="text-align: center; font-size: 10px; color: #ffcc00; margin-top: 3px; text-shadow: 0 0 2px #000;">
            Votre participation stabilise la connexion et r√©v√®le de nouveaux myst√®res
        </div>
    </div>
    
    <div id="debug" style="display: none;">
        <h3>Contr√¥les Debug</h3>
        <button id="giftBtn">Simuler cadeau</button>
        <input id="commentInput" type="text" placeholder="Commentaire">
        <button id="commentBtn">Envoyer</button>
        <button id="likeBtn">Simuler likes</button>
        <button id="toggle-debug">Afficher contr√¥les avanc√©s</button>
        <div id="advanced-debug" style="display: none; margin-top: 10px;">
            <button id="debug-milestone">D√©bloquer milestone</button>
            <button id="debug-entity">Invoquer entit√©</button>
            <button id="debug-clue">R√©v√©ler indice</button>
            <button id="debug-event">D√©clencher √©v√©nement</button>
            <button id="debug-vote">Lancer vote</button>
        </div>
    </div>
    
    <div id="donation-panel">
        <h3 style="margin-top: 0; text-align: center;">Les Profondeurs</h3>
        <button id="open-donation-simulator" style="width:100%; margin-bottom:5px; font-size:10px; padding:4px;">
            Ouvrir le Simulateur de Dons
        </button>
        <div style="font-size:9px; margin-bottom:5px; text-align:center;">
            Pour simuler un don, utilisez le simulateur
        </div>
        <button id="open-tiktok-config" style="width:100%; margin-bottom:10px; font-size:10px; padding:4px; background-color:#ff3366;">
            Configurer API TikTok
        </button>
        <div style="display: flex; justify-content: space-between;">
            <span>Progression narrative:</span>
            <span id="progress-percent">0%</span>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="story-progress"></div>
        </div>
        <div style="display: flex; justify-content: space-between;">
            <span>Prochain palier:</span>
            <span id="next-milestone-amount">500 unit√©s</span>
        </div>
        <div id="story-milestone">
            "Le passage vers le secteur 2 semble bloqu√©. Une intervention externe est n√©cessaire pour r√©tablir l'acc√®s..."
        </div>
        <div style="margin-top: 15px;">
            <div style="display: flex; justify-content: space-between;">
                <span>Total des contributions:</span>
                <span id="total-donations">0 unit√©s</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
                <span>Myst√®res r√©solus:</span>
                <span id="solved-mysteries">0/13</span>
            </div>
        </div>
    </div>
    
    <div id="donor-wall">
        <h4 style="margin-top: 0;">Contributeurs R√©cents</h4>
        <div id="donor-list">
            <!-- Les contributeurs seront ajout√©s ici dynamiquement -->
        </div>
    </div>
    
    <div id="top100-panel">
        <h4>Top 100 Explorateurs</h4>
        <div id="top100-list">
            <!-- La liste des 100 meilleurs sera ici -->
        </div>
    </div>
    
    <div id="narrative-display"></div>
    
    <div id="clue-notification">Indice trouv√©: Enigme #172</div>
    
    <div id="event-counter"></div>
    
    <div id="vote-panel">
        <h4 style="margin-top: 0;">Vote Communautaire</h4>
        <p id="vote-question">Quelle porte le voyageur devrait-il ouvrir ensuite?</p>
        <div class="vote-option" data-option="1">
            <div style="display: flex; justify-content: space-between;">
                <span>Porte avec symbole spirale</span>
                <span>30%</span>
            </div>
            <div class="vote-bar">
                <div class="vote-fill" style="width: 30%"></div>
            </div>
        </div>
        <div class="vote-option" data-option="2">
            <div style="display: flex; justify-content: space-between;">
                <span>Porte rouge clignotante</span>
                <span>45%</span>
            </div>
            <div class="vote-bar">
                <div class="vote-fill" style="width: 45%"></div>
            </div>
        </div>
        <div class="vote-option" data-option="3">
            <div style="display: flex; justify-content: space-between;">
                <span>Porte avec marques de griffes</span>
                <span>25%</span>
            </div>
            <div class="vote-bar">
                <div class="vote-fill" style="width: 25%"></div>
            </div>
        </div>
        <p style="font-size: 12px; text-align: center; margin-top: 10px;">Votre interaction compte comme un vote. Fin dans <span id="vote-timer">02:45</span></p>
    </div>

    <!-- Charger Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // D√©finir les variables globales
        window.scene = null;
        window.camera = null;
        window.renderer = null;
        window.boat = null;
        window.doors = [];
        window.segments = [];
        window.boatSpeed = 0.05;
        window.moveDirection = { x: 0, z: 1 };
        // Variable pour stocker les r√©f√©rences aux fen√™tres ouvertes
        window.detailWindows = [];
        
        // Variables pour le syst√®me de narration et de dons
        window.totalDonations = 0;
        window.currentSeason = 1;
        window.currentEpisode = 1;
        window.currentMilestoneIndex = 0;
        window.storyProgress = 0;
        window.mysteryElements = {};
        window.discoveredClues = [];
        window.solvedMysteries = 0;
        window.activatedDoors = 0;
        window.specialDoors = {};
        window.activeVote = null;
        
        // Constantes
        const TUNNEL_RADIUS = 5;
        const TUNNEL_LENGTH = 20;
        const WATER_LEVEL = -2;
        
        // D√©finition des paliers de donation pour le progr√®s narratif
        const STORY_MILESTONES = [
            { amount: 100, title: "Prologue: L'entr√©e", description: "Les premi√®res portes commencent √† r√©v√©ler d'√©tranges ph√©nom√®nes...", unlocksFunction: unlockPrologue },
            { amount: 500, title: "Secteur 2: Murmures", description: "Des voix lointaines r√©sonnent dans l'eau. Elles semblent raconter des fragments d'histoires...", unlocksFunction: unlockSector2 },
            { amount: 1500, title: "Secteur 3: M√©moires", description: "Des symboles apparaissent sur certaines portes. Ils semblent former un code √† d√©chiffrer...", unlocksFunction: unlockSector3 },
            { amount: 3000, title: "Secteur 4: R√©sonance", description: "L'eau commence √† vibrer √† intervalles r√©guliers. Une pr√©sence se fait sentir dans les profondeurs...", unlocksFunction: unlockSector4 },
            { amount: 5000, title: "Confrontation Mineure: L'Observateur", description: "Une entit√© myst√©rieuse semble suivre le bateau. Ses intentions sont inconnues...", unlocksFunction: unlockMinorEntity },
            { amount: 8000, title: "Secteur 5: Distorsion", description: "La r√©alit√© semble se plier. Certaines portes m√®nent √† des lieux impossibles...", unlocksFunction: unlockSector5 },
            { amount: 12000, title: "Secteur 6: Convergence", description: "Les indices commencent √† converger. Un sch√©ma plus large se dessine...", unlocksFunction: unlockSector6 },
            { amount: 18000, title: "Confrontation Majeure: Le Gardien", description: "Une pr√©sence ancienne bloque le chemin. Elle doit √™tre confront√©e pour continuer...", unlocksFunction: unlockMajorEntity },
            { amount: 25000, title: "Secteur 7: V√©rit√©", description: "Les derniers fragments du myst√®re se d√©voilent. La v√©rit√© est presque √† port√©e...", unlocksFunction: unlockSector7 },
            { amount: 35000, title: "Finale: R√©v√©lation", description: "Le myst√®re final des Profondeurs est sur le point d'√™tre r√©v√©l√©...", unlocksFunction: unlockFinale }
        ];
        
        // D√©finition des niveaux de contributeurs
        const DONOR_TIERS = [
            { min: 1, max: 49, name: "Explorateur", class: "donor-common" },
            { min: 50, max: 199, name: "Chercheur", class: "donor-rare" },
            { min: 200, max: 999, name: "√âclaireur", class: "donor-epic" },
            { min: 1000, max: Infinity, name: "Illumin√©", class: "donor-legendary" }
        ];
        
        // Base de donn√©es des √©l√©ments narratifs
        const STORY_ELEMENTS = {
            clues: [
                { id: "C001", text: "Num√©ro grav√©: 7-3-9-4-2", category: "sequence", linkedMystery: "M003" },
                { id: "C002", text: "Inscription: 'Le cercle s'√©largit mais revient toujours au centre'", category: "phrase", linkedMystery: "M001" },
                { id: "C003", text: "Symbole r√©current: ≈ìil travers√© par une ligne verticale", category: "symbol", linkedMystery: "M002" },
                { id: "C004", text: "Date r√©p√©titive: 22.07.1976", category: "date", linkedMystery: "M005" },
                { id: "C005", text: "Coordonn√©es fragment√©es: 47¬∞N 13...", category: "location", linkedMystery: "M004" },
                { id: "C006", text: "Mot invers√©: RUEGREMBUS", category: "word", linkedMystery: "M002" },
                { id: "C007", text: "Sch√©ma circulaire avec 9 points", category: "pattern", linkedMystery: "M001" },
                { id: "C008", text: "R√©f√©rence: 'Projet Abyssus'", category: "name", linkedMystery: "M007" },
                { id: "C009", text: "√âquation: 2x¬≤ + 3x - ‚àö(4) = 0", category: "math", linkedMystery: "M003" },
                { id: "C010", text: "Fragment audio: voix distordue r√©p√©tant 'le sixi√®me cycle'", category: "audio", linkedMystery: "M006" },
                { id: "C011", text: "Phrase cod√©e: VGSPJVYMREGIVPIVW", category: "cipher", linkedMystery: "M005" },
                { id: "C012", text: "Motif de lumi√®res: court-court-long-long-court", category: "pattern", linkedMystery: "M004" }
            ],
            mysteries: [
                { id: "M001", title: "Le Motif Circulaire", requiredClues: ["C002", "C007"], solved: false, reward: "R√©v√®le l'origine du tunnel" },
                { id: "M002", title: "L'Entit√© Observatrice", requiredClues: ["C003", "C006"], solved: false, reward: "D√©bloque une porte sp√©ciale" },
                { id: "M003", title: "La S√©quence Math√©matique", requiredClues: ["C001", "C009"], solved: false, reward: "Permet de pr√©voir certains √©v√©nements" },
                { id: "M004", title: "Les Signaux", requiredClues: ["C005", "C012"], solved: false, reward: "R√©v√®le un mode de communication" },
                { id: "M005", title: "L'Incident Initial", requiredClues: ["C004", "C011"], solved: false, reward: "Explique pourquoi le tunnel existe" },
                { id: "M006", title: "Les Cycles Temporels", requiredClues: ["C010"], solved: false, reward: "D√©bloque une vision du pass√©/futur" },
                { id: "M007", title: "Les Origines du Projet", requiredClues: ["C008"], solved: false, reward: "R√©v√®le qui a cr√©√© cette exp√©rience" }
            ],
            narrativeFragments: [
                "Les enregistrements indiquent que le projet a √©t√© abandonn√© suite √† une 'contamination'.",
                "Le tunnel n'a pas √©t√© construit. Il est apparu spontan√©ment le 22 juillet 1976.",
                "Certains chercheurs affirment avoir vu leur propre reflet vieilli de plusieurs d√©cennies.",
                "L'eau n'est pas r√©ellement de l'eau. Sa composition mol√©culaire est inconnue.",
                "Les portes apparaissaient et disparaissaient m√™me avant notre arriv√©e.",
                "Les tests ont r√©v√©l√© que le temps s'√©coule diff√©remment √† diverses profondeurs.",
                "√âquipe d'exploration #7: 4 entr√©s, 5 revenus. Anomalie consign√©e.",
                "Les manifestations semblent r√©agir aux √©motions collectives des observateurs.",
                "Th√©orie: nous ne sommes pas dans un lieu physique mais dans une projection mentale collective.",
                "Le sixi√®me cycle s'ach√®vera quand le t√©moin final comprendra sa fonction."
            ]
        };
        
        // ==========================================
        // FONCTIONS D'INITIALISATION
        // ==========================================
        
        // Gestion du redimensionnement de la fen√™tre
        function onWindowResize() {
            // Mettre √† jour la cam√©ra
            window.camera.aspect = window.innerWidth / window.innerHeight;
            window.camera.updateProjectionMatrix();
            
            // Mettre √† jour le renderer
            window.renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Initialisation de l'application
        function init() {
            // Cr√©er la sc√®ne Three.js
            window.scene = new THREE.Scene();
            
            // Cr√©er la cam√©ra
            window.camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            window.camera.position.set(0, 1, -5);
            
            // Cr√©er le renderer
            window.renderer = new THREE.WebGLRenderer({ antialias: false });
            window.renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(window.renderer.domElement);
            
            // Ajouter une lumi√®re ambiante
            const light = new THREE.AmbientLight(0x444444);
            window.scene.add(light);
            
            // Effet de brouillard pour l'atmosph√®re
            window.scene.fog = new THREE.FogExp2(0x000000, 0.035);
            
            // Cr√©er le bateau
            window.boat = createBoat();
            
            // Cr√©er le tunnel initial
            for (let i = 0; i < 3; i++) {
                createSegment(i * TUNNEL_LENGTH);
            }
            
            // G√©rer le redimensionnement
            window.addEventListener('resize', onWindowResize);
            
            // Configurer le debug et les contr√¥les de simulation
            setupDebug();
            setupDonationSystem();
            setupVoteSystem();
            
            // Masquer l'√©cran de chargement
            const loadingScreen = document.getElementById('loading');
            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 500);
            }, 2000);
            
            // Afficher le message d'introduction apr√®s un d√©lai
            setTimeout(showNarrativeMessage, 3000, "Bienvenue dans Les Profondeurs. Les portes cachent des secrets. √Ä vous de les d√©couvrir...", 8000);
            
            // Initialiser les variables de narration
            updateMilestoneDisplay();
            
            // Cr√©er le panneau d'objectifs
            createObjectivesPanel();
            
            // Initialiser les panneaux avec d√©filement automatique (activation directe)
            const historyList = document.getElementById('story-history-list');
            const leaderboardList = document.getElementById('leaderboard-list');
            const top100List = document.getElementById('top100-list');
            
            // Activer l'auto-d√©filement pour l'historique
            if (historyList) {
                const historyPanel = document.getElementById('story-history-panel');
                if (historyPanel) historyPanel.style.display = 'block';
            }
            
            // Activer l'auto-d√©filement pour le leaderboard
            if (leaderboardList) {
                const leaderboardPanel = document.getElementById('leaderboard-panel');
                if (leaderboardPanel) leaderboardPanel.style.display = 'block';
            }
            
            // Activer l'auto-d√©filement pour le top100
            if (top100List) {
                const top100Panel = document.getElementById('top100-panel');
                if (top100Panel) top100Panel.style.display = 'block';
            }
            
            // Ajouter quelques entr√©es initiales dans l'historique si vide
            if (!window.storyHistory || window.storyHistory.length === 0) {
                addToStoryHistory('milestone', 'Bienvenue dans Les Profondeurs');
                addToStoryHistory('discovery', 'Explorez les tunnels √† la recherche d\'indices');
                addToStoryHistory('event', 'Attention aux entit√©s myst√©rieuses');
            }
            
            // D√©marrer l'animation
            animate();
            
            // Ajouter un gestionnaire pour le bouton d√©tails d'exploration
            const detailsButton = document.getElementById('details-button');
            if (detailsButton) {
                detailsButton.addEventListener('click', function() {
                    const detailWindow = window.open('exploration_details.html', '_blank');
                    if (detailWindow) {
                        window.detailWindows.push(detailWindow);
                    }
                });
            }
        }
        
        // Animation de chargement
        function simulateLoading() {
                let progress = 5;
                const loadProgressBar = document.getElementById('load-progress');
                
                const interval = setInterval(() => {
                    progress += Math.floor(Math.random() * 8) + 3;
                    if (progress >= 100) {
                        progress = 100;
                        clearInterval(interval);
                    }
                    loadProgressBar.style.width = progress + '%';
                }, 300);
        }
        
        // Configuration du panneau de debug
        function setupDebug() {
            if (window.location.search.includes('debug=true')) {
                const debugPanel = document.getElementById('debug');
                debugPanel.style.display = 'block';
                
                // Toggle des contr√¥les avanc√©s
                document.getElementById('toggle-debug').addEventListener('click', () => {
                    const advancedDebug = document.getElementById('advanced-debug');
                    advancedDebug.style.display = advancedDebug.style.display === 'none' ? 'block' : 'none';
                });
                
                // Bouton pour simuler un cadeau/don
                document.getElementById('giftBtn').addEventListener('click', () => {
                    const randomAmount = Math.floor(Math.random() * 100) + 5;
                    simulateDonation("Viewer" + Math.floor(Math.random() * 1000), randomAmount);
                });
                
                // Bouton pour envoyer un commentaire
                document.getElementById('commentBtn').addEventListener('click', () => {
                    const text = document.getElementById('commentInput').value.toLowerCase();
                    handleComment(text);
                    document.getElementById('commentInput').value = '';
                });
                
                // Bouton pour simuler des likes
                document.getElementById('likeBtn').addEventListener('click', () => {
                    // Petit effet visuel
                    window.camera.position.x += (Math.random() - 0.5) * 0.1;
                    window.camera.position.y += (Math.random() - 0.5) * 0.1;
                });
                
                // Contr√¥les avanc√©s
                document.getElementById('debug-milestone').addEventListener('click', () => {
                    unlockNextMilestone("Debug");
                });
                
                document.getElementById('debug-entity').addEventListener('click', () => {
                    spawnSpecialEntity();
                });
                
                document.getElementById('debug-clue').addEventListener('click', () => {
                    revealRandomClue();
                });
                
                document.getElementById('debug-event').addEventListener('click', () => {
                    triggerSpecialEvent();
                });
                
                document.getElementById('debug-vote').addEventListener('click', () => {
                    startVote();
                });
            }
        }
        
        // Configuration du syst√®me de dons
        function setupDonationSystem() {
            // V√©rifier si le bouton de simulation de dons existe avant d'ajouter l'√©couteur
            const simDonationBtn = document.getElementById('sim-donation');
            if (simDonationBtn) {
                simDonationBtn.addEventListener('click', () => {
                    const amountInput = document.getElementById('donation-amount');
                    const amount = parseInt(amountInput.value);
                    
                    if (amount && amount > 0) {
                        const username = "Viewer" + Math.floor(Math.random() * 10000);
                        simulateDonation(username, amount);
                        amountInput.value = '';
                    }
                });
            }
            
            // Configuration du bouton d'ouverture du simulateur de dons
            const openDonationSimBtn = document.getElementById('open-donation-simulator');
            if (openDonationSimBtn) {
                openDonationSimBtn.addEventListener('click', () => {
                    openDonationSimulator();
                });
            }
            
            // Configuration du bouton d'ouverture de la configuration TikTok
            const openTikTokConfigBtn = document.getElementById('open-tiktok-config');
            if (openTikTokConfigBtn) {
                openTikTokConfigBtn.addEventListener('click', () => {
                    openTikTokConfig();
                });
            }
            
            // Initialisation des valeurs
            updateDonationDisplay();
            
            // Charger la configuration TikTok s'il y en a une
            loadTikTokConfig();
        }
        
        // Fonction pour ouvrir le simulateur de dons (sans cr√©er de fen√™tre popup)
        function openDonationSimulator() {
            // V√©rifier si un panneau de simulation existe d√©j√† et le supprimer s'il est d√©j√† affich√©
            const existingPanel = document.getElementById('inline-donation-panel');
            if (existingPanel) {
                existingPanel.remove();
                return;
            }
            
            // Cr√©er un panneau flottant pour le simulateur de dons int√©gr√©
            const panel = document.createElement('div');
            panel.id = 'inline-donation-panel';
            panel.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 300px;
                background: rgba(0, 0, 0, 0.9);
                border: 1px solid #ff3366;
                z-index: 1000;
                padding: 15px;
                color: white;
                border-radius: 5px;
                box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            `;
            
            // Ajouter le contenu du simulateur
            panel.innerHTML = `
                <h3 style="text-align: center; margin-top: 0;">Simulateur de Dons</h3>
                <button id="close-simulator" style="position: absolute; top: 5px; right: 5px; background: none; border: none; color: #fff; cursor: pointer; font-size: 16px;">√ó</button>
                <div style="margin-bottom: 15px;">
                    <label>Nom d'utilisateur:</label>
                    <input type="text" id="sim-username" value="Utilisateur${Math.floor(Math.random() * 1000)}" style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label>Montant:</label>
                    <input type="number" id="sim-amount" value="5" min="1" max="1000" style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label>Message (optionnel):</label>
                    <input type="text" id="sim-message" placeholder="Message avec votre don..." style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <button id="donate-2" style="flex: 1; margin-right: 5px; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+2‚Ç¨</button>
                    <button id="donate-5" style="flex: 1; margin-right: 5px; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+5‚Ç¨</button>
                    <button id="donate-10" style="flex: 1; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+10‚Ç¨</button>
                </div>
                <button id="send-donation" style="width: 100%; margin-top: 15px; background: #ff3366; border: none; color: white; padding: 10px; cursor: pointer;">Simuler le Don</button>
            `;
            
            // Ajouter le panneau au document
            document.body.appendChild(panel);
            
            // G√©rer la fermeture du panneau
            document.getElementById('close-simulator').addEventListener('click', () => {
                panel.remove();
            });
            
            // G√©rer les boutons de montant pr√©d√©finis
            document.getElementById('donate-2').addEventListener('click', () => {
                document.getElementById('sim-amount').value = "2";
            });
            
            document.getElementById('donate-5').addEventListener('click', () => {
                document.getElementById('sim-amount').value = "5";
            });
            
            document.getElementById('donate-10').addEventListener('click', () => {
                document.getElementById('sim-amount').value = "10";
            });
            
            // G√©rer l'envoi du don
            document.getElementById('send-donation').addEventListener('click', async () => {
                const username = document.getElementById('sim-username').value || `Utilisateur${Math.floor(Math.random() * 1000)}`;
                const amount = parseFloat(document.getElementById('sim-amount').value) || 5;
                const message = document.getElementById('sim-message').value || '';
                
                if (amount <= 0) {
                    alert('Veuillez entrer un montant positif.');
                    return;
                }
                
                try {
                    // Simuler le don via l'API
                    const response = await fetch('/api/simulate/donation', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ username, amount, message })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        // Fermer le panneau apr√®s un don r√©ussi
                        panel.remove();
                        
                        // Appliquer directement le don √† l'interface actuelle
                        simulateDonation(username, amount);
                    } else {
                        console.error('Erreur lors de la simulation du don:', data.message);
                        alert('Erreur lors de la simulation du don: ' + data.message);
                    }
                } catch (error) {
                    console.error('Erreur lors de la simulation du don:', error);
                    alert('Erreur lors de la simulation du don.');
                }
            });
        }
        
        // Ouvrir la page de configuration de l'API TikTok
        function openTikTokConfig() {
            const width = 800;
            const height = 700;
            const left = (window.innerWidth - width) / 2;
            const top = (window.innerHeight - height) / 2;
            
            const popup = window.open('tiktok_api_config.html', 'TikTokConfig', 
                `width=${width},height=${height},left=${left},top=${top},resizable=yes`);
            
            if (popup) {
                window.tikTokConfigPopup = popup;
            }
        }
        
        // Charger la configuration TikTok depuis localStorage
        function loadTikTokConfig() {
            const savedConfig = localStorage.getItem('tiktokApiConfig');
            
            if (savedConfig) {
                try {
                    window.tikTokConfig = JSON.parse(savedConfig);
                    console.log('Configuration TikTok charg√©e:', window.tikTokConfig);
                } catch (error) {
                    console.error('Erreur lors du chargement de la configuration TikTok:', error);
                }
            }
        }
        
        // Mettre √† jour la configuration TikTok (appel√© depuis la page de configuration)
        function updateTikTokConfig(config) {
            window.tikTokConfig = config;
            console.log('Configuration TikTok mise √† jour:', config);
        }
        
        // Traiter un √©v√©nement TikTok (appel√© depuis la page de configuration ou par l'API)
        function processTikTokEvent(event) {
            console.log('√âv√©nement TikTok re√ßu:', event);
            
            switch (event.type) {
                case 'donation':
                    // Convertir le montant en pi√®ces/diamants en euros
                    const convertedAmount = event.convertedAmount || 
                        (event.amount * (window.tikTokConfig?.donationConversion || 0.01));
                    
                    // Simuler un don avec le montant converti
                    simulateDonation(event.username, convertedAmount, event.giftName || 'Don TikTok');
                    
                    // Am√©lioration: V√©rifier si c'est un don majeur pour des effets sp√©ciaux
                    if (convertedAmount >= 50) {
                        triggerSpecialEvent(event.username);
                    } else if (convertedAmount >= 20) {
                        spawnSpecialEntity();
                    }
                    break;
                    
                case 'subscription':
                    // Traiter l'abonnement comme un don avec un montant fixe
                    const subValue = event.value || 
                        (window.tikTokConfig?.subscriptionValue || 4.99);
                    
                    simulateDonation(event.username, subValue, 'Abonnement');
                    
                    // Am√©lioration: Ajouter un indice sp√©cial pour les abonn√©s
                    revealSpecialClue(event.username);
                    break;
                    
                case 'comment':
                    // Traiter les commentaires pour d√©tecter les mots-cl√©s
                    if (window.tikTokConfig?.enableComments) {
                        handleComment(event.comment, event.username);
                    }
                    break;
                    
                case 'follow':
                    // Ajouter au journal d'exploration
                    addToStoryHistory('event', `${event.username} suit maintenant le stream!`);
                    break;
                    
                case 'share':
                    // R√©compenser le partage avec un petit don virtuel
                    simulateDonation(event.username, 1, 'Partage');
                    
                    // Ajouter au journal d'exploration
                    addToStoryHistory('event', `${event.username} a partag√© le stream!`);
                    break;
                    
                case 'like':
                    // Reconna√Ætre les likes en masse
                    if (event.likeCount && event.likeCount > 5) {
                        // D√©clencher des effets mineurs d'ambiance
                        triggerAmbientEffect(event.likeCount);
                        
                        // Ajouter au journal d'exploration pour les likes importants
                        addToStoryHistory('event', `${event.username} a envoy√© ${event.likeCount} likes!`);
                    }
                    break;
                    
                case 'importantComment':
                    // Traiter les commentaires importants sp√©cifiquement
                    handleImportantComment(event.comment, event.username);
                    break;
                    
                case 'memberJoin':
                    // Membre rejoignant le stream
                    addToStoryHistory('discovery', `${event.username} a rejoint l'exploration!`);
                    break;
            }
        }
        
        // Fonction pour r√©v√©ler un indice sp√©cial aux abonn√©s
        function revealSpecialClue(username) {
            // S√©lectionner un indice pas encore d√©couvert
            const unrevealedClues = STORY_ELEMENTS.clues.filter(clue => !window.discoveredClues.includes(clue.id));
            
            if (unrevealedClues.length > 0) {
                const randomIndex = Math.floor(Math.random() * unrevealedClues.length);
                const clue = unrevealedClues[randomIndex];
                
                // R√©v√©ler un indice pour l'utilisateur
                revealClue(clue.id, username);
                
                // Ajouter un message sp√©cial dans le journal
                addToStoryHistory('discovery', `Indice sp√©cial r√©v√©l√© √† ${username}: "${clue.text}"`);
            }
        }
        
        // Fonction pour g√©rer les commentaires importants
        function handleImportantComment(comment, username) {
            // √âvaluer si le commentaire contient des mots-cl√©s li√©s √† l'histoire
            const storyKeywords = [
                'myst√®re', 'cr√©ature', 'secret', 'porte', 'symbole', 'code', 
                '√©nigme', 'indice', 'lumi√®re', 'ombre', 'profondeur',
                'ab√Æme', 'portail', 'anciens', 'artefact', 'cl√©'
            ];
            
            const lowerComment = comment.toLowerCase();
            const matchedKeywords = storyKeywords.filter(keyword => lowerComment.includes(keyword));
            
            if (matchedKeywords.length >= 2) {
                // Commentaire tr√®s pertinent pour l'histoire
                addToStoryHistory('discovery', `Observation de ${username}: "${comment}"`);
                
                // Potentiellement r√©v√©ler un indice bas√© sur ce commentaire
                if (Math.random() < 0.3) {
                    // 30% de chance de r√©v√©ler un indice
                    setTimeout(() => {
                        revealRandomClue(username);
                    }, 3000 + Math.random() * 5000);
                }
                
                // Pour les commentaires tr√®s pertinents, ajouter un effet visuel subtil
                flashCameraEffect(0.3);
            }
        }
        
        // Fonction pour d√©clencher des effets d'ambiance bas√©s sur l'activit√© TikTok
        function triggerAmbientEffect(intensity) {
            // L'intensit√© repr√©sente combien l'effet doit √™tre prononc√©, bas√© sur les likes/interactions
            intensity = Math.min(intensity / 10, 1.0); // Normaliser entre 0 et 1
            
            // Types d'effets d'ambiance
            const effects = [
                'flicker', // Effet de vacillement des lumi√®res
                'ripple',  // Effet d'ondulation sur l'eau
                'mist',    // Effet de brume temporaire
                'whisper'  // Sons subtils d'ambiance
            ];
            
            // S√©lectionner un effet al√©atoire
            const effect = effects[Math.floor(Math.random() * effects.length)];
            
            // Appliquer l'effet selon le type
            switch (effect) {
                case 'flicker':
                    // Faire vaciller les lumi√®res dans le tunnel
                    flickerLights(intensity);
                    break;
                case 'ripple':
                    // Cr√©er des ondulations sur l'eau
                    createWaterRipple(intensity);
                    break;
                case 'mist':
                    // Ajouter une brume temporaire
                    addTemporaryMist(intensity);
                    break;
                case 'whisper':
                    // Jouer des sons d'ambiance
                    playAmbientSound(intensity);
                    break;
            }
        }
        
        // Faire vaciller les lumi√®res du tunnel
        function flickerLights(intensity) {
            // Trouver toutes les lumi√®res dans la sc√®ne
            const lights = [];
            window.scene.traverse(function(object) {
                if (object.userData && object.userData.light) {
                    lights.push(object.userData.light);
                }
            });
            
            // Aucune lumi√®re trouv√©e
            if (lights.length === 0) return;
            
            // Sauvegarder les intensit√©s d'origine
            const originalIntensities = lights.map(light => light.intensity);
            
            // Nombre de vacillements
            const flickerCount = Math.floor(3 + intensity * 7);
            
            // Fonction pour un vacillement al√©atoire
            function singleFlicker(index) {
                if (index >= flickerCount) {
                    // Restaurer les intensit√©s d'origine
                    lights.forEach((light, i) => { 
                        if (light) light.intensity = originalIntensities[i]; 
                    });
                    return;
                }
                
                // Appliquer un vacillement al√©atoire √† chaque lumi√®re
                lights.forEach((light, i) => {
                    if (light) {
                        const randomFactor = 0.3 + Math.random() * 0.7;
                        light.intensity = originalIntensities[i] * randomFactor;
                    }
                });
                
                // Planifier le prochain vacillement
                setTimeout(() => singleFlicker(index + 1), 50 + Math.random() * 150);
            }
            
            // D√©marrer la s√©quence de vacillement
            singleFlicker(0);
        }
        
        // Cr√©er des ondulations sur l'eau
        function createWaterRipple(intensity) {
            if (!window.waterMesh) return;
            
            // Cr√©er un effet d'ondulation sur l'eau
            const rippleDuration = 2000 + intensity * 3000; // 2-5 secondes selon l'intensit√©
            const startTime = Date.now();
            const originalY = window.waterMesh.position.y;
            
            // Fonction d'animation pour l'ondulation
            function animateRipple() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / rippleDuration;
                
                if (progress >= 1) {
                    // Restaurer la position de l'eau
                    window.waterMesh.position.y = originalY;
                    return;
                }
                
                // Calcul de l'ondulation
                const amplitude = 0.05 * intensity;
                const frequency = 6 + intensity * 4;
                const ripple = amplitude * Math.sin(frequency * progress * Math.PI) * (1 - progress);
                
                // Appliquer l'ondulation
                window.waterMesh.position.y = originalY + ripple;
                
                // Continuer l'animation
                requestAnimationFrame(animateRipple);
            }
            
            // D√©marrer l'animation
            animateRipple();
        }
        
        // Ajouter de la brume temporaire
        function addTemporaryMist(intensity) {
            // V√©rifier si la brume existe d√©j√†
            if (window.mistMesh) return;
            
            // Cr√©er une sph√®re de brume semi-transparente
            const mistGeometry = new THREE.SphereGeometry(10, 16, 16);
            const mistMaterial = new THREE.MeshBasicMaterial({
                color: 0xccccff,
                transparent: true,
                opacity: 0
            });
            
            const mistMesh = new THREE.Mesh(mistGeometry, mistMaterial);
            mistMesh.position.set(window.boat.position.x, 0, window.boat.position.z);
            window.scene.add(mistMesh);
            window.mistMesh = mistMesh;
            
            // Dur√©e de la brume
            const mistDuration = 3000 + intensity * 4000; // 3-7 secondes
            const startTime = Date.now();
            
            // Fonction d'animation pour la brume
            function animateMist() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / mistDuration;
                
                if (progress >= 1) {
                    // Supprimer la brume
                    window.scene.remove(mistMesh);
                    window.mistMesh = null;
                    return;
                }
                
                // Animation de l'opacit√© (apparition puis disparition)
                let opacity;
                if (progress < 0.3) {
                    // Apparition
                    opacity = (progress / 0.3) * 0.3 * intensity;
                } else if (progress > 0.7) {
                    // Disparition
                    opacity = ((1 - progress) / 0.3) * 0.3 * intensity;
                } else {
                    // Plateau
                    opacity = 0.3 * intensity;
                }
                
                // Appliquer l'opacit√©
                mistMaterial.opacity = opacity;
                
                // Continuer l'animation
                requestAnimationFrame(animateMist);
            }
            
            // D√©marrer l'animation
            animateMist();
        }
        
        // Jouer un son d'ambiance
        function playAmbientSound(intensity) {
            // Si le son est d√©sactiv√©, ne rien faire
            if (!window.audioEnabled) return;
            
            // S√©lectionner un son d'ambiance al√©atoire
            const ambientSounds = [
                'whisper', 'creak', 'drip', 'distant_echo'
            ];
            
            const sound = ambientSounds[Math.floor(Math.random() * ambientSounds.length)];
            const volume = 0.1 + intensity * 0.2; // Volume entre 0.1 et 0.3
            
            // Cr√©er un √©l√©ment audio
            const audio = new Audio();
            audio.volume = volume;
            
            // D√©finir la source du son
            switch (sound) {
                case 'whisper':
                    audio.src = 'sounds/whisper.mp3';
                    break;
                case 'creak':
                    audio.src = 'sounds/creak.mp3';
                    break;
                case 'drip':
                    audio.src = 'sounds/drip.mp3';
                    break;
                case 'distant_echo':
                    audio.src = 'sounds/echo.mp3';
                    break;
            }
            
            // Jouer le son
            try {
                audio.play().catch(error => {
                    console.warn('Impossible de jouer le son:', error);
                });
            } catch (error) {
                console.warn('Erreur lors de la lecture du son:', error);
            }
        }
        
        // Configuration du syst√®me de vote
        function setupVoteSystem() {
            // Gestion des clics sur les options de vote
            document.querySelectorAll('.vote-option').forEach(option => {
                option.addEventListener('click', (e) => {
                    const optionIndex = e.currentTarget.getAttribute('data-option');
                    voteForOption(optionIndex);
                });
            });
        }
        
        // ==========================================
        // FONCTIONS DE CR√âATION D'OBJETS 3D
        // ==========================================
        
        // Cr√©er une barque avec un mod√®le Three.js d√©taill√©
        function createBoat() {
            const boat = new THREE.Group();
            
            // Coque principale - forme d'une barque traditionnelle
            const hullShape = new THREE.Shape();
            // D√©finir un contour en forme de barque vue de dessus
            hullShape.moveTo(-0.7, -1.2);
            hullShape.quadraticCurveTo(-0.2, -1.5, 0, -1.5);
            hullShape.quadraticCurveTo(0.2, -1.5, 0.7, -1.2);
            hullShape.quadraticCurveTo(0.9, -0.8, 0.9, 0);
            hullShape.quadraticCurveTo(0.9, 0.8, 0.7, 1.2);
            hullShape.quadraticCurveTo(0.2, 1.5, 0, 1.5);
            hullShape.quadraticCurveTo(-0.2, 1.5, -0.7, 1.2);
            hullShape.quadraticCurveTo(-0.9, 0.8, -0.9, 0);
            hullShape.quadraticCurveTo(-0.9, -0.8, -0.7, -1.2);
            
            // Extruder la forme pour cr√©er la coque 3D
            const extrudeSettings = {
                steps: 2,
                depth: 0.5,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.1,
                bevelOffset: 0,
                bevelSegments: 3
            };
            
            const hullGeometry = new THREE.ExtrudeGeometry(hullShape, extrudeSettings);
            
            // Cr√©er un mat√©riau pour la coque avec texture de bois
            const hullMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.7,
                metalness: 0.2
            });
            
            // Cr√©er un effet de veine de bois (proc√©dural)
            const woodTexture = createWoodTexture();
            hullMaterial.map = woodTexture;
            
            const hull = new THREE.Mesh(hullGeometry, hullMaterial);
            hull.rotation.x = Math.PI / 2; // Orienter correctement la barque
            boat.add(hull);
            
            // Ajouter des bancs transversaux
            const benchMaterial = new THREE.MeshStandardMaterial({
                color: 0x964B00,
                roughness: 0.8,
                metalness: 0.1
            });
            
            // Banc avant
            const frontBenchGeometry = new THREE.BoxGeometry(1.4, 0.1, 0.25);
            const frontBench = new THREE.Mesh(frontBenchGeometry, benchMaterial);
            frontBench.position.set(0, 0.3, 0.9);
            boat.add(frontBench);
            
            // Banc arri√®re
            const backBenchGeometry = new THREE.BoxGeometry(1.4, 0.1, 0.25);
            const backBench = new THREE.Mesh(backBenchGeometry, benchMaterial);
            backBench.position.set(0, 0.3, -0.9);
            boat.add(backBench);
            
            // Banc milieu
            const middleBenchGeometry = new THREE.BoxGeometry(1.4, 0.1, 0.25);
            const middleBench = new THREE.Mesh(middleBenchGeometry, benchMaterial);
            middleBench.position.set(0, 0.3, 0);
            boat.add(middleBench);
            
            // Ajouter une lanterne pour l'ambiance
            const lanternBase = new THREE.CylinderGeometry(0.05, 0.05, 0.2, 8);
            const lanternGlobe = new THREE.SphereGeometry(0.1, 8, 8);
            const lanternMaterial = new THREE.MeshStandardMaterial({
                color: 0x553311,
                roughness: 0.5
            });
            const lanternGlassMaterial = new THREE.MeshStandardMaterial({
                color: 0xffaa55,
                emissive: 0xff6622,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.7
            });
            
            const lanternBaseObj = new THREE.Mesh(lanternBase, lanternMaterial);
            const lanternGlobeObj = new THREE.Mesh(lanternGlobe, lanternGlassMaterial);
            lanternGlobeObj.position.y = 0.15;
            
            const lantern = new THREE.Group();
            lantern.add(lanternBaseObj);
            lantern.add(lanternGlobeObj);
            lantern.position.set(0, 0.4, 0.9);
            boat.add(lantern);
            
            // Ajouter une lumi√®re dans la lanterne
            const lanternLight = new THREE.PointLight(0xff6622, 1, 3);
            lanternLight.position.set(0, 0.15, 0);
            lantern.add(lanternLight);
            
            // Position et √©chelle finale de la barque
            boat.scale.set(0.7, 0.7, 0.7);
            boat.position.y = WATER_LEVEL + 0.4;
            window.scene.add(boat);
            
            // Variables pour l'animation narrative de la barque
            boat.userData = {
                lanternLight: lanternLight,
                lanternOriginalIntensity: 1,
                narrativeState: "normal"
            };
            
            return boat;
        }
        
        // Fonction pour cr√©er une texture de bois
        function createWoodTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            
            // Fond
            context.fillStyle = "#8B4513";
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Veines de bois
            for (let i = 0; i < 30; i++) {
                // Position et √©paisseur variables
                const y = Math.random() * canvas.height;
                const width = 1 + Math.random() * 3;
                
                // Couleur de veine l√©g√®rement variable
                const brightness = 100 + Math.floor(Math.random() * 50);
                const color = `rgb(${brightness}, ${brightness * 0.6}, ${brightness * 0.4})`;
                
                context.beginPath();
                context.moveTo(0, y);
                
                // Cr√©er une ligne ondul√©e
                for (let x = 0; x < canvas.width; x += canvas.width/20) {
                    const newY = y + (Math.random() - 0.5) * 15;
                    context.lineTo(x, newY);
                }
                
                context.strokeStyle = color;
                context.lineWidth = width;
                context.stroke();
            }
            
            // Noeuds du bois
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 3 + Math.random() * 8;
                
                const gradient = context.createRadialGradient(x, y, 1, x, y, radius);
                gradient.addColorStop(0, "#4B2809");
                gradient.addColorStop(1, "#8B4513");
                
                context.beginPath();
                context.arc(x, y, radius, 0, Math.PI * 2);
                context.fillStyle = gradient;
                context.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }
        
        // Cr√©er un segment de tunnel avec rebords et portes
        function createSegment(zPosition) {
            const segment = new THREE.Group();
            segment.position.z = zPosition;
            
            // Tunnel principal
            const tunnelGeometry = new THREE.CylinderGeometry(
                TUNNEL_RADIUS, TUNNEL_RADIUS, TUNNEL_LENGTH, 16, 1, true
            );
            const tunnelMaterial = new THREE.MeshPhongMaterial({
                color: 0x333333, 
                side: THREE.BackSide
            });
            const tunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
            tunnel.rotation.x = Math.PI / 2;
            segment.add(tunnel);
            
            // Sol/eau au centre
            const waterWidth = TUNNEL_RADIUS * 1.2; // R√©duire pour laisser de la place aux rebords
            const floorGeometry = new THREE.PlaneGeometry(
                waterWidth, TUNNEL_LENGTH
            );
            const waterMaterial = new THREE.MeshPhongMaterial({
                color: 0x006666,
                transparent: true,
                opacity: 0.7
            });
            const floor = new THREE.Mesh(floorGeometry, waterMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = WATER_LEVEL;
            segment.add(floor);
            
            // Ajouter un effet de miroitement √† l'eau
            segment.userData.water = floor;
            segment.userData.waterBaseColor = new THREE.Color(0x006666);
            
            // Ajouter des rebords et des portes r√©guli√®rement
            for (let z = 0; z < TUNNEL_LENGTH; z += 5) {
                // Position en z
                const doorZ = z - TUNNEL_LENGTH / 2;
                
                // D√©terminer si cette porte est sp√©ciale (narrative)
                const isSpecialDoor = Math.random() < 0.05 + (window.storyProgress * 0.02);
                
                // Porte gauche
                const leftDoor = createDoor(isSpecialDoor);
                leftDoor.position.set(-TUNNEL_RADIUS + 0.2, WATER_LEVEL + 1.5, doorZ);
                leftDoor.rotation.y = Math.PI/2; // Rotation pour que la porte soit perpendiculaire √† la paroi du tunnel
                leftDoor.rotation.z = 0; // Assurer que la porte est verticale
                segment.add(leftDoor);
                
                if (isSpecialDoor) {
                    registerSpecialDoor(leftDoor);
                }
                
                window.doors.push(leftDoor);
                
                // Porte droite - perpendiculaire √† la paroi et verticale
                const rightDoor = createDoor(isSpecialDoor);
                rightDoor.position.set(TUNNEL_RADIUS - 0.2, WATER_LEVEL + 1.5, doorZ);
                rightDoor.rotation.y = -Math.PI/2; // Rotation pour que la porte soit perpendiculaire √† la paroi du tunnel
                rightDoor.rotation.z = 0; // Assurer que la porte est verticale
                segment.add(rightDoor);
                
                if (isSpecialDoor) {
                    registerSpecialDoor(rightDoor);
                }
                
                window.doors.push(rightDoor);
                
                // Rebords pour marcher (gauche et droite)
                createWalkway(segment, -TUNNEL_RADIUS + 0.6, WATER_LEVEL + 0.1, doorZ - 2.5, 5);
                createWalkway(segment, TUNNEL_RADIUS - 0.6, WATER_LEVEL + 0.1, doorZ - 2.5, 5);
                
                // Lumi√®res murales
                createWallLight(segment, -TUNNEL_RADIUS + 0.1, WATER_LEVEL + 2, doorZ - 1.5);
                createWallLight(segment, TUNNEL_RADIUS - 0.1, WATER_LEVEL + 2, doorZ - 1.5);
            }
            
            // Lumi√®re g√©n√©rale du tunnel (faible)
            const ambientLight = new THREE.PointLight(0x333333, 0.3, TUNNEL_RADIUS * 2);
            ambientLight.position.set(0, 0, 0);
            segment.add(ambientLight);
            
            // Stocker la position et les donn√©es suppl√©mentaires
            segment.userData = { 
                ...segment.userData,
                zPosition: zPosition,
                narrativeZone: determineNarrativeZone(zPosition),
                ambientLight: ambientLight
            };
            
            window.scene.add(segment);
            window.segments.push(segment);
            return segment;
        }
        
        // Cr√©er un rebord pour marcher
        function createWalkway(parent, x, y, z, length) {
            // Plateforme pour marcher
            const walkwayGeometry = new THREE.BoxGeometry(1, 0.2, length);
            const walkwayMaterial = new THREE.MeshPhongMaterial({color: 0x555555});
            const walkway = new THREE.Mesh(walkwayGeometry, walkwayMaterial);
            walkway.position.set(x, y, z + length/2);
            parent.add(walkway);
            
            // Support m√©tallique
            for (let i = 0; i < length; i += 1.5) {
                const supportGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 6);
                const supportMaterial = new THREE.MeshPhongMaterial({color: 0x777777});
                const support = new THREE.Mesh(supportGeometry, supportMaterial);
                support.position.set(x, y - 0.35, z + i);
                parent.add(support);
            }
            
            return walkway;
        }
        
        // Cr√©er une lumi√®re murale
        function createWallLight(parent, x, y, z) {
            // Groupe pour la lumi√®re
            const lightGroup = new THREE.Group();
            lightGroup.position.set(x, y, z);
            
            // Support mural
            const baseGeometry = new THREE.BoxGeometry(0.1, 0.3, 0.3);
            const baseMaterial = new THREE.MeshPhongMaterial({color: 0x333333});
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            
            // Orientation selon le c√¥t√©
            if (x < 0) { // C√¥t√© gauche
                base.rotation.y = 0;
                lightGroup.rotation.y = 0;
            } else { // C√¥t√© droit
                base.rotation.y = Math.PI;
                lightGroup.rotation.y = Math.PI;
            }
            
            lightGroup.add(base);
            
            // Ampoule/Globe
            const bulbGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            
            // La couleur varie en fonction de la progression de l'histoire
            const colorProgress = Math.min(window.storyProgress, 1);
            const bulbColor = new THREE.Color().setHSL(
                0.1 - (colorProgress * 0.1), // De jaune vers rouge
                0.7,
                0.5 + (colorProgress * 0.2) // Devient plus brillant
            );
            
            const bulbMaterial = new THREE.MeshBasicMaterial({
                color: bulbColor
                // emissive et emissiveIntensity sont retir√©s car non support√©s par MeshBasicMaterial
            });
            
            const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
            bulb.position.x = (x < 0) ? 0.1 : -0.1; // Position selon le c√¥t√©
            lightGroup.add(bulb);
            
            // Lumi√®re
            const intensity = 0.5 + Math.random() * 0.5;
            const light = new THREE.PointLight(bulbColor, intensity, 3);
            light.position.copy(bulb.position);
            lightGroup.add(light);
            
            // Ajouter des donn√©es pour les animations
            lightGroup.userData = {
                bulb: bulb,
                light: light,
                originalIntensity: intensity,
                flicker: Math.random() < 0.3, // 30% de chance de scintillement
                flickerSpeed: 0.5 + Math.random() * 2,
                originalColor: bulbColor.clone()
            };
            
            parent.add(lightGroup);
            return lightGroup;
        }
        
        // Cr√©er une porte avec une orientation correcte et th√©matique
        function createDoor(isSpecial = false) {
            const door = new THREE.Group();
            
            // Couleurs diff√©rentes selon le type de porte
            let doorColor, frameColor, detailsColor;
            let doorSymbol = null;
            
            if (isSpecial) {
                // Porte sp√©ciale avec couleur et caract√©ristiques uniques
                const specialType = Math.floor(Math.random() * 5);
                
                switch(specialType) {
                    case 0: // Porte myst√©rieuse avec symboles
                        frameColor = 0x443322;
                        doorColor = 0x221100;
                        detailsColor = 0xaa8866;
                        doorSymbol = "symbol";
                        break;
                    case 1: // Porte rouge sang
                        frameColor = 0x662222;
                        doorColor = 0x990000;
                        detailsColor = 0xaa3333;
                        doorSymbol = "blood";
                        break;
                    case 2: // Porte luminescente
                        frameColor = 0x443355;
                        doorColor = 0x334466;
                        detailsColor = 0x88aaff;
                        doorSymbol = "glow";
                        break;
                    case 3: // Porte m√©tallique rouill√©e
                        frameColor = 0x775533;
                        doorColor = 0x996633;
                        detailsColor = 0xcc8844;
                        doorSymbol = "rust";
                        break;
                    case 4: // Porte avec marques de griffes
                        frameColor = 0x554433;
                        doorColor = 0x443322;
                        detailsColor = 0x333333;
                        doorSymbol = "claw";
                        break;
                }
            } else {
                // Porte standard
                frameColor = 0x553322;
                doorColor = 0x332211;
                detailsColor = 0x888888;
            }
            
            // Cadre de porte
            const frameGeometry = new THREE.BoxGeometry(2, 3, 0.2);
            const frameMaterial = new THREE.MeshPhongMaterial({color: frameColor});
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            door.add(frame);
            
            // La porte elle-m√™me (panneau)
            const doorGeometry = new THREE.BoxGeometry(1.8, 2.8, 0.1);
            const doorMaterial = new THREE.MeshPhongMaterial({color: doorColor});
            const doorMesh = new THREE.Mesh(doorGeometry, doorMaterial);
            // Positionner la porte correctement pour l'animation
            doorMesh.position.z = -0.15; 
            door.add(doorMesh);
            
            // Poign√©e de porte
            const handleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const handleMaterial = new THREE.MeshPhongMaterial({color: detailsColor});
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.set(0.5, 0, -0.15); // √Ä droite de la porte vue de face
            door.add(handle);
            
            // Ajout de num√©ro ou symbole de porte
            const doorNumber = Math.floor(Math.random() * 900) + 100;
            
            // Plaque de num√©ro/symbole
            const plateGeometry = new THREE.PlaneGeometry(0.4, 0.2);
            const plateMaterial = new THREE.MeshPhongMaterial({
                color: detailsColor,
                side: THREE.DoubleSide
            });
            const plate = new THREE.Mesh(plateGeometry, plateMaterial);
            plate.position.set(0, 1, -0.11);
            door.add(plate);
            
            // Ajouter un symbole sp√©cial si c'est une porte sp√©ciale
            if (isSpecial && doorSymbol) {
                // Cr√©er le symbole selon le type
                switch(doorSymbol) {
                    case "symbol":
                        // Ajouter un symbole √©sot√©rique
                        addSymbolToDoor(door, plate);
                        break;
                    case "blood":
                        // Ajouter des taches de sang
                        addBloodToDoor(door, doorMesh);
                        break;
                    case "glow":
                        // Ajouter un effet lumineux
                        addGlowToDoor(door, doorMesh);
                        break;
                    case "rust":
                        // Ajouter des taches de rouille
                        addRustToDoor(door, doorMesh);
                        break;
                    case "claw":
                        // Ajouter des marques de griffes
                        addClawMarksToDoor(door, doorMesh);
                        break;
                }
            }
            
            // Donn√©es pour l'animation et statut narratif
            door.userData = {
                doorMesh: doorMesh,
                animating: false,
                doorNumber: doorNumber,
                isSpecial: isSpecial,
                doorSymbol: doorSymbol,
                activated: false,
                containsClue: isSpecial && (Math.random() < 0.6), // 60% des portes sp√©ciales contiennent un indice
                containsEntity: isSpecial && (Math.random() < 0.3), // 30% des portes sp√©ciales contiennent une entit√©
                entityType: isSpecial ? Math.floor(Math.random() * 7) : null,
                narrativeElement: null
            };
            
            return door;
        }
        
        // Ajouter un symbole √©sot√©rique √† une porte
        function addSymbolToDoor(door, plate) {
            // Cr√©er un canvas pour dessiner le symbole
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Fond transparent
            ctx.fillStyle = 'rgba(0, 0, 0, 0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Choisir un symbole al√©atoire
            const symbolType = Math.floor(Math.random() * 5);
            
            // Dessiner le symbole en blanc
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.fillStyle = 'white';
            
            switch(symbolType) {
                case 0: // Cercle avec triangle
                    ctx.beginPath();
                    ctx.arc(64, 64, 40, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(64, 34);
                    ctx.lineTo(94, 94);
                    ctx.lineTo(34, 94);
                    ctx.closePath();
                    ctx.stroke();
                    break;
                    
                case 1: // Spirale
                    ctx.beginPath();
                    let radius = 5;
                    let angle = 0;
                    let x = 64;
                    let y = 64;
                    
                    for (let i = 0; i < 200; i++) {
                        angle += 0.1;
                        radius += 0.2;
                        const newX = 64 + Math.cos(angle) * radius;
                        const newY = 64 + Math.sin(angle) * radius;
                        ctx.lineTo(newX, newY);
                        x = newX;
                        y = newY;
                        
                        if (radius > 40) break;
                    }
                    ctx.stroke();
                    break;
                    
                case 2: // ≈íil
                    ctx.beginPath();
                    ctx.ellipse(64, 64, 45, 25, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(64, 64, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(64, 39);
                    ctx.lineTo(64, 89);
                    ctx.stroke();
                    break;
                    
                case 3: // Runes
                    for (let i = 0; i < 3; i++) {
                        const startX = 34 + i * 30;
                        ctx.beginPath();
                        
                        // Runes al√©atoires
                        switch(Math.floor(Math.random() * 5)) {
                            case 0: // F-like
                                ctx.moveTo(startX, 44);
                                ctx.lineTo(startX, 94);
                                ctx.moveTo(startX, 44);
                                ctx.lineTo(startX + 20, 44);
                                ctx.moveTo(startX, 69);
                                ctx.lineTo(startX + 15, 69);
                                break;
                            case 1: // X-like
                                ctx.moveTo(startX - 10, 44);
                                ctx.lineTo(startX + 10, 94);
                                ctx.moveTo(startX + 10, 44);
                                ctx.lineTo(startX - 10, 94);
                                break;
                            case 2: // O with line
                                ctx.arc(startX, 69, 25, 0, Math.PI * 2);
                                ctx.moveTo(startX - 25, 69);
                                ctx.lineTo(startX + 25, 69);
                                break;
                            case 3: // Arrow
                                ctx.moveTo(startX, 44);
                                ctx.lineTo(startX, 94);
                                ctx.moveTo(startX - 10, 54);
                                ctx.lineTo(startX, 44);
                                ctx.lineTo(startX + 10, 54);
                                break;
                            case 4: // Wave
                                ctx.moveTo(startX - 15, 69);
                                for (let j = 0; j < 30; j++) {
                                    ctx.lineTo(startX - 15 + j, 69 + Math.sin(j * 0.3) * 15);
                                }
                                break;
                        }
                        
                        ctx.stroke();
                    }
                    break;
                    
                case 4: // Constellation
                    // Points
                    const points = [];
                    for (let i = 0; i < 7; i++) {
                        points.push({
                            x: 30 + Math.random() * 68,
                            y: 30 + Math.random() * 68,
                            r: 2 + Math.random() * 3
                        });
                    }
                    
                    // Dessiner les points
                    points.forEach(point => {
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, point.r, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Relier certains points
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) {
                        if (Math.random() < 0.7) { // 70% de chance de relier deux points
                            ctx.lineTo(points[i].x, points[i].y);
                        } else {
                            ctx.moveTo(points[i].x, points[i].y);
                        }
                    }
                    ctx.stroke();
                    break;
            }
            
            // Cr√©er une texture √† partir du canvas
            const symbolTexture = new THREE.CanvasTexture(canvas);
            
            // Cr√©er un mat√©riau avec cette texture
            const symbolMaterial = new THREE.MeshBasicMaterial({
                map: symbolTexture,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            
            // Remplacer le mat√©riau de la plaque
            plate.material = symbolMaterial;
            
            // Agrandir la plaque pour le symbole
            plate.scale.set(2, 2, 1);
            
            // Stocker les donn√©es pour animation
            door.userData.symbolType = symbolType;
            door.userData.symbolTexture = symbolTexture;
        }
        
        // Ajouter des taches de sang √† une porte
        function addBloodToDoor(door, doorMesh) {
            // Cr√©er un canvas pour dessiner les taches
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Copier la couleur de base de la porte
            ctx.fillStyle = '#990000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner des taches de sang al√©atoires
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 10 + Math.random() * 50;
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, 'rgba(120, 0, 0, 0.9)');
                gradient.addColorStop(0.7, 'rgba(80, 0, 0, 0.6)');
                gradient.addColorStop(1, 'rgba(80, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Dessiner des tra√Æn√©es de sang coulant
            for (let i = 0; i < 5; i++) {
                const startX = Math.random() * canvas.width;
                const startY = Math.random() * (canvas.height / 2); // Commencer dans la moiti√© sup√©rieure
                
                ctx.strokeStyle = 'rgba(100, 0, 0, 0.8)';
                ctx.lineWidth = 3 + Math.random() * 8;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                
                let currentX = startX;
                let currentY = startY;
                
                // Cr√©er une ligne descendante avec zigzags al√©atoires
                const length = 50 + Math.random() * 200;
                for (let j = 0; j < length; j += 10) {
                    currentY += 10;
                    currentX += (Math.random() - 0.5) * 15;
                    
                    // R√©duire progressivement l'√©paisseur de la ligne
                    ctx.lineWidth = Math.max(1, ctx.lineWidth - 0.2);
                    
                    ctx.lineTo(currentX, currentY);
                    
                    if (currentY > canvas.height) break;
                }
                
                ctx.stroke();
            }
            
            // Cr√©er une texture √† partir du canvas
            const bloodTexture = new THREE.CanvasTexture(canvas);
            
            // Appliquer la texture √† la porte
            const bloodMaterial = new THREE.MeshStandardMaterial({
                map: bloodTexture,
                color: 0x990000,
                roughness: 0.7,
                metalness: 0.2
            });
            
            doorMesh.material = bloodMaterial;
        }
        
        // Ajouter un effet lumineux √† une porte
        function addGlowToDoor(door, doorMesh) {
            // Cr√©er un mat√©riau avec √©mission pour l'effet lumineux
            const glowMaterial = new THREE.MeshStandardMaterial({
                color: 0x334466,
                emissive: 0x88aaff,
                emissiveIntensity: 0.5,
                roughness: 0.4,
                metalness: 0.6
            });
            
            doorMesh.material = glowMaterial;
            
            // Ajouter une lumi√®re pour renforcer l'effet
            const glowLight = new THREE.PointLight(0x88aaff, 0.8, 1);
            glowLight.position.set(0, 0, -0.1);
            doorMesh.add(glowLight);
            
            // Stocker la lumi√®re pour l'animation
            door.userData.glowLight = glowLight;
            door.userData.originalIntensity = 0.8;
        }
        
        // Ajouter des taches de rouille √† une porte
        function addRustToDoor(door, doorMesh) {
            // Cr√©er un canvas pour dessiner la rouille
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Couleur de base m√©tallique
            ctx.fillStyle = '#996633';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Ajouter une texture m√©tallique de base
            for (let i = 0; i < 20; i++) {
                ctx.strokeStyle = `rgba(153, 122, 102, ${Math.random() * 0.3})`;
                ctx.lineWidth = 1 + Math.random() * 2;
                
                ctx.beginPath();
                ctx.moveTo(0, Math.random() * canvas.height);
                ctx.lineTo(canvas.width, Math.random() * canvas.height);
                ctx.stroke();
            }
            
            // Ajouter des taches de rouille
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 5 + Math.random() * 40;
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, 'rgba(180, 60, 20, 0.9)');
                gradient.addColorStop(0.6, 'rgba(160, 80, 30, 0.6)');
                gradient.addColorStop(1, 'rgba(153, 102, 51, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Ajouter quelques trous de rouille
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 2 + Math.random() * 6;
                
                ctx.fillStyle = 'rgba(30, 20, 10, 0.8)';
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Ajouter un halo de rouille intense autour du trou
                const holeGradient = ctx.createRadialGradient(x, y, radius, x, y, radius * 3);
                holeGradient.addColorStop(0, 'rgba(180, 60, 20, 0.9)');
                holeGradient.addColorStop(1, 'rgba(180, 60, 20, 0)');
                
                ctx.fillStyle = holeGradient;
                ctx.beginPath();
                ctx.arc(x, y, radius * 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Cr√©er une texture √† partir du canvas
            const rustTexture = new THREE.CanvasTexture(canvas);
            
            // Appliquer la texture √† la porte
            const rustMaterial = new THREE.MeshStandardMaterial({
                map: rustTexture,
                roughness: 0.9,
                metalness: 0.4
            });
            
            doorMesh.material = rustMaterial;
        }
        
        // Ajouter des marques de griffes √† une porte
        function addClawMarksToDoor(door, doorMesh) {
            // Cr√©er un canvas pour dessiner les marques
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Couleur de base de la porte
            ctx.fillStyle = '#443322';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner des marques de griffes
            const clawSets = Math.floor(Math.random() * 3) + 2; // 2-4 sets de griffes
            
            for (let set = 0; set < clawSets; set++) {
                const startX = 50 + Math.random() * (canvas.width - 100);
                const startY = 50 + Math.random() * (canvas.height - 100);
                const angle = Math.random() * Math.PI / 4 - Math.PI / 8; // Angle al√©atoire l√©ger
                const length = 100 + Math.random() * 200;
                
                // 3-5 griffes par set
                const claws = Math.floor(Math.random() * 3) + 3;
                const spacing = 10 + Math.random() * 15;
                
                for (let claw = 0; claw < claws; claw++) {
                    // Calculer le d√©calage perpendiculaire √† l'angle
                    const offsetX = Math.sin(angle) * spacing * (claw - (claws - 1) / 2);
                    const offsetY = -Math.cos(angle) * spacing * (claw - (claws - 1) / 2);
                    
                    ctx.strokeStyle = '#221100';
                    ctx.lineWidth = 3 + Math.random() * 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(startX + offsetX, startY + offsetY);
                    
                    // Ligne principale
                    const endX = startX + Math.cos(angle) * length + offsetX;
                    const endY = startY + Math.sin(angle) * length + offsetY;
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    // Ajouter une ligne plus claire pour montrer le bois expos√©
                    ctx.strokeStyle = 'rgba(200, 150, 100, 0.7)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(startX + offsetX + 1, startY + offsetY + 1);
                    ctx.lineTo(endX + 1, endY + 1);
                    ctx.stroke();
                }
            }
            
            // Cr√©er une texture √† partir du canvas
            const clawTexture = new THREE.CanvasTexture(canvas);
            
            // Appliquer la texture √† la porte
            const clawMaterial = new THREE.MeshStandardMaterial({
                map: clawTexture,
                roughness: 0.8,
                metalness: 0.1
            });
            
            doorMesh.material = clawMaterial;
        }
        
        // D√©terminer la zone narrative en fonction de la position
        function determineNarrativeZone(zPosition) {
            // La progression narrative est d√©termin√©e par la distance parcourue
            // Plus on s'enfonce dans le tunnel, plus l'histoire avance
            const absolutePosition = Math.abs(zPosition);
            
            // Secteurs d√©termin√©s par les paliers de milestone
            if (absolutePosition < 50) return "prologue";
            if (absolutePosition < 150) return "secteur2";
            if (absolutePosition < 300) return "secteur3";
            if (absolutePosition < 500) return "secteur4";
            if (absolutePosition < 800) return "secteur5";
            if (absolutePosition < 1200) return "secteur6";
            if (absolutePosition < 1800) return "secteur7";
            return "finale";
        }
        
        // Enregistrer une porte sp√©ciale
        function registerSpecialDoor(door) {
            const doorId = "door_" + Math.floor(Math.random() * 10000);
            window.specialDoors[doorId] = door;
            door.userData.doorId = doorId;
            
            // Si nous avons des indices non d√©couverts, attribuer l'un d'eux √† cette porte
            const availableClues = STORY_ELEMENTS.clues.filter(
                clue => !window.discoveredClues.includes(clue.id)
            );
            
            if (availableClues.length > 0 && door.userData.containsClue) {
                const randomClue = availableClues[Math.floor(Math.random() * availableClues.length)];
                door.userData.narrativeElement = {
                    type: "clue",
                    data: randomClue
                };
            }
        }
        
        // ==========================================
        // FONCTIONS D'ANIMATION ET INTERACTION
        // ==========================================
        
        // Animer une porte et r√©v√©ler son contenu
        function animateDoor(door) {
            if (!door || door.userData.animating) return;
            
            door.userData.animating = true;
            const doorMesh = door.userData.doorMesh;
            const originalPosition = -0.15; // Position initiale
            
            // Incr√©menter le compteur de portes activ√©es
            window.activatedDoors++;
            
            // Si c'est une porte sp√©ciale, la marquer comme activ√©e
            if (door.userData.isSpecial && !door.userData.activated) {
                door.userData.activated = true;
                
                // R√©v√©ler un indice ou d√©clencher un √©v√©nement narratif si applicable
                if (door.userData.narrativeElement) {
                    handleNarrativeElement(door.userData.narrativeElement);
                }
            }
            
            // Cr√©er ou r√©cup√©rer l'√©l√©ment myst√©rieux derri√®re la porte
            let mysteryElement = null;
            
            if (!door.userData.mysteryElement) {
                // D√©terminer le type d'√©l√©ment myst√©rieux
                const entityType = door.userData.entityType || Math.floor(Math.random() * 7);
                
                // Si la porte est sp√©ciale, plus de chance d'avoir une entit√© complexe
                const mysteryType = door.userData.isSpecial ? 
                    Math.min(6, Math.floor(Math.random() * 8)) : // Favorise les entit√©s 0-6
                    Math.floor(Math.random() * 7); // Distribution uniforme
                
                mysteryElement = createMysteryElement(mysteryType, entityType);
                
                // Positionner l'√©l√©ment derri√®re la porte
                const doorPosition = new THREE.Vector3();
                door.getWorldPosition(doorPosition);
                
                // Ajuster la position en fonction de l'orientation de la porte
                const doorDirection = new THREE.Vector3(0, 0, -1);
                doorDirection.applyQuaternion(door.quaternion);
                
                // Placer l'√©l√©ment derri√®re la porte √† une distance appropri√©e
                mysteryElement.position.copy(doorPosition);
                mysteryElement.position.add(doorDirection.multiplyScalar(1.5));
                
                // Attacher l'√©l√©ment √† la porte
                door.userData.mysteryElement = mysteryElement;
                door.userData.mysteryType = mysteryType;
                
                // Ajouter l'√©l√©ment √† la sc√®ne
                window.scene.add(mysteryElement);
                
                // Stocker dans la liste globale pour les mises √† jour
                window.mysteryElements[mysteryElement.uuid] = mysteryElement;
            } else {
                mysteryElement = door.userData.mysteryElement;
            }
            
            // Animation d'ouverture puis de fermeture
            let openAmount = 0;
            let opening = true;
            let revealSound = false;
            let effectTriggered = false;
            
            const interval = setInterval(() => {
                if (opening) {
                    // Phase d'ouverture
                    openAmount += 0.02;
                    
                    // Jouer un son/effet √† mi-ouverture
                    if (openAmount >= 0.15 && !revealSound) {
                        playMysterySound(door.userData.mysteryType || 0);
                        revealSound = true;
                    }
                    
                    // Limitation de l'ouverture maximale
                    if (openAmount >= 0.3) {
                        opening = false;
                        
                        // D√©clencher un effet sp√©cial une seule fois
                        if (!effectTriggered) {
                            triggerMysteryEffect(door.userData.mysteryType || 0, mysteryElement);
                            effectTriggered = true;
                        }
                    }
                } else {
                    // Phase de fermeture
                    openAmount -= 0.02;
                    
                    // V√©rification fin de fermeture
                    if (openAmount <= 0) {
                        openAmount = 0;
                        clearInterval(interval);
                        door.userData.animating = false;
                        
                        // Ne pas supprimer l'√©l√©ment myst√©rieux pour permettre des interactions continues
                        // avec le m√™me √©l√©ment si la porte est rouverte
                    }
                }
                
                // Appliquer le mouvement de la porte correctement
                doorMesh.position.z = originalPosition - openAmount;
            }, 50);
        }
        
        // Cr√©er un √©l√©ment myst√©rieux
        function createMysteryElement(type, entityVariant = 0) {
            const group = new THREE.Group();
            
            switch (type) {
                case 0: // Yeux brillants
                    const glowingEyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const glowingEyeMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
                    
                    const glowingLeftEye = new THREE.Mesh(glowingEyeGeometry, glowingEyeMaterial);
                    glowingLeftEye.position.x = 0.2;
                    group.add(glowingLeftEye);
                    
                    const glowingRightEye = new THREE.Mesh(glowingEyeGeometry, glowingEyeMaterial);
                    glowingRightEye.position.x = -0.2;
                    group.add(glowingRightEye);
                    
                    // Animation de clignotement
                    group.userData.update = (time) => {
                        const blink = Math.sin(time * 10) > 0.7;
                        glowingLeftEye.visible = glowingRightEye.visible = blink;
                    };
                    break;
                    
                case 1: // Tentacule ondulante
                    const tentacleGeometry = new THREE.CylinderGeometry(0.1, 0.02, 1.5, 8);
                    const tentacleMaterial = new THREE.MeshPhongMaterial({
                        color: 0x660066,
                        specular: 0x555555,
                        shininess: 30
                    });
                    
                    // Cr√©er plusieurs segments pour la tentacule
                    const segments = 5;
                    const tentacleSegments = [];
                    
                    for (let i = 0; i < segments; i++) {
                        const segment = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.1 - (i * 0.02), 0.08 - (i * 0.02), 0.4, 8),
                            tentacleMaterial
                        );
                        segment.position.y = -i * 0.3;
                        if (i > 0) {
                            segment.position.z = 0.1;
                        }
                        
                        if (i > 0) {
                            tentacleSegments[i-1].add(segment);
                        } else {
                            group.add(segment);
                        }
                        
                        tentacleSegments.push(segment);
                    }
                    
                    // Animation d'ondulation
                    group.userData.update = (time) => {
                        tentacleSegments.forEach((segment, index) => {
                            segment.rotation.x = Math.sin(time * 3 + index * 0.5) * 0.3;
                            segment.rotation.z = Math.cos(time * 2 + index * 0.5) * 0.3;
                        });
                    };
                    break;
                    
                case 2: // Silhouette sombre
                    const torsoGeometry = new THREE.BoxGeometry(0.5, 0.8, 0.3);
                    const headGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                    const limbGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
                    
                    const shadowMaterial = new THREE.MeshBasicMaterial({
                        color: 0x000000,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const torso = new THREE.Mesh(torsoGeometry, shadowMaterial);
                    group.add(torso);
                    
                    const head = new THREE.Mesh(headGeometry, shadowMaterial);
                    head.position.y = 0.5;
                    group.add(head);
                    
                    // Membres
                    const arms = [];
                    for (let i = 0; i < 2; i++) {
                        const arm = new THREE.Mesh(limbGeometry, shadowMaterial);
                        arm.position.set(i === 0 ? -0.3 : 0.3, 0.1, 0);
                        arm.rotation.z = i === 0 ? Math.PI/4 : -Math.PI/4;
                        group.add(arm);
                        arms.push(arm);
                    }
                    
                    const legs = [];
                    for (let i = 0; i < 2; i++) {
                        const leg = new THREE.Mesh(limbGeometry, shadowMaterial);
                        leg.position.set(i === 0 ? -0.15 : 0.15, -0.6, 0);
                        group.add(leg);
                        legs.push(leg);
                    }
                    
                    // Animation d'agitation
                    group.userData.update = (time) => {
                        head.rotation.y = Math.sin(time * 2) * 0.5;
                        arms.forEach((arm, index) => {
                            arm.rotation.x = Math.sin(time * 3 + index) * 0.2;
                        });
                        legs.forEach((leg, index) => {
                            leg.rotation.x = Math.sin(time * 2 + index * Math.PI) * 0.1;
                        });
                        
                        group.position.y = Math.sin(time * 2) * 0.05;
                    };
                    break;
                    
                case 3: // Objet flottant lumineux
                    const coreGeometry = new THREE.OctahedronGeometry(0.2, 1);
                    const coreMaterial = new THREE.MeshBasicMaterial({
                        color: 0x88ffff,
                        wireframe: true
                    });
                    
                    const core = new THREE.Mesh(coreGeometry, coreMaterial);
                    group.add(core);
                    
                    // Lumi√®re interne
                    const coreLight = new THREE.PointLight(0x88ffff, 1, 3);
                    core.add(coreLight);
                    
                    // Particules orbitales
                    const particles = [];
                    const particleGeometry = new THREE.SphereGeometry(0.03, 4, 4);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff
                    });
                    
                    for (let i = 0; i < 8; i++) {
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        particle.userData = {
                            orbitRadius: 0.3 + Math.random() * 0.2,
                            orbitSpeed: 0.5 + Math.random() * 2,
                            orbitOffset: Math.random() * Math.PI * 2,
                            elevation: (Math.random() - 0.5) * 0.3
                        };
                        group.add(particle);
                        particles.push(particle);
                    }
                    
                    // Animation d'orbite
                    group.userData.update = (time) => {
                        core.rotation.x = time * 0.5;
                        core.rotation.y = time * 0.8;
                        
                        particles.forEach(particle => {
                            const orbit = particle.userData;
                            particle.position.x = Math.cos(time * orbit.orbitSpeed + orbit.orbitOffset) * orbit.orbitRadius;
                            particle.position.z = Math.sin(time * orbit.orbitSpeed + orbit.orbitOffset) * orbit.orbitRadius;
                            particle.position.y = orbit.elevation + Math.sin(time * 2) * 0.1;
                        });
                        
                        coreLight.intensity = 0.7 + Math.sin(time * 5) * 0.3;
                    };
                    break;
                    
                case 4: // Visage fantomatique
                    const faceGeometry = new THREE.PlaneGeometry(0.6, 0.8);
                    
                    // Cr√©er une texture dynamique pour le visage
                    const canvas = document.createElement('canvas');
                    canvas.width = 256;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    
                    // Fond transparent
                    ctx.fillStyle = 'rgba(0, 0, 0, 0)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Dessiner un visage de base
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(128, 120, 90, 120, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Yeux
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.ellipse(90, 100, 20, 25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.ellipse(166, 100, 20, 25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bouche
                    ctx.beginPath();
                    ctx.ellipse(128, 160, 40, 20, 0, 0, Math.PI);
                    ctx.fill();
                    
                    const faceTexture = new THREE.CanvasTexture(canvas);
                    const faceMaterial = new THREE.MeshBasicMaterial({
                        map: faceTexture,
                        transparent: true,
                        opacity: 0.7,
                        side: THREE.DoubleSide
                    });
                    
                    const face = new THREE.Mesh(faceGeometry, faceMaterial);
                    group.add(face);
                    
                    // Animation du visage
                    group.userData.canvas = canvas;
                    group.userData.texture = faceTexture;
                    group.userData.context = ctx;
                    
                    group.userData.update = (time) => {
                        const ctx = group.userData.context;
                        const canvas = group.userData.canvas;
                        
                        // Effacer et redessiner
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Visage de base
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.beginPath();
                        ctx.ellipse(128, 120, 90, 120, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Yeux anim√©s
                        const eyeScaleY = Math.max(0.1, Math.sin(time * 4) * 0.5 + 0.5);
                        
                        ctx.fillStyle = '#000000';
                        ctx.beginPath();
                        ctx.ellipse(90, 100, 20, 25 * eyeScaleY, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.ellipse(166, 100, 20, 25 * eyeScaleY, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Bouche anim√©e
                        const mouthOpen = 0.3 + Math.sin(time * 2) * 0.2;
                        ctx.beginPath();
                        ctx.ellipse(128, 160, 40, 20 * mouthOpen, 0, 0, Math.PI);
                        ctx.fill();
                        
                        // Mettre √† jour la texture
                        group.userData.texture.needsUpdate = true;
                        
                        // Mouvement flottant
                        group.position.y = Math.sin(time * 1.5) * 0.1;
                        face.rotation.y = Math.sin(time) * 0.2;
                    };
                    break;
                    
                case 5: // Portail √©nerg√©tique
                    const ringGeometry = new THREE.TorusGeometry(0.3, 0.03, 16, 32);
                    const ringMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffaa00,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    group.add(ring);
                    
                    // Ajouter des anneaux suppl√©mentaires
                    const rings = [ring];
                    for (let i = 1; i < 3; i++) {
                        const newRing = new THREE.Mesh(
                            new THREE.TorusGeometry(0.3, 0.02, 16, 32),
                            new THREE.MeshBasicMaterial({
                                color: 0xffaa00,
                                transparent: true,
                                opacity: 0.5 - (i * 0.1)
                            })
                        );
                        rings.push(newRing);
                        group.add(newRing);
                    }
                    
                    // Centre du portail
                    const centerGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                    const centerMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.5
                    });
                    
                    const center = new THREE.Mesh(centerGeometry, centerMaterial);
                    group.add(center);
                    
                    // Lumi√®re du portail
                    const portalLight = new THREE.PointLight(0xffaa00, 1, 3);
                    group.add(portalLight);
                    
                    // Animation du portail
                    group.userData.update = (time) => {
                        rings.forEach((ring, i) => {
                            ring.rotation.x = time * (1 + i * 0.2);
                            ring.rotation.y = time * (0.5 + i * 0.1);
                            
                            const scalePulse = 1 + Math.sin(time * (3 + i)) * 0.1;
                            ring.scale.set(scalePulse, scalePulse, 1);
                        });
                        
                        center.scale.setScalar(0.8 + Math.sin(time * 4) * 0.2);
                        portalLight.intensity = 0.7 + Math.sin(time * 5) * 0.3;
                    };
                    break;
                    
                case 6: // Cr√©ature obscure
                    // Remplacer CapsuleGeometry (non disponible en r128) par une combinaison de cylindre et sph√®res
                    const body = new THREE.Group();
                    
                    // Cylindre pour le corps
                    const bodyMainGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 12);
                    const bodyMaterial = new THREE.MeshPhongMaterial({
                        color: 0x330000,
                        specular: 0x111111,
                        shininess: 50
                    });
                    const bodyMain = new THREE.Mesh(bodyMainGeometry, bodyMaterial);
                    body.add(bodyMain);
                    
                    // Sph√®res pour arrondir les extr√©mit√©s (effet capsule)
                    const topSphereGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                    const topSphere = new THREE.Mesh(topSphereGeometry, bodyMaterial);
                    topSphere.position.y = 0.2;
                    body.add(topSphere);
                    
                    const bottomSphereGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                    const bottomSphere = new THREE.Mesh(bottomSphereGeometry, bodyMaterial);
                    bottomSphere.position.y = -0.2;
                    body.add(bottomSphere);
                    
                    group.add(body);
                    
                    // Membres
                    const limbs = [];
                    const limbMaterial = new THREE.MeshPhongMaterial({
                        color: 0x220000,
                        specular: 0x111111,
                        shininess: 30
                    });
                    
                    for (let i = 0; i < 6; i++) {
                        const limbGeometry = new THREE.CylinderGeometry(0.03, 0.01, 0.5, 5);
                        const limb = new THREE.Mesh(limbGeometry, limbMaterial);
                        
                        const angle = (i / 6) * Math.PI * 2;
                        limb.position.set(
                            Math.cos(angle) * 0.2,
                            0,
                            Math.sin(angle) * 0.2
                        );
                        
                        limb.rotation.x = Math.PI / 2;
                        limb.rotation.z = angle;
                        
                        body.add(limb);
                        limbs.push(limb);
                    }
                    
                    // Yeux
                    const creatureEyeGeometry = new THREE.SphereGeometry(0.03, 8, 8);
                    const creatureEyeMaterial = new THREE.MeshBasicMaterial({
                        color: 0xff0000
                    });
                    
                    const creatureLeftEye = new THREE.Mesh(creatureEyeGeometry, creatureEyeMaterial);
                    creatureLeftEye.position.set(0.1, 0.2, 0.15);
                    body.add(creatureLeftEye);
                    
                    const creatureRightEye = new THREE.Mesh(creatureEyeGeometry, creatureEyeMaterial);
                    creatureRightEye.position.set(-0.1, 0.2, 0.15);
                    body.add(creatureRightEye);
                    
                    // Animation de la cr√©ature
                    group.userData.update = (time) => {
                        body.rotation.y = Math.sin(time) * 0.3;
                        
                        limbs.forEach((limb, i) => {
                            limb.rotation.x = Math.PI/2 + Math.sin(time * 3 + i) * 0.3;
                        });
                        
                        creatureLeftEye.scale.setScalar(0.8 + Math.sin(time * 5) * 0.2);
                        creatureRightEye.scale.setScalar(0.8 + Math.sin(time * 5 + 1) * 0.2);
                    };
                    break;
            }
            
            // Personnaliser l'entit√© selon sa variante
            customizeEntityByVariant(group, entityVariant);
            
            return group;
        }
        
        // Personnaliser l'entit√© en fonction de sa variante (pour la diversit√©)
        function customizeEntityByVariant(entity, variant) {
            // Appliquer des modifications selon le type de variante
            switch(variant) {
                case 1: // Variante plus grande
                    entity.scale.set(1.3, 1.3, 1.3);
                    break;
                case 2: // Variante color√©e diff√©remment
                    entity.traverse(child => {
                        if (child.isMesh && child.material) {
                            // Changer la teinte
                            if (child.material.color) {
                                const color = child.material.color;
                                color.setHSL((color.getHSL({}).h + 0.2) % 1, color.getHSL({}).s, color.getHSL({}).l);
                            }
                        }
                    });
                    break;
                case 3: // Variante d√©form√©e
                    entity.rotation.set(Math.PI/6, 0, Math.PI/8);
                    entity.scale.set(0.9, 1.2, 0.9);
                    break;
                case 4: // Variante avec lueur
                    const glow = new THREE.PointLight(0xaaccff, 0.5, 2);
                    entity.add(glow);
                    break;
                case 5: // Variante multiple (clones)
                    for (let i = 0; i < 2; i++) {
                        const clone = entity.clone();
                        clone.position.set(
                            (Math.random() - 0.5) * 0.5,
                            (Math.random() - 0.5) * 0.5,
                            (Math.random() - 0.5) * 0.5
                        );
                        clone.scale.set(0.7, 0.7, 0.7);
                        entity.add(clone);
                    }
                    break;
                case 6: // Variante plus angoissante/agressive
                    // Augmenter la vitesse d'animation
                    const originalUpdate = entity.userData.update;
                    if (originalUpdate) {
                        entity.userData.update = (time) => {
                            originalUpdate(time * 1.5); // Animation plus rapide
                        };
                    }
                    break;
                // Cas par d√©faut: aucune modification
            }
        }
        
        // Jouer un son myst√©rieux (simulation)
        function playMysterySound(type) {
            // Ici, on ne fait que simuler le son avec console.log
            // Dans une application r√©elle, vous utiliseriez l'API Web Audio
            const sounds = [
                "Chuchotements inqui√©tants",
                "Crissement humide",
                "Respiration profonde",
                "Bourdonnement √©lectrique",
                "G√©missement spectral",
                "Vrombissement √©nerg√©tique",
                "Grognement mena√ßant"
            ];
            
            console.log(`Son: ${sounds[Math.min(type, sounds.length - 1)]}`);
            
            // D√©clencher un √©v√©nement al√©atoire bas√© sur la progression narrative
            if (Math.random() < window.storyProgress * 0.05) {
                setTimeout(() => {
                    console.log("√âv√©nement sonore sp√©cial d√©clench√©!");
                    // Effet suppl√©mentaire possible ici
                }, 1000 + Math.random() * 2000);
            }
        }
        
        // D√©clencher un effet sp√©cial selon le type d'√©l√©ment myst√©rieux
        function triggerMysteryEffect(type, element) {
            // Effets vari√©s selon le type
            switch(type) {
                case 0: // Yeux - Flash rapide de lumi√®re rouge
                    flashLightEffect(0xff0000);
                    break;
                case 1: // Tentacule - Secousse de cam√©ra
                    cameraShakeEffect(0.5);
                    break;
                case 2: // Silhouette - Assombrissement temporaire
                    darkenEffect(1.5);
                    break;
                case 3: // Objet flottant - Pulse lumineux
                    pulseLightEffect(0x88ffff, 3);
                    break;
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TikTok Horror Experience - Saison 1: Les Profondeurs</title>
    <link rel="stylesheet" href="responsive.css">
    <link rel="stylesheet" href="auth_gauge.css">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
        
        #loading { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: #000; 
            color: #fff; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            z-index: 1000;
        }
        
        #debug {
            position: fixed; 
            top: 10px; 
            left: 10px; 
            z-index: 10;
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px;
            border-radius: 5px;
        }
        
        #donation-panel {
            position: fixed;
            right: 10px;
            top: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 180px;
            font-size: 11px;
            display: none; /* Hide donation panel as requested */
        }
        
        #donation-panel h3 {
            margin-top: 0;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 40px; /* D√©plac√© plus bas pour √©viter le chevauchement */
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            max-width: 400px;
            z-index: 900;
        }
        
        .progress-bar {
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            margin-bottom: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9900);
            width: 0%;
            transition: width 1s ease-in-out;
        }
        
        #story-milestone {
            position: fixed;
            top: 80px; /* D√©plac√© encore plus bas */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 12px;
            z-index: 900;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
            padding: 5px 10px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            width: 40%;
            max-width: 400px;
            line-height: 1.3;
            display: none; /* Cach√© par d√©faut, sera affich√© dans le journal uniquement */
        }
        
        #donor-wall {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* Align√© avec le journal d'exploration */
            max-height: 130px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Cach√© car remplac√© par top100 */
        }
        
        #top100-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* En bas de l'√©cran, directement sous le journal */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px;
            max-height: 150px;
            overflow: hidden;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Cach√© car remplac√© par leaderboard-panel */
        }
        
        #top100-panel h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 13px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .top100-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
            position: relative;
        }
        
        .top100-rank {
            width: 20px;
            text-align: center;
            color: #aaa;
        }
        
        .top100-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .top100-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #narrative-display {
            position: fixed;
            top: 50%; /* Centr√© verticalement */
            left: 50%;
            transform: translate(-50%, -50%); /* Centrage parfait */
            z-index: 950;
            color: white;
            text-align: center;
            width: 70%;
            max-width: 600px;
            text-shadow: 0 0 3px black, 0 0 5px black;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Fond plus opaque pour meilleure lisibilit√© */
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none; /* Pour √©viter d'interf√©rer avec les clics */
        }
        
        #narrative-display.visible {
            opacity: 0.95;
        }
        
        #clue-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 950;
            color: #ffcc00;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 3px solid #ffcc00;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease-out;
        }
        
        #clue-notification.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #event-counter {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            color: white;
            font-size: 120px;
            text-shadow: 0 0 20px red;
            opacity: 0;
            transition: all 0.3s ease-in-out;
            pointer-events: none;
        }
        
        #event-counter.visible {
            opacity: 1;
        }
        
        button, input { 
            margin: 5px 0; 
            display: block;
            border: none;
            background: #444;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #666;
        }
        
        #sim-donation {
            margin-top: 15px;
            width: 100%;
        }
        
        #vote-panel {
            position: fixed;
            right: 10px;
            bottom: 10px; /* En bas √† droite */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 160px;
            font-size: 10px;
            display: none;
        }
        
        .vote-option {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .vote-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .vote-bar {
            height: 5px;
            width: 100%;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .vote-fill {
            height: 100%;
            background: linear-gradient(90deg, #77ccff, #4488ff);
            width: 30%;
        }
        
        /* Animation pour les effects */
        @keyframes pulse {
            0% { opacity: 0.2; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.2; transform: scale(0.95); }
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        #leaderboard-panel {
            position: fixed;
            left: 10px;
            bottom: 10px; /* Repositionn√© en bas sous le journal */
            top: auto; /* Annule la position top pr√©c√©dente */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px;
            border-radius: 8px;
            width: 200px;
            max-height: 145px; /* Hauteur r√©duite pour √©viter le chevauchement (√©tait √† 150px) */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #leaderboard-panel h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
            border-bottom: 1px dotted #333;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #aaa;
            width: 20px;
            text-align: center;
        }
        
        .leaderboard-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 5px;
        }
        
        .leaderboard-score {
            color: #ffcc00;
            font-weight: bold;
            text-align: right;
        }
        
        #story-history-panel {
            position: fixed;
            left: 10px;
            bottom: 175px; /* Remont√© plus haut pour √©viter le chevauchement (√©tait √† 70px) */
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            width: 200px; /* √âlargi pour mieux afficher les messages */
            max-height: 180px; /* L√©g√®rement plus grand */
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #story-history-panel h3 {
            margin-top: 0;
            margin-bottom: 3px;
            font-size: 12px;
            text-align: center;
            color: #ffcc00;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        .history-item {
            margin-bottom: 4px;
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .history-item-milestone {
            background-color: rgba(255, 204, 0, 0.2);
            border-left: 2px solid #ffcc00;
        }
        
        .history-item-discovery {
            background-color: rgba(119, 204, 255, 0.2);
            border-left: 2px solid #77ccff;
        }
        
        .history-item-event {
            background-color: rgba(255, 102, 102, 0.2);
            border-left: 2px solid #ff6666;
        }
        
        .history-timestamp {
            color: #aaa;
            font-size: 8px;
            margin-bottom: 2px;
            font-style: italic;
        }
        
        /* Style pour r√©server l'espace pour la cam√©ra */
        .camera-space {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 100px;
            z-index: 800;
            /* Background comment√© - juste pour visualiser l'espace r√©serv√© 
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            */
        }
        
        /* Assurons-nous que tous les panneaux ont une apparence coh√©rente */
        #leaderboard-panel, #story-history-panel, #vote-panel, #donor-wall {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.85; /* L√©g√®rement transparent pour voir le bateau derri√®re */
        }
        
        /* Animation de d√©filement automatique pour les panneaux */
        @keyframes autoscroll {
            0% { transform: translateY(0); }
            45% { transform: translateY(calc(-100% + 100px)); }
            55% { transform: translateY(calc(-100% + 100px)); } /* Pause au bas pendant 10% de l'animation */
            57% { transform: translateY(0); } /* Retour tr√®s rapide au d√©but (2% de l'animation) */
            100% { transform: translateY(0); } /* Pause au d√©but avant de recommencer */
        }
        
        .autoscroll-container {
            height: 100%;
            overflow: hidden;
            position: relative;
            max-height: inherit;
        }
        
        .autoscroll-content {
            animation: autoscroll 60s linear infinite; /* Remis √† "infinite" pour boucler */
            animation-play-state: running;
            padding-bottom: 20px; /* Add space at the bottom before repeating */
        }
        
        .autoscroll-content:hover {
            animation-play-state: paused;
        }
        
        /* Objectifs sur la barre en haut */
        #objectives-panel {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 900;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            display: flex;
            gap: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .objective {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .objective-icon {
            color: #ffcc00;
            font-size: 14px;
        }
        
        .objective-text {
            white-space: nowrap;
        }
        
        /* 
        Organisation des panneaux :
        - Haut: Objectifs
        - Droite: Progression narrative 
        - √Ä gauche milieu: Journal d'exploration
        - √Ä gauche bas: Classement des explorateurs
        - En bas √† droite: Panneau de vote
        - Centre haut (ajust√©): Barre de progression
        - Centre bas: Affichage narratif
        */
        
        /* Hover effect pour rendre les panneaux plus lisibles au survol */
        #leaderboard-panel:hover, #story-history-panel:hover, #donation-panel:hover, #vote-panel:hover, #donor-wall:hover {
            opacity: 0.95;
            z-index: 950; /* Augmente le z-index au survol pour s'assurer qu'il est au-dessus des autres */
        }
        
        /* Style pour les titres des panneaux */
        #leaderboard-panel h3, #story-history-panel h3, #donor-wall h4 {
            color: #ffcc00;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        #details-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 950;
            background: rgba(0,0,0,0.7);
            color: #ffcc00;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid rgba(255, 204, 0, 0.3);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            display: none; /* Cacher le bouton des d√©tails d'exploration */
        }
        
        #details-button:hover {
            background: rgba(50,50,0,0.7);
            border-color: rgba(255, 204, 0, 0.6);
        }
        
        /* Overlay d'authentification */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #33ff33;
            font-family: 'Courier New', monospace;
        }
        
        .auth-content {
            text-align: center;
            max-width: 500px;
            padding: 20px;
        }
        
        .auth-logo {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
        }
        
        .auth-message {
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        .auth-warning {
            color: #ff3333;
            margin-top: 20px;
            font-size: 12px;
            max-width: 80%;
            text-align: justify;
        }
        
        .donation-progress-container {
            width: 300px;
            margin: 0 auto;
        }
        
        .donation-label {
            color: #fff;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .donation-bar {
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #ff3366;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        #auth-donation-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff3366, #ff6699);
            transition: width 0.5s ease-in-out;
        }
        
        .auth-gauge {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .auth-gauge h3 {
            margin-top: 0;
            font-size: 14px;
            color: #ffcc00;
        }
        
        .tiktok-integration-notice {
            font-size: 12px;
            color: #ccc;
        }
        
        /* Notifications d'authentification */
        .auth-notification {
            position: fixed;
            right: -300px;
            top: 100px;
            background: linear-gradient(90deg, #330033, #5a0057);
            border-left: 3px solid #ff3366;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            padding: 15px;
            width: 250px;
            border-radius: 5px 0 0 5px;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .auth-notification.show {
            right: 0;
        }
        
        .auth-username {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .auth-amount {
            color: #ff3366;
            font-weight: bold;
            font-size: 18px;
        }
        
        /* Statut du syst√®me */
        .system-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #33ff33;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #ff3333;
        }
        
        .status-indicator.online {
            background-color: #33ff33;
        }
        
        /* Animation de pulsation pour la jauge */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .auth-gauge.pulse {
            animation: pulse 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
    <!-- Inclure les fichiers externes pour la gestion de l'authentification -->
    <script src="auth_gauge.js"></script>
    <script>
        /**
         * Gestion de la jauge d'authentification du syst√®me
         */
        
        // Configuration
        const REQUIRED_AMOUNT = 10; // Montant requis pour d√©bloquer l'acc√®s (en unit√©s)
        let totalProgress = 0; // Variable globale pour suivre la progression
        
        /**
         * Initialisation de la jauge d'authentification
         */
        function initAuthGauge() {
            console.log("Initialisation de la jauge d'authentification");
            
            // R√©cup√©rer les √©l√©ments pour v√©rifier qu'ils existent
            const fillBar = document.getElementById('auth-donation-fill');
            const percentText = document.getElementById('auth-donation-percent');
            
            if (fillBar) {
                console.log("√âl√©ment 'auth-donation-fill' trouv√©");
            } else {
                console.error("√âl√©ment 'auth-donation-fill' introuvable");
            }
            
            if (percentText) {
                console.log("√âl√©ment 'auth-donation-percent' trouv√©");
            } else {
                console.error("√âl√©ment 'auth-donation-percent' introuvable");
            }
            
            // Mettre √† jour l'affichage initial
            updateAuthGauge(0);
            
            // √âcouter les messages d'authentification externes
            window.addEventListener('message', function(event) {
                console.log("Message re√ßu:", event.data);
                // V√©rifier si le message contient des donn√©es d'authentification
                if (event.data && event.data.type === 'auth_progress') {
                    processAuthProgress(event.data.data);
                }
            });
        
            // V√©rifier la progression √† intervalles r√©guliers
            setInterval(checkAuthProgress, 5000);
            
            // Faire une v√©rification imm√©diate
            setTimeout(checkAuthProgress, 1000);
        }
        
        /**
         * Mise √† jour visuelle de la jauge d'authentification
         */
        function updateAuthGauge(amount) {
            console.log("Mise √† jour de la jauge d'authentification avec:", amount);
            
            // Obtenir les √©l√©ments de la jauge
            const fillBar = document.getElementById('auth-donation-fill');
            const percentText = document.getElementById('auth-donation-percent');
            
            // Calculer le pourcentage de progression
            const percentage = Math.min((amount / REQUIRED_AMOUNT) * 100, 100);
            console.log("Pourcentage calcul√©:", percentage);
            
            if (fillBar) {
                console.log("Mise √† jour de la barre de remplissage");
                // Mettre √† jour la barre de progression
                fillBar.style.width = percentage + '%';
            } else {
                console.error("√âl√©ment 'auth-donation-fill' introuvable");
            }
            
            if (percentText) {
                console.log("Mise √† jour du texte de pourcentage");
                // Mettre √† jour le texte du pourcentage
                percentText.textContent = Math.floor(percentage) + '%';
            } else {
                console.error("√âl√©ment 'auth-donation-percent' introuvable");
            }
            
            // V√©rifier si le seuil est atteint pour d√©bloquer
            if (amount >= REQUIRED_AMOUNT) {
                unlockAuthScreen();
            }
        }
        
        /**
         * Traitement d'une progression d'authentification
         */
        function processAuthProgress(progressData) {
            console.log("Traitement des donn√©es de progression:", progressData);
            
            // V√©rifier que les donn√©es contiennent les informations n√©cessaires
            if (progressData && progressData.username && progressData.amount) {
                // Convertir le montant en unit√©s si n√©cessaire
                const amount = parseFloat(progressData.amount);
                if (isNaN(amount)) {
                    console.error("Montant invalide:", progressData.amount);
                    return;
                }
        
                console.log("Ajout de", amount, "au total");
                // Mettre √† jour le total
                totalProgress += amount;
                
                // Mettre √† jour l'affichage
                updateAuthGauge(totalProgress);
                
                // Afficher une notification
                showAuthNotification(progressData.username, amount);
            } else {
                console.error("Donn√©es de progression incompl√®tes:", progressData);
            }
        }
        
        /**
         * Affichage d'une notification pour une progression d'authentification
         */
        function showAuthNotification(username, amount) {
            // Cr√©er un √©l√©ment de notification
            const notification = document.createElement('div');
            notification.className = 'auth-notification';
            notification.innerHTML = `
                <span class="auth-username">${username}</span>
                <span class="auth-amount">+${amount.toFixed(2)} unit√©s</span>
            `;
            
            // Ajouter la notification au DOM
            document.body.appendChild(notification);
            
            // Animer la notification
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);
            
            // Supprimer la notification apr√®s un d√©lai
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 500);
            }, 5000);
        }
        
        /**
         * V√©rification de la progression d'authentification √† intervalles r√©guliers
         */
        function checkAuthProgress() {
            console.log("V√©rification de la progression locale");
            
            // Utiliser une m√©thode alternative pour lire le fichier local
            fetch('/latest_auth_progress.json')
                .then(response => {
                    console.log("R√©ponse du serveur pour le fichier local:", response.status);
                    if (!response.ok) {
                        throw new Error('Fichier non disponible');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log("Donn√©es locales r√©cup√©r√©es:", data);
                    if (data && data.username && data.amount) {
                        // Traiter le don local
                        processAuthProgress(data);
                        // R√©initialiser le fichier pour √©viter de traiter le m√™me don plusieurs fois
                        resetLocalAuthProgress();
                    } else if (Object.keys(data).length === 0) {
                        console.log("Fichier local vide, pas de nouvelle progression");
                    } else {
                        console.error("Fichier local incomplet:", data);
                    }
                })
                .catch(error => {
                    // Silencieux en cas d'erreur - le fichier n'existe peut-√™tre pas encore
                    console.log('Pas de nouveau progr√®s d\'authentification local:', error.message);
                });
        }
        
        /**
         * R√©initialise le fichier de progression locale apr√®s traitement
         */
        function resetLocalAuthProgress() {
            // Appel au serveur pour r√©initialiser le fichier
            fetch('/api/reset-auth-progress', {
                method: 'POST'
            }).catch(error => {
                console.error('Erreur lors de la r√©initialisation de la progression:', error);
            });
        }
        
        /**
         * D√©bloque l'√©cran d'authentification quand le seuil est atteint
         */
        function unlockAuthScreen() {
            const authOverlay = document.getElementById('auth-overlay');
            if (authOverlay && authOverlay.style.display !== 'none') {
                // Animation de disparition
                authOverlay.style.opacity = '0';
                setTimeout(() => {
                    authOverlay.style.display = 'none';
                    // Masquer l'√©cran de chargement pour afficher l'exp√©rience 3D
                    const loadingScreen = document.getElementById('loading');
                    if (loadingScreen) {
                        loadingScreen.style.display = 'none';
                    }
                    
                    // Initialiser le jeu apr√®s l'authentification
                    if (typeof initializeAfterAuth === 'function') {
                        initializeAfterAuth();
                    } else {
                        // Initialiser ou afficher l'exp√©rience du bateau si elle est d√©j√† charg√©e
                        if (window.scene && window.camera && window.renderer) {
                            console.log("Exp√©rience 3D d√©j√† charg√©e, activation");
                            // Ajouter ici tout code n√©cessaire pour d√©marrer l'animation du bateau
                        } else {
                            console.log("Initialisation de l'exp√©rience 3D");
                            // Initialiser la sc√®ne Three.js si pas encore fait
                            initScene();
                        }
                    }
                }, 1000);
                
                console.log("Authentification r√©ussie, acc√®s d√©bloqu√©");
            }
        }
        
        // Initialiser la jauge d'authentification au chargement de la page
        document.addEventListener('DOMContentLoaded', initAuthGauge);
    </script>
</head>
<body>
    <!-- Overlay d'authentification -->
    <div class="auth-overlay" id="auth-overlay">
        <div class="auth-content">
            <div class="auth-logo">THE-DEPTHS v3.6.7</div>
            <div class="auth-message">
                AVERTISSEMENT: Vous √™tes sur le point d'acc√©der √† un r√©seau non autoris√©.<br><br>
                Ce terminal sert d'interface aux communications internes du groupe THE-DEPTHS.<br>
                Toute intrusion non autoris√©e sera trac√©e et signal√©e aux administrateurs.<br><br>
                Cet acc√®s est seulement destin√© aux membres confirm√©s.
            </div>
            
            <div class="auth-gauge">
                <h3 style="text-align: center;">Progression vers l'authentification</h3>
                <div class="donation-progress-container">
                    <div class="donation-label" style="text-align: center; display: block; width: 100%;">Progression : <span id="auth-donation-percent">0%</span></div>
                    <div class="donation-bar">
                        <div id="auth-donation-fill" style="width: 0%;"></div>
                    </div>
                </div>
                <div class="tiktok-integration-notice" style="text-align: center; width: 100%;">
                    Connexion aux syst√®mes de s√©curit√© en cours...
                </div>
            </div>
            
            <div style="text-align: center; width: 100%;">
                <button id="auth-accept" style="background: #111; color: #777; border: 1px solid #666; padding: 10px 20px; cursor: not-allowed; margin-top: 20px; opacity: 0.6; display: inline-block;">
                    AUTHENTIFICATION VERROUILL√âE
            </button>
            </div>
            
            <div class="auth-warning">
                SYST√àME DE S√âCURIT√â: L'acc√®s √† cette interface est strictement contr√¥l√©. Une authentification externe est n√©cessaire pour d√©bloquer le terminal.
            </div>
        </div>
    </div>
    
    <!-- Indicateur de statut du syst√®me -->
    <div class="system-status" id="system-status">
        <div class="status-indicator" id="status-light"></div>
        <span id="status-text">SYST√àME HORS LIGNE</span>
    </div>
    
    <div id="loading">
        <h2>Exploration des Profondeurs</h2>
            <div style="width: 200px; height: 20px; background: #333; border-radius: 10px; overflow: hidden; margin: 20px 0;">
                <div id="load-progress" style="width: 0%; height: 100%; background: linear-gradient(90deg, #ff0066, #ffcc00);"></div>
            </div>
            <div>Chargement de l'exp√©rience...</div>
    </div>
    
    <div id="details-button" onclick="window.open('exploration_details.html', '_blank')">
        <span>üìä</span>
        <span>D√©tails d'Exploration</span>
    </div>
    
    <div id="progress-display">
        <div style="display: flex; justify-content: space-between;">
            <span>PROGRESSION: </span>
            <span id="progress-percent">0%</span>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="story-progress"></div>
        </div>
        <div style="display: flex; justify-content: space-between;">
            <span>D√âBUT</span>
            <span>FIN</span>
        </div>
        <div style="text-align: center; font-size: 10px; color: #ffcc00; margin-top: 3px; text-shadow: 0 0 2px #000;">
            Votre participation stabilise la connexion et r√©v√®le de nouveaux myst√®res
        </div>
    </div>
    
    <div id="debug" style="display: none;">
        <h3>Contr√¥les Debug</h3>
        <button id="giftBtn">Simuler cadeau</button>
        <input id="commentInput" type="text" placeholder="Commentaire">
        <button id="commentBtn">Envoyer</button>
        <button id="likeBtn">Simuler likes</button>
        <button id="toggle-debug">Afficher contr√¥les avanc√©s</button>
        <div id="advanced-debug" style="display: none; margin-top: 10px;">
            <button id="debug-milestone">D√©bloquer milestone</button>
            <button id="debug-entity">Invoquer entit√©</button>
            <button id="debug-clue">R√©v√©ler indice</button>
            <button id="debug-event">D√©clencher √©v√©nement</button>
            <button id="debug-vote">Lancer vote</button>
        </div>
    </div>
    
    <div id="donation-panel">
        <h3 style="margin-top: 0; text-align: center;">Les Profondeurs</h3>
        <button id="open-donation-simulator" style="width:100%; margin-bottom:5px; font-size:10px; padding:4px;">
            Ouvrir le Simulateur de Dons
        </button>
        <div style="font-size:9px; margin-bottom:5px; text-align:center;">
            Pour simuler un don, utilisez le simulateur
        </div>
        <button id="open-tiktok-config" style="width:100%; margin-bottom:10px; font-size:10px; padding:4px; background-color:#ff3366;">
            Configurer API TikTok
        </button>
        <div style="display: flex; justify-content: space-between;">
            <span>Progression narrative:</span>
            <span id="progress-percent">0%</span>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="story-progress"></div>
        </div>
        <div style="display: flex; justify-content: space-between;">
            <span>Prochain palier:</span>
            <span id="next-milestone-amount">500 unit√©s</span>
        </div>
        <div id="story-milestone">
            "Le passage vers le secteur 2 semble bloqu√©. Une intervention externe est n√©cessaire pour r√©tablir l'acc√®s..."
        </div>
        <div style="margin-top: 15px;">
            <div style="display: flex; justify-content: space-between;">
                <span>Total des contributions:</span>
                <span id="total-donations">0 unit√©s</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
                <span>Myst√®res r√©solus:</span>
                <span id="solved-mysteries">0/13</span>
            </div>
        </div>
    </div>
    
    <div id="donor-wall">
        <h4 style="margin-top: 0;">Contributeurs R√©cents</h4>
        <div id="donor-list">
            <!-- Les contributeurs seront ajout√©s ici dynamiquement -->
        </div>
    </div>
    
    <div id="top100-panel">
        <h4>Top 100 Explorateurs</h4>
        <div id="top100-list">
            <!-- La liste des 100 meilleurs sera ici -->
        </div>
    </div>
    
    <div id="narrative-display"></div>
    
    <div id="clue-notification">Indice trouv√©: Enigme #172</div>
    
    <div id="event-counter"></div>
    
    <div id="vote-panel">
        <h4 style="margin-top: 0;">Vote Communautaire</h4>
        <p id="vote-question">Quelle porte le voyageur devrait-il ouvrir ensuite?</p>
        <div class="vote-option" data-option="1">
            <div style="display: flex; justify-content: space-between;">
                <span>Porte avec symbole spirale</span>
                <span>30%</span>
            </div>
            <div class="vote-bar">
                <div class="vote-fill" style="width: 30%"></div>
            </div>
        </div>
        <div class="vote-option" data-option="2">
            <div style="display: flex; justify-content: space-between;">
                <span>Porte rouge clignotante</span>
                <span>45%</span>
            </div>
            <div class="vote-bar">
                <div class="vote-fill" style="width: 45%"></div>
            </div>
        </div>
        <div class="vote-option" data-option="3">
            <div style="display: flex; justify-content: space-between;">
                <span>Porte avec marques de griffes</span>
                <span>25%</span>
            </div>
            <div class="vote-bar">
                <div class="vote-fill" style="width: 25%"></div>
            </div>
        </div>
        <p style="font-size: 12px; text-align: center; margin-top: 10px;">Votre interaction compte comme un vote. Fin dans <span id="vote-timer">02:45</span></p>
    </div>

    <!-- Charger Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // D√©finir les variables globales
        window.scene = null;
        window.camera = null;
        window.renderer = null;
        window.boat = null;
        window.doors = [];
        window.segments = [];
        window.boatSpeed = 0.05;
        window.moveDirection = { x: 0, z: 1 };
        // Variable pour stocker les r√©f√©rences aux fen√™tres ouvertes
        window.detailWindows = [];
        
        // Variables pour le syst√®me de narration et de dons
        window.totalDonations = 0;
        window.currentSeason = 1;
        window.currentEpisode = 1;
        window.currentMilestoneIndex = 0;
        window.storyProgress = 0;
        window.mysteryElements = {};
        window.discoveredClues = [];
        window.solvedMysteries = 0;
        window.activatedDoors = 0;
        window.specialDoors = {};
        window.activeVote = null;
        
        // Constantes
        const TUNNEL_RADIUS = 5;
        const TUNNEL_LENGTH = 20;
        const WATER_LEVEL = -2;
        
        // D√©finition des paliers de donation pour le progr√®s narratif
        const STORY_MILESTONES = [
            { amount: 100, title: "Prologue: L'entr√©e", description: "Les premi√®res portes commencent √† r√©v√©ler d'√©tranges ph√©nom√®nes...", unlocksFunction: unlockPrologue },
            { amount: 500, title: "Secteur 2: Murmures", description: "Des voix lointaines r√©sonnent dans l'eau. Elles semblent raconter des fragments d'histoires...", unlocksFunction: unlockSector2 },
            { amount: 1500, title: "Secteur 3: M√©moires", description: "Des symboles apparaissent sur certaines portes. Ils semblent former un code √† d√©chiffrer...", unlocksFunction: unlockSector3 },
            { amount: 3000, title: "Secteur 4: R√©sonance", description: "L'eau commence √† vibrer √† intervalles r√©guliers. Une pr√©sence se fait sentir dans les profondeurs...", unlocksFunction: unlockSector4 },
            { amount: 5000, title: "Confrontation Mineure: L'Observateur", description: "Une entit√© myst√©rieuse semble suivre le bateau. Ses intentions sont inconnues...", unlocksFunction: unlockMinorEntity },
            { amount: 8000, title: "Secteur 5: Distorsion", description: "La r√©alit√© semble se plier. Certaines portes m√®nent √† des lieux impossibles...", unlocksFunction: unlockSector5 },
            { amount: 12000, title: "Secteur 6: Convergence", description: "Les indices commencent √† converger. Un sch√©ma plus large se dessine...", unlocksFunction: unlockSector6 },
            { amount: 18000, title: "Confrontation Majeure: Le Gardien", description: "Une pr√©sence ancienne bloque le chemin. Elle doit √™tre confront√©e pour continuer...", unlocksFunction: unlockMajorEntity },
            { amount: 25000, title: "Secteur 7: V√©rit√©", description: "Les derniers fragments du myst√®re se d√©voilent. La v√©rit√© est presque √† port√©e...", unlocksFunction: unlockSector7 },
            { amount: 35000, title: "Finale: R√©v√©lation", description: "Le myst√®re final des Profondeurs est sur le point d'√™tre r√©v√©l√©...", unlocksFunction: unlockFinale }
        ];
        
        // D√©finition des niveaux de contributeurs
        const DONOR_TIERS = [
            { min: 1, max: 49, name: "Explorateur", class: "donor-common" },
            { min: 50, max: 199, name: "Chercheur", class: "donor-rare" },
            { min: 200, max: 999, name: "√âclaireur", class: "donor-epic" },
            { min: 1000, max: Infinity, name: "Illumin√©", class: "donor-legendary" }
        ];
        
        // Base de donn√©es des √©l√©ments narratifs
        const STORY_ELEMENTS = {
            clues: [
                { id: "C001", text: "Num√©ro grav√©: 7-3-9-4-2", category: "sequence", linkedMystery: "M003" },
                { id: "C002", text: "Inscription: 'Le cercle s'√©largit mais revient toujours au centre'", category: "phrase", linkedMystery: "M001" },
                { id: "C003", text: "Symbole r√©current: ≈ìil travers√© par une ligne verticale", category: "symbol", linkedMystery: "M002" },
                { id: "C004", text: "Date r√©p√©titive: 22.07.1976", category: "date", linkedMystery: "M005" },
                { id: "C005", text: "Coordonn√©es fragment√©es: 47¬∞N 13...", category: "location", linkedMystery: "M004" },
                { id: "C006", text: "Mot invers√©: RUEGREMBUS", category: "word", linkedMystery: "M002" },
                { id: "C007", text: "Sch√©ma circulaire avec 9 points", category: "pattern", linkedMystery: "M001" },
                { id: "C008", text: "R√©f√©rence: 'Projet Abyssus'", category: "name", linkedMystery: "M007" },
                { id: "C009", text: "√âquation: 2x¬≤ + 3x - ‚àö(4) = 0", category: "math", linkedMystery: "M003" },
                { id: "C010", text: "Fragment audio: voix distordue r√©p√©tant 'le sixi√®me cycle'", category: "audio", linkedMystery: "M006" },
                { id: "C011", text: "Phrase cod√©e: VGSPJVYMREGIVPIVW", category: "cipher", linkedMystery: "M005" },
                { id: "C012", text: "Motif de lumi√®res: court-court-long-long-court", category: "pattern", linkedMystery: "M004" }
            ],
            mysteries: [
                { id: "M001", title: "Le Motif Circulaire", requiredClues: ["C002", "C007"], solved: false, reward: "R√©v√®le l'origine du tunnel" },
                { id: "M002", title: "L'Entit√© Observatrice", requiredClues: ["C003", "C006"], solved: false, reward: "D√©bloque une porte sp√©ciale" },
                { id: "M003", title: "La S√©quence Math√©matique", requiredClues: ["C001", "C009"], solved: false, reward: "Permet de pr√©voir certains √©v√©nements" },
                { id: "M004", title: "Les Signaux", requiredClues: ["C005", "C012"], solved: false, reward: "R√©v√®le un mode de communication" },
                { id: "M005", title: "L'Incident Initial", requiredClues: ["C004", "C011"], solved: false, reward: "Explique pourquoi le tunnel existe" },
                { id: "M006", title: "Les Cycles Temporels", requiredClues: ["C010"], solved: false, reward: "D√©bloque une vision du pass√©/futur" },
                { id: "M007", title: "Les Origines du Projet", requiredClues: ["C008"], solved: false, reward: "R√©v√®le qui a cr√©√© cette exp√©rience" }
            ],
            narrativeFragments: [
                "Les enregistrements indiquent que le projet a √©t√© abandonn√© suite √† une 'contamination'.",
                "Le tunnel n'a pas √©t√© construit. Il est apparu spontan√©ment le 22 juillet 1976.",
                "Certains chercheurs affirment avoir vu leur propre reflet vieilli de plusieurs d√©cennies.",
                "L'eau n'est pas r√©ellement de l'eau. Sa composition mol√©culaire est inconnue.",
                "Les portes apparaissaient et disparaissaient m√™me avant notre arriv√©e.",
                "Les tests ont r√©v√©l√© que le temps s'√©coule diff√©remment √† diverses profondeurs.",
                "√âquipe d'exploration #7: 4 entr√©s, 5 revenus. Anomalie consign√©e.",
                "Les manifestations semblent r√©agir aux √©motions collectives des observateurs.",
                "Th√©orie: nous ne sommes pas dans un lieu physique mais dans une projection mentale collective.",
                "Le sixi√®me cycle s'ach√®vera quand le t√©moin final comprendra sa fonction."
            ]
        };
        
        // ==========================================
        // FONCTIONS D'INITIALISATION
        // ==========================================
        
        // Gestion du redimensionnement de la fen√™tre
        function onWindowResize() {
            // Mettre √† jour la cam√©ra
            window.camera.aspect = window.innerWidth / window.innerHeight;
            window.camera.updateProjectionMatrix();
            
            // Mettre √† jour le renderer
            window.renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Initialisation de l'application
        function init() {
            // Cr√©er la sc√®ne Three.js
            window.scene = new THREE.Scene();
            
            // Cr√©er la cam√©ra
            window.camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            window.camera.position.set(0, 1, -5);
            
            // Cr√©er le renderer
            window.renderer = new THREE.WebGLRenderer({ antialias: false });
            window.renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(window.renderer.domElement);
            
            // Ajouter une lumi√®re ambiante
            const light = new THREE.AmbientLight(0x444444);
            window.scene.add(light);
            
            // Effet de brouillard pour l'atmosph√®re
            window.scene.fog = new THREE.FogExp2(0x000000, 0.035);
            
            // Cr√©er le bateau
            window.boat = createBoat();
            
            // Cr√©er le tunnel initial
            for (let i = 0; i < 3; i++) {
                createSegment(i * TUNNEL_LENGTH);
            }
            
            // G√©rer le redimensionnement
            window.addEventListener('resize', onWindowResize);
            
            // Configurer le debug et les contr√¥les de simulation
            setupDebug();
            setupDonationSystem();
            setupVoteSystem();
            
            // Masquer l'√©cran de chargement
            const loadingScreen = document.getElementById('loading');
            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 500);
            }, 2000);
            
            // Afficher le message d'introduction apr√®s un d√©lai
            setTimeout(showNarrativeMessage, 3000, "Bienvenue dans Les Profondeurs. Les portes cachent des secrets. √Ä vous de les d√©couvrir...", 8000);
            
            // Initialiser les variables de narration
            updateMilestoneDisplay();
            
            // Cr√©er le panneau d'objectifs
            createObjectivesPanel();
            
            // Initialiser les panneaux avec d√©filement automatique (activation directe)
            const historyList = document.getElementById('story-history-list');
            const leaderboardList = document.getElementById('leaderboard-list');
            const top100List = document.getElementById('top100-list');
            
            // Activer l'auto-d√©filement pour l'historique
            if (historyList) {
                const historyPanel = document.getElementById('story-history-panel');
                if (historyPanel) historyPanel.style.display = 'block';
            }
            
            // Activer l'auto-d√©filement pour le leaderboard
            if (leaderboardList) {
                const leaderboardPanel = document.getElementById('leaderboard-panel');
                if (leaderboardPanel) leaderboardPanel.style.display = 'block';
            }
            
            // Activer l'auto-d√©filement pour le top100
            if (top100List) {
                const top100Panel = document.getElementById('top100-panel');
                if (top100Panel) top100Panel.style.display = 'block';
            }
            
            // Ajouter quelques entr√©es initiales dans l'historique si vide
            if (!window.storyHistory || window.storyHistory.length === 0) {
                addToStoryHistory('milestone', 'Bienvenue dans Les Profondeurs');
                addToStoryHistory('discovery', 'Explorez les tunnels √† la recherche d\'indices');
                addToStoryHistory('event', 'Attention aux entit√©s myst√©rieuses');
            }
            
            // D√©marrer l'animation
            animate();
            
            // Ajouter un gestionnaire pour le bouton d√©tails d'exploration
            const detailsButton = document.getElementById('details-button');
            if (detailsButton) {
                detailsButton.addEventListener('click', function() {
                    const detailWindow = window.open('exploration_details.html', '_blank');
                    if (detailWindow) {
                        window.detailWindows.push(detailWindow);
                    }
                });
            }
        }
        
        // Animation de chargement
        function simulateLoading() {
                let progress = 5;
                const loadProgressBar = document.getElementById('load-progress');
                
                const interval = setInterval(() => {
                    progress += Math.floor(Math.random() * 8) + 3;
                    if (progress >= 100) {
                        progress = 100;
                        clearInterval(interval);
                    }
                    loadProgressBar.style.width = progress + '%';
                }, 300);
        }
        
        // Configuration du panneau de debug
        function setupDebug() {
            if (window.location.search.includes('debug=true')) {
                const debugPanel = document.getElementById('debug');
                debugPanel.style.display = 'block';
                
                // Toggle des contr√¥les avanc√©s
                document.getElementById('toggle-debug').addEventListener('click', () => {
                    const advancedDebug = document.getElementById('advanced-debug');
                    advancedDebug.style.display = advancedDebug.style.display === 'none' ? 'block' : 'none';
                });
                
                // Bouton pour simuler un cadeau/don
                document.getElementById('giftBtn').addEventListener('click', () => {
                    const randomAmount = Math.floor(Math.random() * 100) + 5;
                    simulateDonation("Viewer" + Math.floor(Math.random() * 1000), randomAmount);
                });
                
                // Bouton pour envoyer un commentaire
                document.getElementById('commentBtn').addEventListener('click', () => {
                    const text = document.getElementById('commentInput').value.toLowerCase();
                    handleComment(text);
                    document.getElementById('commentInput').value = '';
                });
                
                // Bouton pour simuler des likes
                document.getElementById('likeBtn').addEventListener('click', () => {
                    // Petit effet visuel
                    window.camera.position.x += (Math.random() - 0.5) * 0.1;
                    window.camera.position.y += (Math.random() - 0.5) * 0.1;
                });
                
                // Contr√¥les avanc√©s
                document.getElementById('debug-milestone').addEventListener('click', () => {
                    unlockNextMilestone("Debug");
                });
                
                document.getElementById('debug-entity').addEventListener('click', () => {
                    spawnSpecialEntity();
                });
                
                document.getElementById('debug-clue').addEventListener('click', () => {
                    revealRandomClue();
                });
                
                document.getElementById('debug-event').addEventListener('click', () => {
                    triggerSpecialEvent();
                });
                
                document.getElementById('debug-vote').addEventListener('click', () => {
                    startVote();
                });
            }
        }
        
        // Configuration du syst√®me de dons
        function setupDonationSystem() {
            // V√©rifier si le bouton de simulation de dons existe avant d'ajouter l'√©couteur
            const simDonationBtn = document.getElementById('sim-donation');
            if (simDonationBtn) {
                simDonationBtn.addEventListener('click', () => {
                    const amountInput = document.getElementById('donation-amount');
                    const amount = parseInt(amountInput.value);
                    
                    if (amount && amount > 0) {
                        const username = "Viewer" + Math.floor(Math.random() * 10000);
                        simulateDonation(username, amount);
                        amountInput.value = '';
                    }
                });
            }
            
            // Configuration du bouton d'ouverture du simulateur de dons
            const openDonationSimBtn = document.getElementById('open-donation-simulator');
            if (openDonationSimBtn) {
                openDonationSimBtn.addEventListener('click', () => {
                    openDonationSimulator();
                });
            }
            
            // Configuration du bouton d'ouverture de la configuration TikTok
            const openTikTokConfigBtn = document.getElementById('open-tiktok-config');
            if (openTikTokConfigBtn) {
                openTikTokConfigBtn.addEventListener('click', () => {
                    openTikTokConfig();
                });
            }
            
            // Initialisation des valeurs
            updateDonationDisplay();
            
            // Charger la configuration TikTok s'il y en a une
            loadTikTokConfig();
        }
        
        // Fonction pour ouvrir le simulateur de dons (sans cr√©er de fen√™tre popup)
        function openDonationSimulator() {
            // V√©rifier si un panneau de simulation existe d√©j√† et le supprimer s'il est d√©j√† affich√©
            const existingPanel = document.getElementById('inline-donation-panel');
            if (existingPanel) {
                existingPanel.remove();
                return;
            }
            
            // Cr√©er un panneau flottant pour le simulateur de dons int√©gr√©
            const panel = document.createElement('div');
            panel.id = 'inline-donation-panel';
            panel.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 300px;
                background: rgba(0, 0, 0, 0.9);
                border: 1px solid #ff3366;
                z-index: 1000;
                padding: 15px;
                color: white;
                border-radius: 5px;
                box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            `;
            
            // Ajouter le contenu du simulateur
            panel.innerHTML = `
                <h3 style="text-align: center; margin-top: 0;">Simulateur de Dons</h3>
                <button id="close-simulator" style="position: absolute; top: 5px; right: 5px; background: none; border: none; color: #fff; cursor: pointer; font-size: 16px;">√ó</button>
                <div style="margin-bottom: 15px;">
                    <label>Nom d'utilisateur:</label>
                    <input type="text" id="sim-username" value="Utilisateur${Math.floor(Math.random() * 1000)}" style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label>Montant:</label>
                    <input type="number" id="sim-amount" value="5" min="1" max="1000" style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label>Message (optionnel):</label>
                    <input type="text" id="sim-message" placeholder="Message avec votre don..." style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <button id="donate-2" style="flex: 1; margin-right: 5px; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+2‚Ç¨</button>
                    <button id="donate-5" style="flex: 1; margin-right: 5px; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+5‚Ç¨</button>
                    <button id="donate-10" style="flex: 1; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+10‚Ç¨</button>
                </div>
                <button id="send-donation" style="width: 100%; margin-top: 15px; background: #ff3366; border: none; color: white; padding: 10px; cursor: pointer;">Simuler le Don</button>
            `;
            
            // Ajouter le panneau au document
            document.body.appendChild(panel);
            
            // G√©rer la fermeture du panneau
            document.getElementById('close-simulator').addEventListener('click', () => {
                panel.remove();
            });
            
            // G√©rer les boutons de montant pr√©d√©finis
            document.getElementById('donate-2').addEventListener('click', () => {
                document.getElementById('sim-amount').value = "2";
            });
            
            document.getElementById('donate-5').addEventListener('click', () => {
                document.getElementById('sim-amount').value = "5";
            });
            
            document.getElementById('donate-10').addEventListener('click', () => {
                document.getElementById('sim-amount').value = "10";
            });
            
            // G√©rer l'envoi du don
            document.getElementById('send-donation').addEventListener('click', async () => {
                const username = document.getElementById('sim-username').value || `Utilisateur${Math.floor(Math.random() * 1000)}`;
                const amount = parseFloat(document.getElementById('sim-amount').value) || 5;
                const message = document.getElementById('sim-message').value || '';
                
                if (amount <= 0) {
                    alert('Veuillez entrer un montant positif.');
                    return;
                }
                
                try {
                    // Simuler le don via l'API
                    const response = await fetch('/api/simulate/donation', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ username, amount, message })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        // Fermer le panneau apr√®s un don r√©ussi
                        panel.remove();
                        
                        // Appliquer directement le don √† l'interface actuelle
                        simulateDonation(username, amount);
                    } else {
                        console.error('Erreur lors de la simulation du don:', data.message);
                        alert('Erreur lors de la simulation du don: ' + data.message);
                    }
                } catch (error) {
                    console.error('Erreur lors de la simulation du don:', error);
                    alert('Erreur lors de la simulation du don.');
                }
            });
        }
        
        // Ouvrir la page de configuration de l'API TikTok
        function openTikTokConfig() {
            const width = 800;
            const height = 700;
            const left = (window.innerWidth - width) / 2;
            const top = (window.innerHeight - height) / 2;
            
            const popup = window.open('tiktok_api_config.html', 'TikTokConfig', 
                `width=${width},height=${height},left=${left},top=${top},resizable=yes`);
            
            if (popup) {
                window.tikTokConfigPopup = popup;
            }
        }
        
        // Charger la configuration TikTok depuis localStorage
        function loadTikTokConfig() {
            const savedConfig = localStorage.getItem('tiktokApiConfig');
            
            if (savedConfig) {
                try {
                    window.tikTokConfig = JSON.parse(savedConfig);
                    console.log('Configuration TikTok charg√©e:', window.tikTokConfig);
                } catch (error) {
                    console.error('Erreur lors du chargement de la configuration TikTok:', error);
                }
            }
        }
        
        // Mettre √† jour la configuration TikTok (appel√© depuis la page de configuration)
        function updateTikTokConfig(config) {
            window.tikTokConfig = config;
            console.log('Configuration TikTok mise √† jour:', config);
        }
        
        // Traiter un √©v√©nement TikTok (appel√© depuis la page de configuration ou par l'API)
        function processTikTokEvent(event) {
            console.log('√âv√©nement TikTok re√ßu:', event);
            
            switch (event.type) {
                case 'donation':
                    // Convertir le montant en pi√®ces/diamants en euros
                    const convertedAmount = event.convertedAmount || 
                        (event.amount * (window.tikTokConfig?.donationConversion || 0.01));
                    
                    // Simuler un don avec le montant converti
                    simulateDonation(event.username, convertedAmount, event.giftName || 'Don TikTok');
                    
                    // Am√©lioration: V√©rifier si c'est un don majeur pour des effets sp√©ciaux
                    if (convertedAmount >= 50) {
                        triggerSpecialEvent(event.username);
                    } else if (convertedAmount >= 20) {
                        spawnSpecialEntity();
                    }
                    break;
                    
                case 'subscription':
                    // Traiter l'abonnement comme un don avec un montant fixe
                    const subValue = event.value || 
                        (window.tikTokConfig?.subscriptionValue || 4.99);
                    
                    simulateDonation(event.username, subValue, 'Abonnement');
                    
                    // Am√©lioration: Ajouter un indice sp√©cial pour les abonn√©s
                    revealSpecialClue(event.username);
                    break;
                    
                case 'comment':
                    // Traiter les commentaires pour d√©tecter les mots-cl√©s
                    if (window.tikTokConfig?.enableComments) {
                        handleComment(event.comment, event.username);
                    }
                    break;
                    
                case 'follow':
                    // Ajouter au journal d'exploration
                    addToStoryHistory('event', `${event.username} suit maintenant le stream!`);
                    break;
                    
                case 'share':
                    // R√©compenser le partage avec un petit don virtuel
                    simulateDonation(event.username, 1, 'Partage');
                    
                    // Ajouter au journal d'exploration
                    addToStoryHistory('event', `${event.username} a partag√© le stream!`);
                    break;
                    
                case 'like':
                    // Reconna√Ætre les likes en masse
                    if (event.likeCount && event.likeCount > 5) {
                        // D√©clencher des effets mineurs d'ambiance
                        triggerAmbientEffect(event.likeCount);
                        
                        // Ajouter au journal d'exploration pour les likes importants
                        addToStoryHistory('event', `${event.username} a envoy√© ${event.likeCount} likes!`);
                    }
                    break;
                    
                case 'importantComment':
                    // Traiter les commentaires importants sp√©cifiquement
                    handleImportantComment(event.comment, event.username);
                    break;
                    
                case 'memberJoin':
                    // Membre rejoignant le stream
                    addToStoryHistory('discovery', `${event.username} a rejoint l'exploration!`);
                    break;
            }
        }
        
        // Fonction pour r√©v√©ler un indice sp√©cial aux abonn√©s
        function revealSpecialClue(username) {
            // S√©lectionner un indice pas encore d√©couvert
            const unrevealedClues = STORY_ELEMENTS.clues.filter(clue => !window.discoveredClues.includes(clue.id));
            
            if (unrevealedClues.length > 0) {
                const randomIndex = Math.floor(Math.random() * unrevealedClues.length);
                const clue = unrevealedClues[randomIndex];
                
                // R√©v√©ler un indice pour l'utilisateur
                revealClue(clue.id, username);
                
                // Ajouter un message sp√©cial dans le journal
                addToStoryHistory('discovery', `Indice sp√©cial r√©v√©l√© √† ${username}: "${clue.text}"`);
            }
        }
        
        // Fonction pour g√©rer les commentaires importants
        function handleImportantComment(comment, username) {
            // √âvaluer si le commentaire contient des mots-cl√©s li√©s √† l'histoire
            const storyKeywords = [
                'myst√®re', 'cr√©ature', 'secret', 'porte', 'symbole', 'code', 
                '√©nigme', 'indice', 'lumi√®re', 'ombre', 'profondeur',
                'ab√Æme', 'portail', 'anciens', 'artefact', 'cl√©'
            ];
            
            const lowerComment = comment.toLowerCase();
            const matchedKeywords = storyKeywords.filter(keyword => lowerComment.includes(keyword));
            
            if (matchedKeywords.length >= 2) {
                // Commentaire tr√®s pertinent pour l'histoire
                addToStoryHistory('discovery', `Observation de ${username}: "${comment}"`);
                
                // Potentiellement r√©v√©ler un indice bas√© sur ce commentaire
                if (Math.random() < 0.3) {
                    // 30% de chance de r√©v√©ler un indice
                    setTimeout(() => {
                        revealRandomClue(username);
                    }, 3000 + Math.random() * 5000);
                }
                
                // Pour les commentaires tr√®s pertinents, ajouter un effet visuel subtil
                flashCameraEffect(0.3);
            }
        }
        
        // Fonction pour d√©clencher des effets d'ambiance bas√©s sur l'activit√© TikTok
        function triggerAmbientEffect(intensity) {
            // L'intensit√© repr√©sente combien l'effet doit √™tre prononc√©, bas√© sur les likes/interactions
            intensity = Math.min(intensity / 10, 1.0); // Normaliser entre 0 et 1
            
            // Types d'effets d'ambiance
            const effects = [
                'flicker', // Effet de vacillement des lumi√®res
                'ripple',  // Effet d'ondulation sur l'eau
                'mist',    // Effet de brume temporaire
                'whisper'  // Sons subtils d'ambiance
            ];
            
            // S√©lectionner un effet al√©atoire
            const effect = effects[Math.floor(Math.random() * effects.length)];
            
            // Appliquer l'effet selon le type
            switch (effect) {
                case 'flicker':
                    // Faire vaciller les lumi√®res dans le tunnel
                    flickerLights(intensity);
                    break;
                case 'ripple':
                    // Cr√©er des ondulations sur l'eau
                    createWaterRipple(intensity);
                    break;
                case 'mist':
                    // Ajouter une brume temporaire
                    addTemporaryMist(intensity);
                    break;
                case 'whisper':
                    // Jouer des sons d'ambiance
                    playAmbientSound(intensity);
                    break;
            }
        }
        
        // Faire vaciller les lumi√®res du tunnel
        function flickerLights(intensity) {
            // Trouver toutes les lumi√®res dans la sc√®ne
            const lights = [];
            window.scene.traverse(function(object) {
                if (object.userData && object.userData.light) {
                    lights.push(object.userData.light);
                }
            });
            
            // Aucune lumi√®re trouv√©e
            if (lights.length === 0) return;
            
            // Sauvegarder les intensit√©s d'origine
            const originalIntensities = lights.map(light => light.intensity);
            
            // Nombre de vacillements
            const flickerCount = Math.floor(3 + intensity * 7);
            
            // Fonction pour un vacillement al√©atoire
            function singleFlicker(index) {
                if (index >= flickerCount) {
                    // Restaurer les intensit√©s d'origine
                    lights.forEach((light, i) => { 
                        if (light) light.intensity = originalIntensities[i]; 
                    });
                    return;
                }
                
                // Appliquer un vacillement al√©atoire √† chaque lumi√®re
                lights.forEach((light, i) => {
                    if (light) {
                        const randomFactor = 0.3 + Math.random() * 0.7;
                        light.intensity = originalIntensities[i] * randomFactor;
                    }
                });
                
                // Planifier le prochain vacillement
                setTimeout(() => singleFlicker(index + 1), 50 + Math.random() * 150);
            }
            
            // D√©marrer la s√©quence de vacillement
            singleFlicker(0);
        }
        
        // Cr√©er des ondulations sur l'eau
        function createWaterRipple(intensity) {
            if (!window.waterMesh) return;
            
            // Cr√©er un effet d'ondulation sur l'eau
            const rippleDuration = 2000 + intensity * 3000; // 2-5 secondes selon l'intensit√©
            const startTime = Date.now();
            const originalY = window.waterMesh.position.y;
            
            // Fonction d'animation pour l'ondulation
            function animateRipple() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / rippleDuration;
                
                if (progress >= 1) {
                    // Restaurer la position de l'eau
                    window.waterMesh.position.y = originalY;
                    return;
                }
                
                // Calcul de l'ondulation
                const amplitude = 0.05 * intensity;
                const frequency = 6 + intensity * 4;
                const ripple = amplitude * Math.sin(frequency * progress * Math.PI) * (1 - progress);
                
                // Appliquer l'ondulation
                window.waterMesh.position.y = originalY + ripple;
                
                // Continuer l'animation
                requestAnimationFrame(animateRipple);
            }
            
            // D√©marrer l'animation
            animateRipple();
        }
        
        // Ajouter de la brume temporaire
        function addTemporaryMist(intensity) {
            // V√©rifier si la brume existe d√©j√†
            if (window.mistMesh) return;
            
            // Cr√©er une sph√®re de brume semi-transparente
            const mistGeometry = new THREE.SphereGeometry(10, 16, 16);
            const mistMaterial = new THREE.MeshBasicMaterial({
                color: 0xccccff,
                transparent: true,
                opacity: 0
            });
            
            const mistMesh = new THREE.Mesh(mistGeometry, mistMaterial);
            mistMesh.position.set(window.boat.position.x, 0, window.boat.position.z);
            window.scene.add(mistMesh);
            window.mistMesh = mistMesh;
            
            // Dur√©e de la brume
            const mistDuration = 3000 + intensity * 4000; // 3-7 secondes
            const startTime = Date.now();
            
            // Fonction d'animation pour la brume
            function animateMist() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / mistDuration;
                
                if (progress >= 1) {
                    // Supprimer la brume
                    window.scene.remove(mistMesh);
                    window.mistMesh = null;
                    return;
                }
                
                // Animation de l'opacit√© (apparition puis disparition)
                let opacity;
                if (progress < 0.3) {
                    // Apparition
                    opacity = (progress / 0.3) * 0.3 * intensity;
                } else if (progress > 0.7) {
                    // Disparition
                    opacity = ((1 - progress) / 0.3) * 0.3 * intensity;
                } else {
                    // Plateau
                    opacity = 0.3 * intensity;
                }
                
                // Appliquer l'opacit√©
                mistMaterial.opacity = opacity;
                
                // Continuer l'animation
                requestAnimationFrame(animateMist);
            }
            
            // D√©marrer l'animation
            animateMist();
        }
        
        // Jouer un son d'ambiance
        function playAmbientSound(intensity) {
            // Si le son est d√©sactiv√©, ne rien faire
            if (!window.audioEnabled) return;
            
            // S√©lectionner un son d'ambiance al√©atoire
            const ambientSounds = [
                'whisper', 'creak', 'drip', 'distant_echo'
            ];
            
            const sound = ambientSounds[Math.floor(Math.random() * ambientSounds.length)];
            const volume = 0.1 + intensity * 0.2; // Volume entre 0.1 et 0.3
            
            // Cr√©er un √©l√©ment audio
            const audio = new Audio();
            audio.volume = volume;
            
            // D√©finir la source du son
            switch (sound) {
                case 'whisper':
                    audio.src = 'sounds/whisper.mp3';
                    break;
                case 'creak':
                    audio.src = 'sounds/creak.mp3';
                    break;
                case 'drip':
                    audio.src = 'sounds/drip.mp3';
                    break;
                case 'distant_echo':
                    audio.src = 'sounds/echo.mp3';
                    break;
            }
            
            // Jouer le son
            try {
                audio.play().catch(error => {
                    console.warn('Impossible de jouer le son:', error);
                });
            } catch (error) {
                console.warn('Erreur lors de la lecture du son:', error);
            }
        }
        
        // Configuration du syst√®me de vote
        function setupVoteSystem() {
            // Gestion des clics sur les options de vote
            document.querySelectorAll('.vote-option').forEach(option => {
                option.addEventListener('click', (e) => {
                    const optionIndex = e.currentTarget.getAttribute('data-option');
                    voteForOption(optionIndex);
                });
            });
        }
        
        // ==========================================
        // FONCTIONS DE CR√âATION D'OBJETS 3D
        // ==========================================
        
        // Cr√©er une barque avec un mod√®le Three.js d√©taill√©
        function createBoat() {
            const boat = new THREE.Group();
            
            // Coque principale - forme d'une barque traditionnelle
            const hullShape = new THREE.Shape();
            // D√©finir un contour en forme de barque vue de dessus
            hullShape.moveTo(-0.7, -1.2);
            hullShape.quadraticCurveTo(-0.2, -1.5, 0, -1.5);
            hullShape.quadraticCurveTo(0.2, -1.5, 0.7, -1.2);
            hullShape.quadraticCurveTo(0.9, -0.8, 0.9, 0);
            hullShape.quadraticCurveTo(0.9, 0.8, 0.7, 1.2);
            hullShape.quadraticCurveTo(0.2, 1.5, 0, 1.5);
            hullShape.quadraticCurveTo(-0.2, 1.5, -0.7, 1.2);
            hullShape.quadraticCurveTo(-0.9, 0.8, -0.9, 0);
            hullShape.quadraticCurveTo(-0.9, -0.8, -0.7, -1.2);
            
            // Extruder la forme pour cr√©er la coque 3D
            const extrudeSettings = {
                steps: 2,
                depth: 0.5,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.1,
                bevelOffset: 0,
                bevelSegments: 3
            };
            
            const hullGeometry = new THREE.ExtrudeGeometry(hullShape, extrudeSettings);
            
            // Cr√©er un mat√©riau pour la coque avec texture de bois
            const hullMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.7,
                metalness: 0.2
            });
            
            // Cr√©er un effet de veine de bois (proc√©dural)
            const woodTexture = createWoodTexture();
            hullMaterial.map = woodTexture;
            
            const hull = new THREE.Mesh(hullGeometry, hullMaterial);
            hull.rotation.x = Math.PI / 2; // Orienter correctement la barque
            boat.add(hull);
            
            // Ajouter des bancs transversaux
            const benchMaterial = new THREE.MeshStandardMaterial({
                color: 0x964B00,
                roughness: 0.8,
                metalness: 0.1
            });
            
            // Banc avant
            const frontBenchGeometry = new THREE.BoxGeometry(1.4, 0.1, 0.25);
            const frontBench = new THREE.Mesh(frontBenchGeometry, benchMaterial);
            frontBench.position.set(0, 0.3, 0.9);
            boat.add(frontBench);
            
            // Banc arri√®re
            const backBenchGeometry = new THREE.BoxGeometry(1.4, 0.1, 0.25);
            const backBench = new THREE.Mesh(backBenchGeometry, benchMaterial);
            backBench.position.set(0, 0.3, -0.9);
            boat.add(backBench);
            
            // Banc milieu
            const middleBenchGeometry = new THREE.BoxGeometry(1.4, 0.1, 0.25);
            const middleBench = new THREE.Mesh(middleBenchGeometry, benchMaterial);
            middleBench.position.set(0, 0.3, 0);
            boat.add(middleBench);
            
            // Ajouter une lanterne pour l'ambiance
            const lanternBase = new THREE.CylinderGeometry(0.05, 0.05, 0.2, 8);
            const lanternGlobe = new THREE.SphereGeometry(0.1, 8, 8);
            const lanternMaterial = new THREE.MeshStandardMaterial({
                color: 0x553311,
                roughness: 0.5
            });
            const lanternGlassMaterial = new THREE.MeshStandardMaterial({
                color: 0xffaa55,
                emissive: 0xff6622,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.7
            });
            
            const lanternBaseObj = new THREE.Mesh(lanternBase, lanternMaterial);
            const lanternGlobeObj = new THREE.Mesh(lanternGlobe, lanternGlassMaterial);
            lanternGlobeObj.position.y = 0.15;
            
            const lantern = new THREE.Group();
            lantern.add(lanternBaseObj);
            lantern.add(lanternGlobeObj);
            lantern.position.set(0, 0.4, 0.9);
            boat.add(lantern);
            
            // Ajouter une lumi√®re dans la lanterne
            const lanternLight = new THREE.PointLight(0xff6622, 1, 3);
            lanternLight.position.set(0, 0.15, 0);
            lantern.add(lanternLight);
            
            // Position et √©chelle finale de la barque
            boat.scale.set(0.7, 0.7, 0.7);
            boat.position.y = WATER_LEVEL + 0.4;
            window.scene.add(boat);
            
            // Variables pour l'animation narrative de la barque
            boat.userData = {
                lanternLight: lanternLight,
                lanternOriginalIntensity: 1,
                narrativeState: "normal"
            };
            
            return boat;
        }
        
        // Fonction pour cr√©er une texture de bois
        function createWoodTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            
            // Fond
            context.fillStyle = "#8B4513";
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Veines de bois
            for (let i = 0; i < 30; i++) {
                // Position et √©paisseur variables
                const y = Math.random() * canvas.height;
                const width = 1 + Math.random() * 3;
                
                // Couleur de veine l√©g√®rement variable
                const brightness = 100 + Math.floor(Math.random() * 50);
                const color = `rgb(${brightness}, ${brightness * 0.6}, ${brightness * 0.4})`;
                
                context.beginPath();
                context.moveTo(0, y);
                
                // Cr√©er une ligne ondul√©e
                for (let x = 0; x < canvas.width; x += canvas.width/20) {
                    const newY = y + (Math.random() - 0.5) * 15;
                    context.lineTo(x, newY);
                }
                
                context.strokeStyle = color;
                context.lineWidth = width;
                context.stroke();
            }
            
            // Noeuds du bois
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 3 + Math.random() * 8;
                
                const gradient = context.createRadialGradient(x, y, 1, x, y, radius);
                gradient.addColorStop(0, "#4B2809");
                gradient.addColorStop(1, "#8B4513");
                
                context.beginPath();
                context.arc(x, y, radius, 0, Math.PI * 2);
                context.fillStyle = gradient;
                context.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }
        
        // Cr√©er un segment de tunnel avec rebords et portes
        function createSegment(zPosition) {
            const segment = new THREE.Group();
            segment.position.z = zPosition;
            
            // Tunnel principal
            const tunnelGeometry = new THREE.CylinderGeometry(
                TUNNEL_RADIUS, TUNNEL_RADIUS, TUNNEL_LENGTH, 16, 1, true
            );
            const tunnelMaterial = new THREE.MeshPhongMaterial({
                color: 0x333333, 
                side: THREE.BackSide
            });
            const tunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
            tunnel.rotation.x = Math.PI / 2;
            segment.add(tunnel);
            
            // Sol/eau au centre
            const waterWidth = TUNNEL_RADIUS * 1.2; // R√©duire pour laisser de la place aux rebords
            const floorGeometry = new THREE.PlaneGeometry(
                waterWidth, TUNNEL_LENGTH
            );
            const waterMaterial = new THREE.MeshPhongMaterial({
                color: 0x006666,
                transparent: true,
                opacity: 0.7
            });
            const floor = new THREE.Mesh(floorGeometry, waterMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = WATER_LEVEL;
            segment.add(floor);
            
            // Ajouter un effet de miroitement √† l'eau
            segment.userData.water = floor;
            segment.userData.waterBaseColor = new THREE.Color(0x006666);
            
            // Ajouter des rebords et des portes r√©guli√®rement
            for (let z = 0; z < TUNNEL_LENGTH; z += 5) {
                // Position en z
                const doorZ = z - TUNNEL_LENGTH / 2;
                
                // D√©terminer si cette porte est sp√©ciale (narrative)
                const isSpecialDoor = Math.random() < 0.05 + (window.storyProgress * 0.02);
                
                // Porte gauche
                const leftDoor = createDoor(isSpecialDoor);
                leftDoor.position.set(-TUNNEL_RADIUS + 0.2, WATER_LEVEL + 1.5, doorZ);
                leftDoor.rotation.y = Math.PI/2; // Rotation pour que la porte soit perpendiculaire √† la paroi du tunnel
                leftDoor.rotation.z = 0; // Assurer que la porte est verticale
                segment.add(leftDoor);
                
                if (isSpecialDoor) {
                    registerSpecialDoor(leftDoor);
                }
                
                window.doors.push(leftDoor);
                
                // Porte droite - perpendiculaire √† la paroi et verticale
                const rightDoor = createDoor(isSpecialDoor);
                rightDoor.position.set(TUNNEL_RADIUS - 0.2, WATER_LEVEL + 1.5, doorZ);
                rightDoor.rotation.y = -Math.PI/2; // Rotation pour que la porte soit perpendiculaire √† la paroi du tunnel
                rightDoor.rotation.z = 0; // Assurer que la porte est verticale
                segment.add(rightDoor);
                
                if (isSpecialDoor) {
                    registerSpecialDoor(rightDoor);
                }
                
                window.doors.push(rightDoor);
                
                // Rebords pour marcher (gauche et droite)
                createWalkway(segment, -TUNNEL_RADIUS + 0.6, WATER_LEVEL + 0.1, doorZ - 2.5, 5);
                createWalkway(segment, TUNNEL_RADIUS - 0.6, WATER_LEVEL + 0.1, doorZ - 2.5, 5);
                
                // Lumi√®res murales
                createWallLight(segment, -TUNNEL_RADIUS + 0.1, WATER_LEVEL + 2, doorZ - 1.5);
                createWallLight(segment, TUNNEL_RADIUS - 0.1, WATER_LEVEL + 2, doorZ - 1.5);
            }
            
            // Lumi√®re g√©n√©rale du tunnel (faible)
            const ambientLight = new THREE.PointLight(0x333333, 0.3, TUNNEL_RADIUS * 2);
            ambientLight.position.set(0, 0, 0);
            segment.add(ambientLight);
            
            // Stocker la position et les donn√©es suppl√©mentaires
            segment.userData = { 
                ...segment.userData,
                zPosition: zPosition,
                narrativeZone: determineNarrativeZone(zPosition),
                ambientLight: ambientLight
            };
            
            window.scene.add(segment);
            window.segments.push(segment);
            return segment;
        }
        
        // Cr√©er un rebord pour marcher
        function createWalkway(parent, x, y, z, length) {
            // Plateforme pour marcher
            const walkwayGeometry = new THREE.BoxGeometry(1, 0.2, length);
            const walkwayMaterial = new THREE.MeshPhongMaterial({color: 0x555555});
            const walkway = new THREE.Mesh(walkwayGeometry, walkwayMaterial);
            walkway.position.set(x, y, z + length/2);
            parent.add(walkway);
            
            // Support m√©tallique
            for (let i = 0; i < length; i += 1.5) {
                const supportGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 6);
                const supportMaterial = new THREE.MeshPhongMaterial({color: 0x777777});
                const support = new THREE.Mesh(supportGeometry, supportMaterial);
                support.position.set(x, y - 0.35, z + i);
                parent.add(support);
            }
            
            return walkway;
        }
        
        // Cr√©er une lumi√®re murale
        function createWallLight(parent, x, y, z) {
            // Groupe pour la lumi√®re
            const lightGroup = new THREE.Group();
            lightGroup.position.set(x, y, z);
            
            // Support mural
            const baseGeometry = new THREE.BoxGeometry(0.1, 0.3, 0.3);
            const baseMaterial = new THREE.MeshPhongMaterial({color: 0x333333});
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            
            // Orientation selon le c√¥t√©
            if (x < 0) { // C√¥t√© gauche
                base.rotation.y = 0;
                lightGroup.rotation.y = 0;
            } else { // C√¥t√© droit
                base.rotation.y = Math.PI;
                lightGroup.rotation.y = Math.PI;
            }
            
            lightGroup.add(base);
            
            // Ampoule/Globe
            const bulbGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            
            // La couleur varie en fonction de la progression de l'histoire
            const colorProgress = Math.min(window.storyProgress, 1);
            const bulbColor = new THREE.Color().setHSL(
                0.1 - (colorProgress * 0.1), // De jaune vers rouge
                0.7,
                0.5 + (colorProgress * 0.2) // Devient plus brillant
            );
            
            const bulbMaterial = new THREE.MeshBasicMaterial({
                color: bulbColor
                // emissive et emissiveIntensity sont retir√©s car non support√©s par MeshBasicMaterial
            });
            
            const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
            bulb.position.x = (x < 0) ? 0.1 : -0.1; // Position selon le c√¥t√©
            lightGroup.add(bulb);
            
            // Lumi√®re
            const intensity = 0.5 + Math.random() * 0.5;
            const light = new THREE.PointLight(bulbColor, intensity, 3);
            light.position.copy(bulb.position);
            lightGroup.add(light);
            
            // Ajouter des donn√©es pour les animations
            lightGroup.userData = {
                bulb: bulb,
                light: light,
                originalIntensity: intensity,
                flicker: Math.random() < 0.3, // 30% de chance de scintillement
                flickerSpeed: 0.5 + Math.random() * 2,
                originalColor: bulbColor.clone()
            };
            
            parent.add(lightGroup);
            return lightGroup;
        }
        
        // Cr√©er une porte avec une orientation correcte et th√©matique
        function createDoor(isSpecial = false) {
            const door = new THREE.Group();
            
            // Couleurs diff√©rentes selon le type de porte
            let doorColor, frameColor, detailsColor;
            let doorSymbol = null;
            
            if (isSpecial) {
                // Porte sp√©ciale avec couleur et caract√©ristiques uniques
                const specialType = Math.floor(Math.random() * 5);
                
                switch(specialType) {
                    case 0: // Porte myst√©rieuse avec symboles
                        frameColor = 0x443322;
                        doorColor = 0x221100;
                        detailsColor = 0xaa8866;
                        doorSymbol = "symbol";
                        break;
                    case 1: // Porte rouge sang
                        frameColor = 0x662222;
                        doorColor = 0x990000;
                        detailsColor = 0xaa3333;
                        doorSymbol = "blood";
                        break;
                    case 2: // Porte luminescente
                        frameColor = 0x443355;
                        doorColor = 0x334466;
                        detailsColor = 0x88aaff;
                        doorSymbol = "glow";
                        break;
                    case 3: // Porte m√©tallique rouill√©e
                        frameColor = 0x775533;
                        doorColor = 0x996633;
                        detailsColor = 0xcc8844;
                        doorSymbol = "rust";
                        break;
                    case 4: // Porte avec marques de griffes
                        frameColor = 0x554433;
                        doorColor = 0x443322;
                        detailsColor = 0x333333;
                        doorSymbol = "claw";
                        break;
                }
            } else {
                // Porte standard
                frameColor = 0x553322;
                doorColor = 0x332211;
                detailsColor = 0x888888;
            }
            
            // Cadre de porte
            const frameGeometry = new THREE.BoxGeometry(2, 3, 0.2);
            const frameMaterial = new THREE.MeshPhongMaterial({color: frameColor});
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            door.add(frame);
            
            // La porte elle-m√™me (panneau)
            const doorGeometry = new THREE.BoxGeometry(1.8, 2.8, 0.1);
            const doorMaterial = new THREE.MeshPhongMaterial({color: doorColor});
            const doorMesh = new THREE.Mesh(doorGeometry, doorMaterial);
            // Positionner la porte correctement pour l'animation
            doorMesh.position.z = -0.15; 
            door.add(doorMesh);
            
            // Poign√©e de porte
            const handleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const handleMaterial = new THREE.MeshPhongMaterial({color: detailsColor});
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.set(0.5, 0, -0.15); // √Ä droite de la porte vue de face
            door.add(handle);
            
            // Ajout de num√©ro ou symbole de porte
            const doorNumber = Math.floor(Math.random() * 900) + 100;
            
            // Plaque de num√©ro/symbole
            const plateGeometry = new THREE.PlaneGeometry(0.4, 0.2);
            const plateMaterial = new THREE.MeshPhongMaterial({
                color: detailsColor,
                side: THREE.DoubleSide
            });
            const plate = new THREE.Mesh(plateGeometry, plateMaterial);
            plate.position.set(0, 1, -0.11);
            door.add(plate);
            
            // Ajouter un symbole sp√©cial si c'est une porte sp√©ciale
            if (isSpecial && doorSymbol) {
                // Cr√©er le symbole selon le type
                switch(doorSymbol) {
                    case "symbol":
                        // Ajouter un symbole √©sot√©rique
                        addSymbolToDoor(door, plate);
                        break;
                    case "blood":
                        // Ajouter des taches de sang
                        addBloodToDoor(door, doorMesh);
                        break;
                    case "glow":
                        // Ajouter un effet lumineux
                        addGlowToDoor(door, doorMesh);
                        break;
                    case "rust":
                        // Ajouter des taches de rouille
                        addRustToDoor(door, doorMesh);
                        break;
                    case "claw":
                        // Ajouter des marques de griffes
                        addClawMarksToDoor(door, doorMesh);
                        break;
                }
            }
            
            // Donn√©es pour l'animation et statut narratif
            door.userData = {
                doorMesh: doorMesh,
                animating: false,
                doorNumber: doorNumber,
                isSpecial: isSpecial,
                doorSymbol: doorSymbol,
                activated: false,
                containsClue: isSpecial && (Math.random() < 0.6), // 60% des portes sp√©ciales contiennent un indice
                containsEntity: isSpecial && (Math.random() < 0.3), // 30% des portes sp√©ciales contiennent une entit√©
                entityType: isSpecial ? Math.floor(Math.random() * 7) : null,
                narrativeElement: null
            };
            
            return door;
        }
        
        // Ajouter un symbole √©sot√©rique √† une porte
        function addSymbolToDoor(door, plate) {
            // Cr√©er un canvas pour dessiner le symbole
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Fond transparent
            ctx.fillStyle = 'rgba(0, 0, 0, 0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Choisir un symbole al√©atoire
            const symbolType = Math.floor(Math.random() * 5);
            
            // Dessiner le symbole en blanc
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.fillStyle = 'white';
            
            switch(symbolType) {
                case 0: // Cercle avec triangle
                    ctx.beginPath();
                    ctx.arc(64, 64, 40, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(64, 34);
                    ctx.lineTo(94, 94);
                    ctx.lineTo(34, 94);
                    ctx.closePath();
                    ctx.stroke();
                    break;
                    
                case 1: // Spirale
                    ctx.beginPath();
                    let radius = 5;
                    let angle = 0;
                    let x = 64;
                    let y = 64;
                    
                    for (let i = 0; i < 200; i++) {
                        angle += 0.1;
                        radius += 0.2;
                        const newX = 64 + Math.cos(angle) * radius;
                        const newY = 64 + Math.sin(angle) * radius;
                        ctx.lineTo(newX, newY);
                        x = newX;
                        y = newY;
                        
                        if (radius > 40) break;
                    }
                    ctx.stroke();
                    break;
                    
                case 2: // ≈íil
                    ctx.beginPath();
                    ctx.ellipse(64, 64, 45, 25, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(64, 64, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(64, 39);
                    ctx.lineTo(64, 89);
                    ctx.stroke();
                    break;
                    
                case 3: // Runes
                    for (let i = 0; i < 3; i++) {
                        const startX = 34 + i * 30;
                        ctx.beginPath();
                        
                        // Runes al√©atoires
                        switch(Math.floor(Math.random() * 5)) {
                            case 0: // F-like
                                ctx.moveTo(startX, 44);
                                ctx.lineTo(startX, 94);
                                ctx.moveTo(startX, 44);
                                ctx.lineTo(startX + 20, 44);
                                ctx.moveTo(startX, 69);
                                ctx.lineTo(startX + 15, 69);
                                break;
                            case 1: // X-like
                                ctx.moveTo(startX - 10, 44);
                                ctx.lineTo(startX + 10, 94);
                                ctx.moveTo(startX + 10, 44);
                                ctx.lineTo(startX - 10, 94);
                                break;
                            case 2: // O with line
                                ctx.arc(startX, 69, 25, 0, Math.PI * 2);
                                ctx.moveTo(startX - 25, 69);
                                ctx.lineTo(startX + 25, 69);
                                break;
                            case 3: // Arrow
                                ctx.moveTo(startX, 44);
                                ctx.lineTo(startX, 94);
                                ctx.moveTo(startX - 10, 54);
                                ctx.lineTo(startX, 44);
                                ctx.lineTo(startX + 10, 54);
                                break;
                            case 4: // Wave
                                ctx.moveTo(startX - 15, 69);
                                for (let j = 0; j < 30; j++) {
                                    ctx.lineTo(startX - 15 + j, 69 + Math.sin(j * 0.3) * 15);
                                }
                                break;
                        }
                        
                        ctx.stroke();
                    }
                    break;
                    
                case 4: // Constellation
                    // Points
                    const points = [];
                    for (let i = 0; i < 7; i++) {
                        points.push({
                            x: 30 + Math.random() * 68,
                            y: 30 + Math.random() * 68,
                            r: 2 + Math.random() * 3
                        });
                    }
                    
                    // Dessiner les points
                    points.forEach(point => {
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, point.r, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Relier certains points
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) {
                        if (Math.random() < 0.7) { // 70% de chance de relier deux points
                            ctx.lineTo(points[i].x, points[i].y);
                        } else {
                            ctx.moveTo(points[i].x, points[i].y);
                        }
                    }
                    ctx.stroke();
                    break;
            }
            
            // Cr√©er une texture √† partir du canvas
            const symbolTexture = new THREE.CanvasTexture(canvas);
            
            // Cr√©er un mat√©riau avec cette texture
            const symbolMaterial = new THREE.MeshBasicMaterial({
                map: symbolTexture,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            
            // Remplacer le mat√©riau de la plaque
            plate.material = symbolMaterial;
            
            // Agrandir la plaque pour le symbole
            plate.scale.set(2, 2, 1);
            
            // Stocker les donn√©es pour animation
            door.userData.symbolType = symbolType;
            door.userData.symbolTexture = symbolTexture;
        }
        
        // Ajouter des taches de sang √† une porte
        function addBloodToDoor(door, doorMesh) {
            // Cr√©er un canvas pour dessiner les taches
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Copier la couleur de base de la porte
            ctx.fillStyle = '#990000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner des taches de sang al√©atoires
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 10 + Math.random() * 50;
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, 'rgba(120, 0, 0, 0.9)');
                gradient.addColorStop(0.7, 'rgba(80, 0, 0, 0.6)');
                gradient.addColorStop(1, 'rgba(80, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Dessiner des tra√Æn√©es de sang coulant
            for (let i = 0; i < 5; i++) {
                const startX = Math.random() * canvas.width;
                const startY = Math.random() * (canvas.height / 2); // Commencer dans la moiti√© sup√©rieure
                
                ctx.strokeStyle = 'rgba(100, 0, 0, 0.8)';
                ctx.lineWidth = 3 + Math.random() * 8;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                
                let currentX = startX;
                let currentY = startY;
                
                // Cr√©er une ligne descendante avec zigzags al√©atoires
                const length = 50 + Math.random() * 200;
                for (let j = 0; j < length; j += 10) {
                    currentY += 10;
                    currentX += (Math.random() - 0.5) * 15;
                    
                    // R√©duire progressivement l'√©paisseur de la ligne
                    ctx.lineWidth = Math.max(1, ctx.lineWidth - 0.2);
                    
                    ctx.lineTo(currentX, currentY);
                    
                    if (currentY > canvas.height) break;
                }
                
                ctx.stroke();
            }
            
            // Cr√©er une texture √† partir du canvas
            const bloodTexture = new THREE.CanvasTexture(canvas);
            
            // Appliquer la texture √† la porte
            const bloodMaterial = new THREE.MeshStandardMaterial({
                map: bloodTexture,
                color: 0x990000,
                roughness: 0.7,
                metalness: 0.2
            });
            
            doorMesh.material = bloodMaterial;
        }
        
        // Ajouter un effet lumineux √† une porte
        function addGlowToDoor(door, doorMesh) {
            // Cr√©er un mat√©riau avec √©mission pour l'effet lumineux
            const glowMaterial = new THREE.MeshStandardMaterial({
                color: 0x334466,
                emissive: 0x88aaff,
                emissiveIntensity: 0.5,
                roughness: 0.4,
                metalness: 0.6
            });
            
            doorMesh.material = glowMaterial;
            
            // Ajouter une lumi√®re pour renforcer l'effet
            const glowLight = new THREE.PointLight(0x88aaff, 0.8, 1);
            glowLight.position.set(0, 0, -0.1);
            doorMesh.add(glowLight);
            
            // Stocker la lumi√®re pour l'animation
            door.userData.glowLight = glowLight;
            door.userData.originalIntensity = 0.8;
        }
        
        // Ajouter des taches de rouille √† une porte
        function addRustToDoor(door, doorMesh) {
            // Cr√©er un canvas pour dessiner la rouille
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Couleur de base m√©tallique
            ctx.fillStyle = '#996633';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Ajouter une texture m√©tallique de base
            for (let i = 0; i < 20; i++) {
                ctx.strokeStyle = `rgba(153, 122, 102, ${Math.random() * 0.3})`;
                ctx.lineWidth = 1 + Math.random() * 2;
                
                ctx.beginPath();
                ctx.moveTo(0, Math.random() * canvas.height);
                ctx.lineTo(canvas.width, Math.random() * canvas.height);
                ctx.stroke();
            }
            
            // Ajouter des taches de rouille
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 5 + Math.random() * 40;
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, 'rgba(180, 60, 20, 0.9)');
                gradient.addColorStop(0.6, 'rgba(160, 80, 30, 0.6)');
                gradient.addColorStop(1, 'rgba(153, 102, 51, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Ajouter quelques trous de rouille
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 2 + Math.random() * 6;
                
                ctx.fillStyle = 'rgba(30, 20, 10, 0.8)';
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Ajouter un halo de rouille intense autour du trou
                const holeGradient = ctx.createRadialGradient(x, y, radius, x, y, radius * 3);
                holeGradient.addColorStop(0, 'rgba(180, 60, 20, 0.9)');
                holeGradient.addColorStop(1, 'rgba(180, 60, 20, 0)');
                
                ctx.fillStyle = holeGradient;
                ctx.beginPath();
                ctx.arc(x, y, radius * 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Cr√©er une texture √† partir du canvas
            const rustTexture = new THREE.CanvasTexture(canvas);
            
            // Appliquer la texture √† la porte
            const rustMaterial = new THREE.MeshStandardMaterial({
                map: rustTexture,
                roughness: 0.9,
                metalness: 0.4
            });
            
            doorMesh.material = rustMaterial;
        }
        
        // Ajouter des marques de griffes √† une porte
        function addClawMarksToDoor(door, doorMesh) {
            // Cr√©er un canvas pour dessiner les marques
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Couleur de base de la porte
            ctx.fillStyle = '#443322';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner des marques de griffes
            const clawSets = Math.floor(Math.random() * 3) + 2; // 2-4 sets de griffes
            
            for (let set = 0; set < clawSets; set++) {
                const startX = 50 + Math.random() * (canvas.width - 100);
                const startY = 50 + Math.random() * (canvas.height - 100);
                const angle = Math.random() * Math.PI / 4 - Math.PI / 8; // Angle al√©atoire l√©ger
                const length = 100 + Math.random() * 200;
                
                // 3-5 griffes par set
                const claws = Math.floor(Math.random() * 3) + 3;
                const spacing = 10 + Math.random() * 15;
                
                for (let claw = 0; claw < claws; claw++) {
                    // Calculer le d√©calage perpendiculaire √† l'angle
                    const offsetX = Math.sin(angle) * spacing * (claw - (claws - 1) / 2);
                    const offsetY = -Math.cos(angle) * spacing * (claw - (claws - 1) / 2);
                    
                    ctx.strokeStyle = '#221100';
                    ctx.lineWidth = 3 + Math.random() * 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(startX + offsetX, startY + offsetY);
                    
                    // Ligne principale
                    const endX = startX + Math.cos(angle) * length + offsetX;
                    const endY = startY + Math.sin(angle) * length + offsetY;
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    // Ajouter une ligne plus claire pour montrer le bois expos√©
                    ctx.strokeStyle = 'rgba(200, 150, 100, 0.7)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(startX + offsetX + 1, startY + offsetY + 1);
                    ctx.lineTo(endX + 1, endY + 1);
                    ctx.stroke();
                }
            }
            
            // Cr√©er une texture √† partir du canvas
            const clawTexture = new THREE.CanvasTexture(canvas);
            
            // Appliquer la texture √† la porte
            const clawMaterial = new THREE.MeshStandardMaterial({
                map: clawTexture,
                roughness: 0.8,
                metalness: 0.1
            });
            
            doorMesh.material = clawMaterial;
        }
        
        // D√©terminer la zone narrative en fonction de la position
        function determineNarrativeZone(zPosition) {
            // La progression narrative est d√©termin√©e par la distance parcourue
            // Plus on s'enfonce dans le tunnel, plus l'histoire avance
            const absolutePosition = Math.abs(zPosition);
            
            // Secteurs d√©termin√©s par les paliers de milestone
            if (absolutePosition < 50) return "prologue";
            if (absolutePosition < 150) return "secteur2";
            if (absolutePosition < 300) return "secteur3";
            if (absolutePosition < 500) return "secteur4";
            if (absolutePosition < 800) return "secteur5";
            if (absolutePosition < 1200) return "secteur6";
            if (absolutePosition < 1800) return "secteur7";
            return "finale";
        }
        
        // Enregistrer une porte sp√©ciale
        function registerSpecialDoor(door) {
            const doorId = "door_" + Math.floor(Math.random() * 10000);
            window.specialDoors[doorId] = door;
            door.userData.doorId = doorId;
            
            // Si nous avons des indices non d√©couverts, attribuer l'un d'eux √† cette porte
            const availableClues = STORY_ELEMENTS.clues.filter(
                clue => !window.discoveredClues.includes(clue.id)
            );
            
            if (availableClues.length > 0 && door.userData.containsClue) {
                const randomClue = availableClues[Math.floor(Math.random() * availableClues.length)];
                door.userData.narrativeElement = {
                    type: "clue",
                    data: randomClue
                };
            }
        }
        
        // ==========================================
        // FONCTIONS D'ANIMATION ET INTERACTION
        // ==========================================
        
        // Animer une porte et r√©v√©ler son contenu
        function animateDoor(door) {
            if (!door || door.userData.animating) return;
            
            door.userData.animating = true;
            const doorMesh = door.userData.doorMesh;
            const originalPosition = -0.15; // Position initiale
            
            // Incr√©menter le compteur de portes activ√©es
            window.activatedDoors++;
            
            // Si c'est une porte sp√©ciale, la marquer comme activ√©e
            if (door.userData.isSpecial && !door.userData.activated) {
                door.userData.activated = true;
                
                // R√©v√©ler un indice ou d√©clencher un √©v√©nement narratif si applicable
                if (door.userData.narrativeElement) {
                    handleNarrativeElement(door.userData.narrativeElement);
                }
            }
            
            // Cr√©er ou r√©cup√©rer l'√©l√©ment myst√©rieux derri√®re la porte
            let mysteryElement = null;
            
            if (!door.userData.mysteryElement) {
                // D√©terminer le type d'√©l√©ment myst√©rieux
                const entityType = door.userData.entityType || Math.floor(Math.random() * 7);
                
                // Si la porte est sp√©ciale, plus de chance d'avoir une entit√© complexe
                const mysteryType = door.userData.isSpecial ? 
                    Math.min(6, Math.floor(Math.random() * 8)) : // Favorise les entit√©s 0-6
                    Math.floor(Math.random() * 7); // Distribution uniforme
                
                mysteryElement = createMysteryElement(mysteryType, entityType);
                
                // Positionner l'√©l√©ment derri√®re la porte
                const doorPosition = new THREE.Vector3();
                door.getWorldPosition(doorPosition);
                
                // Ajuster la position en fonction de l'orientation de la porte
                const doorDirection = new THREE.Vector3(0, 0, -1);
                doorDirection.applyQuaternion(door.quaternion);
                
                // Placer l'√©l√©ment derri√®re la porte √† une distance appropri√©e
                mysteryElement.position.copy(doorPosition);
                mysteryElement.position.add(doorDirection.multiplyScalar(1.5));
                
                // Attacher l'√©l√©ment √† la porte
                door.userData.mysteryElement = mysteryElement;
                door.userData.mysteryType = mysteryType;
                
                // Ajouter l'√©l√©ment √† la sc√®ne
                window.scene.add(mysteryElement);
                
                // Stocker dans la liste globale pour les mises √† jour
                window.mysteryElements[mysteryElement.uuid] = mysteryElement;
            } else {
                mysteryElement = door.userData.mysteryElement;
            }
            
            // Animation d'ouverture puis de fermeture
            let openAmount = 0;
            let opening = true;
            let revealSound = false;
            let effectTriggered = false;
            
            const interval = setInterval(() => {
                if (opening) {
                    // Phase d'ouverture
                    openAmount += 0.02;
                    
                    // Jouer un son/effet √† mi-ouverture
                    if (openAmount >= 0.15 && !revealSound) {
                        playMysterySound(door.userData.mysteryType || 0);
                        revealSound = true;
                    }
                    
                    // Limitation de l'ouverture maximale
                    if (openAmount >= 0.3) {
                        opening = false;
                        
                        // D√©clencher un effet sp√©cial une seule fois
                        if (!effectTriggered) {
                            triggerMysteryEffect(door.userData.mysteryType || 0, mysteryElement);
                            effectTriggered = true;
                        }
                    }
                } else {
                    // Phase de fermeture
                    openAmount -= 0.02;
                    
                    // V√©rification fin de fermeture
                    if (openAmount <= 0) {
                        openAmount = 0;
                        clearInterval(interval);
                        door.userData.animating = false;
                        
                        // Ne pas supprimer l'√©l√©ment myst√©rieux pour permettre des interactions continues
                        // avec le m√™me √©l√©ment si la porte est rouverte
                    }
                }
                
                // Appliquer le mouvement de la porte correctement
                doorMesh.position.z = originalPosition - openAmount;
            }, 50);
        }
        
        // Cr√©er un √©l√©ment myst√©rieux
        function createMysteryElement(type, entityVariant = 0) {
            const group = new THREE.Group();
            
            switch (type) {
                case 0: // Yeux brillants
                    const glowingEyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const glowingEyeMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
                    
                    const glowingLeftEye = new THREE.Mesh(glowingEyeGeometry, glowingEyeMaterial);
                    glowingLeftEye.position.x = 0.2;
                    group.add(glowingLeftEye);
                    
                    const glowingRightEye = new THREE.Mesh(glowingEyeGeometry, glowingEyeMaterial);
                    glowingRightEye.position.x = -0.2;
                    group.add(glowingRightEye);
                    
                    // Animation de clignotement
                    group.userData.update = (time) => {
                        const blink = Math.sin(time * 10) > 0.7;
                        glowingLeftEye.visible = glowingRightEye.visible = blink;
                    };
                    break;
                    
                case 1: // Tentacule ondulante
                    const tentacleGeometry = new THREE.CylinderGeometry(0.1, 0.02, 1.5, 8);
                    const tentacleMaterial = new THREE.MeshPhongMaterial({
                        color: 0x660066,
                        specular: 0x555555,
                        shininess: 30
                    });
                    
                    // Cr√©er plusieurs segments pour la tentacule
                    const segments = 5;
                    const tentacleSegments = [];
                    
                    for (let i = 0; i < segments; i++) {
                        const segment = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.1 - (i * 0.02), 0.08 - (i * 0.02), 0.4, 8),
                            tentacleMaterial
                        );
                        segment.position.y = -i * 0.3;
                        if (i > 0) {
                            segment.position.z = 0.1;
                        }
                        
                        if (i > 0) {
                            tentacleSegments[i-1].add(segment);
                        } else {
                            group.add(segment);
                        }
                        
                        tentacleSegments.push(segment);
                    }
                    
                    // Animation d'ondulation
                    group.userData.update = (time) => {
                        tentacleSegments.forEach((segment, index) => {
                            segment.rotation.x = Math.sin(time * 3 + index * 0.5) * 0.3;
                            segment.rotation.z = Math.cos(time * 2 + index * 0.5) * 0.3;
                        });
                    };
                    break;
                    
                case 2: // Silhouette sombre
                    const torsoGeometry = new THREE.BoxGeometry(0.5, 0.8, 0.3);
                    const headGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                    const limbGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
                    
                    const shadowMaterial = new THREE.MeshBasicMaterial({
                        color: 0x000000,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const torso = new THREE.Mesh(torsoGeometry, shadowMaterial);
                    group.add(torso);
                    
                    const head = new THREE.Mesh(headGeometry, shadowMaterial);
                    head.position.y = 0.5;
                    group.add(head);
                    
                    // Membres
                    const arms = [];
                    for (let i = 0; i < 2; i++) {
                        const arm = new THREE.Mesh(limbGeometry, shadowMaterial);
                        arm.position.set(i === 0 ? -0.3 : 0.3, 0.1, 0);
                        arm.rotation.z = i === 0 ? Math.PI/4 : -Math.PI/4;
                        group.add(arm);
                        arms.push(arm);
                    }
                    
                    const legs = [];
                    for (let i = 0; i < 2; i++) {
                        const leg = new THREE.Mesh(limbGeometry, shadowMaterial);
                        leg.position.set(i === 0 ? -0.15 : 0.15, -0.6, 0);
                        group.add(leg);
                        legs.push(leg);
                    }
                    
                    // Animation d'agitation
                    group.userData.update = (time) => {
                        head.rotation.y = Math.sin(time * 2) * 0.5;
                        arms.forEach((arm, index) => {
                            arm.rotation.x = Math.sin(time * 3 + index) * 0.2;
                        });
                        legs.forEach((leg, index) => {
                            leg.rotation.x = Math.sin(time * 2 + index * Math.PI) * 0.1;
                        });
                        
                        group.position.y = Math.sin(time * 2) * 0.05;
                    };
                    break;
                    
                case 3: // Objet flottant lumineux
                    const coreGeometry = new THREE.OctahedronGeometry(0.2, 1);
                    const coreMaterial = new THREE.MeshBasicMaterial({
                        color: 0x88ffff,
                        wireframe: true
                    });
                    
                    const core = new THREE.Mesh(coreGeometry, coreMaterial);
                    group.add(core);
                    
                    // Lumi√®re interne
                    const coreLight = new THREE.PointLight(0x88ffff, 1, 3);
                    core.add(coreLight);
                    
                    // Particules orbitales
                    const particles = [];
                    const particleGeometry = new THREE.SphereGeometry(0.03, 4, 4);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff
                    });
                    
                    for (let i = 0; i < 8; i++) {
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        particle.userData = {
                            orbitRadius: 0.3 + Math.random() * 0.2,
                            orbitSpeed: 0.5 + Math.random() * 2,
                            orbitOffset: Math.random() * Math.PI * 2,
                            elevation: (Math.random() - 0.5) * 0.3
                        };
                        group.add(particle);
                        particles.push(particle);
                    }
                    
                    // Animation d'orbite
                    group.userData.update = (time) => {
                        core.rotation.x = time * 0.5;
                        core.rotation.y = time * 0.8;
                        
                        particles.forEach(particle => {
                            const orbit = particle.userData;
                            particle.position.x = Math.cos(time * orbit.orbitSpeed + orbit.orbitOffset) * orbit.orbitRadius;
                            particle.position.z = Math.sin(time * orbit.orbitSpeed + orbit.orbitOffset) * orbit.orbitRadius;
                            particle.position.y = orbit.elevation + Math.sin(time * 2) * 0.1;
                        });
                        
                        coreLight.intensity = 0.7 + Math.sin(time * 5) * 0.3;
                    };
                    break;
                    
                case 4: // Visage fantomatique
                    const faceGeometry = new THREE.PlaneGeometry(0.6, 0.8);
                    
                    // Cr√©er une texture dynamique pour le visage
                    const canvas = document.createElement('canvas');
                    canvas.width = 256;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    
                    // Fond transparent
                    ctx.fillStyle = 'rgba(0, 0, 0, 0)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Dessiner un visage de base
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(128, 120, 90, 120, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Yeux
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.ellipse(90, 100, 20, 25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.ellipse(166, 100, 20, 25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bouche
                    ctx.beginPath();
                    ctx.ellipse(128, 160, 40, 20, 0, 0, Math.PI);
                    ctx.fill();
                    
                    const faceTexture = new THREE.CanvasTexture(canvas);
                    const faceMaterial = new THREE.MeshBasicMaterial({
                        map: faceTexture,
                        transparent: true,
                        opacity: 0.7,
                        side: THREE.DoubleSide
                    });
                    
                    const face = new THREE.Mesh(faceGeometry, faceMaterial);
                    group.add(face);
                    
                    // Animation du visage
                    group.userData.canvas = canvas;
                    group.userData.texture = faceTexture;
                    group.userData.context = ctx;
                    
                    group.userData.update = (time) => {
                        const ctx = group.userData.context;
                        const canvas = group.userData.canvas;
                        
                        // Effacer et redessiner
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Visage de base
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.beginPath();
                        ctx.ellipse(128, 120, 90, 120, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Yeux anim√©s
                        const eyeScaleY = Math.max(0.1, Math.sin(time * 4) * 0.5 + 0.5);
                        
                        ctx.fillStyle = '#000000';
                        ctx.beginPath();
                        ctx.ellipse(90, 100, 20, 25 * eyeScaleY, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.ellipse(166, 100, 20, 25 * eyeScaleY, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Bouche anim√©e
                        const mouthOpen = 0.3 + Math.sin(time * 2) * 0.2;
                        ctx.beginPath();
                        ctx.ellipse(128, 160, 40, 20 * mouthOpen, 0, 0, Math.PI);
                        ctx.fill();
                        
                        // Mettre √† jour la texture
                        group.userData.texture.needsUpdate = true;
                        
                        // Mouvement flottant
                        group.position.y = Math.sin(time * 1.5) * 0.1;
                        face.rotation.y = Math.sin(time) * 0.2;
                    };
                    break;
                    
                case 5: // Portail √©nerg√©tique
                    const ringGeometry = new THREE.TorusGeometry(0.3, 0.03, 16, 32);
                    const ringMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffaa00,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    group.add(ring);
                    
                    // Ajouter des anneaux suppl√©mentaires
                    const rings = [ring];
                    for (let i = 1; i < 3; i++) {
                        const newRing = new THREE.Mesh(
                            new THREE.TorusGeometry(0.3, 0.02, 16, 32),
                            new THREE.MeshBasicMaterial({
                                color: 0xffaa00,
                                transparent: true,
                                opacity: 0.5 - (i * 0.1)
                            })
                        );
                        rings.push(newRing);
                        group.add(newRing);
                    }
                    
                    // Centre du portail
                    const centerGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                    const centerMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.5
                    });
                    
                    const center = new THREE.Mesh(centerGeometry, centerMaterial);
                    group.add(center);
                    
                    // Lumi√®re du portail
                    const portalLight = new THREE.PointLight(0xffaa00, 1, 3);
                    group.add(portalLight);
                    
                    // Animation du portail
                    group.userData.update = (time) => {
                        rings.forEach((ring, i) => {
                            ring.rotation.x = time * (1 + i * 0.2);
                            ring.rotation.y = time * (0.5 + i * 0.1);
                            
                            const scalePulse = 1 + Math.sin(time * (3 + i)) * 0.1;
                            ring.scale.set(scalePulse, scalePulse, 1);
                        });
                        
                        center.scale.setScalar(0.8 + Math.sin(time * 4) * 0.2);
                        portalLight.intensity = 0.7 + Math.sin(time * 5) * 0.3;
                    };
                    break;
                    
                case 6: // Cr√©ature obscure
                    // Remplacer CapsuleGeometry (non disponible en r128) par une combinaison de cylindre et sph√®res
                    const body = new THREE.Group();
                    
                    // Cylindre pour le corps
                    const bodyMainGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 12);
                    const bodyMaterial = new THREE.MeshPhongMaterial({
                        color: 0x330000,
                        specular: 0x111111,
                        shininess: 50
                    });
                    const bodyMain = new THREE.Mesh(bodyMainGeometry, bodyMaterial);
                    body.add(bodyMain);
                    
                    // Sph√®res pour arrondir les extr√©mit√©s (effet capsule)
                    const topSphereGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                    const topSphere = new THREE.Mesh(topSphereGeometry, bodyMaterial);
                    topSphere.position.y = 0.2;
                    body.add(topSphere);
                    
                    const bottomSphereGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                    const bottomSphere = new THREE.Mesh(bottomSphereGeometry, bodyMaterial);
                    bottomSphere.position.y = -0.2;
                    body.add(bottomSphere);
                    
                    group.add(body);
                    
                    // Membres
                    const limbs = [];
                    const limbMaterial = new THREE.MeshPhongMaterial({
                        color: 0x220000,
                        specular: 0x111111,
                        shininess: 30
                    });
                    
                    for (let i = 0; i < 6; i++) {
                        const limbGeometry = new THREE.CylinderGeometry(0.03, 0.01, 0.5, 5);
                        const limb = new THREE.Mesh(limbGeometry, limbMaterial);
                        
                        const angle = (i / 6) * Math.PI * 2;
                        limb.position.set(
                            Math.cos(angle) * 0.2,
                            0,
                            Math.sin(angle) * 0.2
                        );
                        
                        limb.rotation.x = Math.PI / 2;
                        limb.rotation.z = angle;
                        
                        body.add(limb);
                        limbs.push(limb);
                    }
                    
                    // Yeux
                    const creatureEyeGeometry = new THREE.SphereGeometry(0.03, 8, 8);
                    const creatureEyeMaterial = new THREE.MeshBasicMaterial({
                        color: 0xff0000
                    });
                    
                    const creatureLeftEye = new THREE.Mesh(creatureEyeGeometry, creatureEyeMaterial);
                    creatureLeftEye.position.set(0.1, 0.2, 0.15);
                    body.add(creatureLeftEye);
                    
                    const creatureRightEye = new THREE.Mesh(creatureEyeGeometry, creatureEyeMaterial);
                    creatureRightEye.position.set(-0.1, 0.2, 0.15);
                    body.add(creatureRightEye);
                    
                    // Animation de la cr√©ature
                    group.userData.update = (time) => {
                        body.rotation.y = Math.sin(time) * 0.3;
                        
                        limbs.forEach((limb, i) => {
                            limb.rotation.x = Math.PI/2 + Math.sin(time * 3 + i) * 0.3;
                        });
                        
                        creatureLeftEye.scale.setScalar(0.8 + Math.sin(time * 5) * 0.2);
                        creatureRightEye.scale.setScalar(0.8 + Math.sin(time * 5 + 1) * 0.2);
                    };
                    break;
            }
            
            // Personnaliser l'entit√© selon sa variante
            customizeEntityByVariant(group, entityVariant);
            
            return group;
        }
        
        // Personnaliser l'entit√© en fonction de sa variante (pour la diversit√©)
        function customizeEntityByVariant(entity, variant) {
            // Appliquer des modifications selon le type de variante
            switch(variant) {
                case 1: // Variante plus grande
                    entity.scale.set(1.3, 1.3, 1.3);
                    break;
                case 2: // Variante color√©e diff√©remment
                    entity.traverse(child => {
                        if (child.isMesh && child.material) {
                            // Changer la teinte
                            if (child.material.color) {
                                const color = child.material.color;
                                color.setHSL((color.getHSL({}).h + 0.2) % 1, color.getHSL({}).s, color.getHSL({}).l);
                            }
                        }
                    });
                    break;
                case 3: // Variante d√©form√©e
                    entity.rotation.set(Math.PI/6, 0, Math.PI/8);
                    entity.scale.set(0.9, 1.2, 0.9);
                    break;
                case 4: // Variante avec lueur
                    const glow = new THREE.PointLight(0xaaccff, 0.5, 2);
                    entity.add(glow);
                    break;
                case 5: // Variante multiple (clones)
                    for (let i = 0; i < 2; i++) {
                        const clone = entity.clone();
                        clone.position.set(
                            (Math.random() - 0.5) * 0.5,
                            (Math.random() - 0.5) * 0.5,
                            (Math.random() - 0.5) * 0.5
                        );
                        clone.scale.set(0.7, 0.7, 0.7);
                        entity.add(clone);
                    }
                    break;
                case 6: // Variante plus angoissante/agressive
                    // Augmenter la vitesse d'animation
                    const originalUpdate = entity.userData.update;
                    if (originalUpdate) {
                        entity.userData.update = (time) => {
                            originalUpdate(time * 1.5); // Animation plus rapide
                        };
                    }
                    break;
                // Cas par d√©faut: aucune modification
            }
        }
        
        // Jouer un son myst√©rieux (simulation)
        function playMysterySound(type) {
            // Ici, on ne fait que simuler le son avec console.log
            // Dans une application r√©elle, vous utiliseriez l'API Web Audio
            const sounds = [
                "Chuchotements inqui√©tants",
                "Crissement humide",
                "Respiration profonde",
                "Bourdonnement √©lectrique",
                "G√©missement spectral",
                "Vrombissement √©nerg√©tique",
                "Grognement mena√ßant"
            ];
            
            console.log(`Son: ${sounds[Math.min(type, sounds.length - 1)]}`);
            
            // D√©clencher un √©v√©nement al√©atoire bas√© sur la progression narrative
            if (Math.random() < window.storyProgress * 0.05) {
                setTimeout(() => {
                    console.log("√âv√©nement sonore sp√©cial d√©clench√©!");
                    // Effet suppl√©mentaire possible ici
                }, 1000 + Math.random() * 2000);
            }
        }
        
        // D√©clencher un effet sp√©cial selon le type d'√©l√©ment myst√©rieux
        function triggerMysteryEffect(type, element) {
            // Effets vari√©s selon le type
            switch(type) {
                case 0: // Yeux - Flash rapide de lumi√®re rouge
                    flashLightEffect(0xff0000);
                    break;
                case 1: // Tentacule - Secousse de cam√©ra
                    cameraShakeEffect(0.5);
                    break;
                case 2: // Silhouette - Assombrissement temporaire
                    darkenEffect(1.5);
                    break;
                case 3: // Objet flottant - Pulse lumineux
                    pulseLightEffect(0x88ffff, 3);
                    break;
                case 4: // Visage - Effet de distorsion d'√©cran
                    distortScreenEffect(1);
                    break;
                case 5: // Portail - Mouvement soudain vers le portail
                    pullTowardsEffect(element, 0.5);
                    break;
                case 6: // Cr√©ature - Rugissement et secousse
                    cameraShakeEffect(0.8);
                    flashLightEffect(0xff3300);
                    break;
            }
        }
        
        // ==========================================
        // EFFETS VISUELS
        // ==========================================
        
        // Flash de lumi√®re
        function flashLightEffect(color, intensity = 1.5) {
            // Ne pas cr√©er un nouvel √©l√©ment √† chaque fois, r√©utiliser l'existant
            let flashOverlay = document.getElementById('flash-overlay');
            if (!flashOverlay) {
                flashOverlay = document.createElement('div');
                flashOverlay.id = 'flash-overlay';
                flashOverlay.style.position = 'fixed';
                flashOverlay.style.top = '0';
                flashOverlay.style.left = '0';
                flashOverlay.style.width = '100%';
                flashOverlay.style.height = '100%';
                flashOverlay.style.pointerEvents = 'none';
                flashOverlay.style.zIndex = '990';
                flashOverlay.style.transition = 'opacity 0.1s ease-in, opacity 0.3s ease-out';
                document.body.appendChild(flashOverlay);
            }
            
            flashOverlay.style.backgroundColor = new THREE.Color(color).getStyle();
            flashOverlay.style.opacity = '0';
            
            // Animation simplifi√©e pour √©viter les empilements de setTimeout
            window.requestAnimationFrame(() => {
                flashOverlay.style.opacity = '0.3'; // R√©duit pour moins de charge visuelle
                
                setTimeout(() => {
                    flashOverlay.style.opacity = '0';
                }, 100);
            });
        }
        
        // Secousse de cam√©ra
        function cameraShakeEffect(intensity) {
            const originalPosition = {
                x: window.camera.position.x,
                y: window.camera.position.y,
                z: window.camera.position.z
            };
            
            let duration = 0;
            const maxDuration = 1; // dur√©e en secondes
            
            function shake() {
                if (duration < maxDuration) {
                    duration += 0.05;
                    
                    // Appliquer un d√©placement al√©atoire √† la cam√©ra
                    window.camera.position.x = originalPosition.x + (Math.random() - 0.5) * intensity;
                    window.camera.position.y = originalPosition.y + (Math.random() - 0.5) * intensity;
                    
                    requestAnimationFrame(shake);
                } else {
                    // Remettre la cam√©ra √† sa position d'origine
                    window.camera.position.x = originalPosition.x;
                    window.camera.position.y = originalPosition.y;
                    window.camera.position.z = originalPosition.z;
                }
            }
            
            shake();
        }
        
        // Assombrissement de la sc√®ne
        function darkenEffect(duration) {
            // Stocker les intensit√©s lumineuses originales
            const lights = [];
            window.scene.traverse(obj => {
                if (obj instanceof THREE.Light) {
                    lights.push({
                        light: obj,
                        originalIntensity: obj.intensity
                    });
                    obj.intensity *= 0.2; // R√©duire fortement l'intensit√©
                }
            });
            
            // Restaurer apr√®s un d√©lai
            setTimeout(() => {
                lights.forEach(item => {
                    item.light.intensity = item.originalIntensity;
                });
            }, duration * 1000);
        }
        
        // Effet de pulse lumineux
        function pulseLightEffect(color, pulseCount) {
            const pulseLight = new THREE.PointLight(color, 0, 10);
            pulseLight.position.copy(window.boat.position);
            window.scene.add(pulseLight);
            
            let currentPulse = 0;
            
            function pulse() {
                if (currentPulse < pulseCount) {
                    // Augmenter puis diminuer l'intensit√©
                    let time = 0;
                    const maxTime = 100;
                    
                    function pulseCycle() {
                        if (time < maxTime) {
                            time++;
                            // Courbe sinuso√Ødale pour l'intensit√©
                            const intensity = Math.sin((time / maxTime) * Math.PI) * 2;
                            pulseLight.intensity = intensity;
                            
                            requestAnimationFrame(pulseCycle);
                        } else {
                            currentPulse++;
                            if (currentPulse < pulseCount) {
                                setTimeout(pulse, 200);
                            } else {
                                window.scene.remove(pulseLight);
                            }
                        }
                    }
                    
                    pulseCycle();
                }
            }
            
            pulse();
        }
        
        // Effet de distorsion d'√©cran (simul√©)
        function distortScreenEffect(duration) {
            // Cr√©er un overlay pour simuler la distorsion
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'transparent';
            overlay.style.pointerEvents = 'none';
            overlay.style.zIndex = '1000';
            overlay.style.animation = `distort ${duration}s ease-in-out`;
            
            // Ajouter des styles pour l'animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes distort {
                    0% { backdrop-filter: blur(0px); }
                    25% { backdrop-filter: blur(3px) hue-rotate(45deg); }
                    50% { backdrop-filter: blur(5px) hue-rotate(90deg); }
                    75% { backdrop-filter: blur(3px) hue-rotate(45deg); }
                    100% { backdrop-filter: blur(0px); }
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(overlay);
            
            // Supprimer apr√®s la dur√©e sp√©cifi√©e
            setTimeout(() => {
                document.body.removeChild(overlay);
                document.head.removeChild(style);
            }, duration * 1000);
        }
        
        // Effet d'attraction vers un objet
        function pullTowardsEffect(element, duration) {
            if (!element) return;
            
            const startPosition = {
                x: window.boat.position.x,
                y: window.boat.position.y,
                z: window.boat.position.z
            };
            
            const targetPosition = new THREE.Vector3();
            element.getWorldPosition(targetPosition);
            
            // Calculer un point entre le bateau et la cible
            const pullTarget = new THREE.Vector3(
                startPosition.x + (targetPosition.x - startPosition.x) * 0.4,
                startPosition.y,
                startPosition.z + (targetPosition.z - startPosition.z) * 0.4
            );
            
            let time = 0;
            const pullDuration = duration * 40; // Nombre d'√©tapes pour l'animation
            
            function pull() {
                if (time < pullDuration) {
                    time++;
                    
                    // Courbe d'acc√©l√©ration puis d√©c√©l√©ration
                    let progress = time / pullDuration;
                    if (progress < 0.5) {
                        // Acc√©l√©ration
                        progress = 2 * progress * progress;
                    } else {
                        // D√©c√©l√©ration
                        progress = -1 + (4 - 2 * progress) * progress;
                    }
                    
                    // D√©placer le bateau vers la cible puis retour
                    if (time < pullDuration / 2) {
                        window.boat.position.x = startPosition.x + (pullTarget.x - startPosition.x) * progress;
                        window.boat.position.z = startPosition.z + (pullTarget.z - startPosition.z) * progress;
                    } else {
                        const returnProgress = (time - pullDuration / 2) / (pullDuration / 2);
                        window.boat.position.x = pullTarget.x + (startPosition.x - pullTarget.x) * returnProgress;
                        window.boat.position.z = pullTarget.z + (startPosition.z - pullTarget.z) * returnProgress;
                    }
                    
                    requestAnimationFrame(pull);
                } else {
                    // Assurer que le bateau revient exactement √† sa position initiale
                    window.boat.position.x = startPosition.x;
                    window.boat.position.z = startPosition.z;
                }
            }
            
            pull();
        }
        
        // ==========================================
        // SYST√àME DE NARRATION ET DE DONS
        // ==========================================
        
        // G√©rer un √©l√©ment narratif (indice, √©v√©nement, etc.)
        function handleNarrativeElement(element) {
            switch(element.type) {
                case "clue":
                    revealClue(element.data);
                    break;
                case "mystery":
                    handleMystery(element.data);
                    break;
                case "fragment":
                    showNarrativeFragment(element.data);
                    break;
            }
        }
        
        // R√©v√©ler un indice
        function revealClue(clue) {
            // V√©rifier si l'indice est d√©j√† d√©couvert
            if (window.discoveredClues.includes(clue.id)) return;
            
            // Ajouter l'indice √† la liste des d√©couverts
            window.discoveredClues.push(clue.id);
            
            // Afficher une notification
            showClueNotification(`Indice trouv√©: ${clue.text}`);
            
            // Afficher un message narratif
            showNarrativeMessage(`${clue.text}`, 8000);
            
            // V√©rifier si cet indice compl√®te un myst√®re
            checkMysteryCompletion();
            
            // Effet visuel sp√©cial
            specialEffectForClueType(clue.category);
        }
        
        // Effet sp√©cial selon la cat√©gorie d'indice
        function specialEffectForClueType(category) {
            switch(category) {
                case "sequence":
                    flashLightEffect(0xffffff);
                    break;
                case "phrase":
                    showNarrativeMessage("Les mots semblent r√©sonner dans le tunnel...", 4000);
                    break;
                case "symbol":
                    distortScreenEffect(0.5);
                    break;
                case "date":
                    countdownEffect();
                    break;
                case "location":
                    cameraShakeEffect(0.3);
                    break;
                case "word":
                    // Effet d'inversion de l'√©cran
                    const overlay = document.createElement('div');
                    overlay.style.position = 'fixed';
                    overlay.style.top = '0';
                    overlay.style.left = '0';
                    overlay.style.width = '100%';
                    overlay.style.height = '100%';
                    overlay.style.backgroundColor = 'transparent';
                    overlay.style.transform = 'scaleX(-1)';
                    overlay.style.zIndex = '1000';
                    document.body.appendChild(overlay);
                    
                    setTimeout(() => {
                        document.body.removeChild(overlay);
                    }, 3000);
                    break;
                case "pattern":
                    pulseLightEffect(0xaaffaa, 5);
                    break;
                case "name":
                    showNarrativeMessage("Ce nom semble important...", 4000);
                    flashLightEffect(0xffaaff);
                    break;
                case "math":
                    countdownEffect();
                    break;
                case "audio":
                    console.log("Son: Voix distordue myst√©rieuse");
                    break;
                case "cipher":
                    showNarrativeMessage("Ces lettres forment un code...", 4000);
                    break;
            }
        }
        
        // Afficher une notification d'indice trouv√©
        function showClueNotification(text) {
            const notification = document.getElementById('clue-notification');
            notification.textContent = text;
            notification.classList.add('visible');
            
            setTimeout(() => {
                notification.classList.remove('visible');
            }, 5000);
        }
        
        // V√©rifier si un myst√®re est compl√©t√©
        function checkMysteryCompletion() {
            STORY_ELEMENTS.mysteries.forEach(mystery => {
                if (!mystery.solved) {
                    // V√©rifier si tous les indices requis sont d√©couverts
                    const allCluesFound = mystery.requiredClues.every(
                        clueId => window.discoveredClues.includes(clueId)
                    );
                    
                    if (allCluesFound) {
                        // Marquer le myst√®re comme r√©solu
                        mystery.solved = true;
                        window.solvedMysteries++;
                        
                        // Mettre √† jour l'affichage
                        document.getElementById('solved-mysteries').textContent = 
                            `${window.solvedMysteries}/${STORY_ELEMENTS.mysteries.length}`;
                        
                        // Afficher un message
                        showNarrativeMessage(`Myst√®re r√©solu: ${mystery.title} - ${mystery.reward}`, 10000);
                        
                        // D√©clencher un √©v√©nement sp√©cial
                        triggerSpecialEvent();
                    }
                }
            });
        }
        
        // Afficher un message narratif plus √©l√©gant avec optimisation
        function showNarrativeMessage(text, duration = 5000) {
            // Limiter les appels intensifs pendant les animations
            // Si nous sommes d√©j√† en train d'afficher un message, mettons celui-ci en file d'attente
            if (window.narrativeMessageActive) {
                // Stocker le message pour l'afficher plus tard
                if (!window.messageQueue) window.messageQueue = [];
                window.messageQueue.push({text, duration});
                return;
            }
            
            window.narrativeMessageActive = true;
            const display = document.getElementById('narrative-display');
            
            // Limiter la longueur du texte pour √©viter les probl√®mes de performance
            if (text.length > 300) {
                text = text.substring(0, 297) + '...';
            }
            
            // D√©terminer le type de message pour un style visuel diff√©rent
            let messageType = 'milestone'; // Type par d√©faut
            let icon = 'üìú'; // Ic√¥ne par d√©faut
            
            if (text.includes('Indice') || text.includes('d√©couvert') || text.includes('r√©v√®le')) {
                messageType = 'discovery';
                icon = 'üîç';
            } else if (text.includes('Myst√®re') || text.includes('√©v√©nement') || text.includes('apparition') || text.includes('distorsion')) {
                messageType = 'event';
                icon = '‚ö°';
            }
            
            // Version simplifi√©e du HTML pour r√©duire la charge de mise en page
            display.innerHTML = `<div>${icon} ${text}</div>`;
            display.setAttribute('data-type', messageType);
            
            // Ajouter imm√©diatement au journal d'exploration (sans doublon)
            addToStoryHistory(messageType, text);
            
            // Affichage avec optimisation
            display.style.opacity = '0'; // Optimisation: √©viter la transition en d√©finissant directement le style
            setTimeout(() => {
                display.classList.add('visible');
                
                setTimeout(() => {
                    display.classList.remove('visible');
                    
                    // Lib√©rer le verrou apr√®s un court d√©lai pour s'assurer que la transition est termin√©e
                    setTimeout(() => {
                        window.narrativeMessageActive = false;
                        
                        // V√©rifier s'il y a des messages en attente
                        if (window.messageQueue && window.messageQueue.length > 0) {
                            const nextMessage = window.messageQueue.shift();
                            showNarrativeMessage(nextMessage.text, nextMessage.duration);
                        }
                    }, 500);
                }, duration);
            }, 50);
        }
        
        // Afficher un fragment narratif
        function showNarrativeFragment(fragment) {
            showNarrativeMessage(fragment, 8000);
        }
        
        // Simuler un don
        function simulateDonation(username, amount) {
            // Ajouter au total des dons
            window.totalDonations += amount;
            
            // Mettre √† jour l'affichage
            updateDonationDisplay();

            // Ajouter le donateur au mur
            addDonorToWall(username, amount);
            
            // V√©rifier si un palier est atteint
                checkMilestoneUnlock(username);

            // √âv√©nement al√©atoire bas√© sur le montant
            if (amount >= 100) {
                triggerSpecialEvent();
            } else if (amount >= 50) {
                revealRandomClue();
            } else if (amount >= 20) {
                // Petit effet visuel
                const effectChoice = Math.floor(Math.random() * 3);
                switch(effectChoice) {
                    case 0:
                        flashLightEffect(0xffff00);
                        break;
                    case 1:
                        pulseLightEffect(0xaaddff, 2);
                        break;
                    case 2:
                        cameraShakeEffect(0.3);
                        break;
                }
            }
            
            // Faire briller la lanterne du bateau pour montrer l'activit√©
            if (window.boat && window.boat.userData.lanternLight) {
                const originalIntensity = window.boat.userData.lanternOriginalIntensity;
                window.boat.userData.lanternLight.intensity = originalIntensity * 2;
                
                setTimeout(() => {
                    window.boat.userData.lanternLight.intensity = originalIntensity;
                }, 1000);
            }
            
            // Mettre √† jour le classement (si n√©cessaire)
            updateLeaderboard(username, amount);
            
            // Mettre √† jour les fen√™tres de d√©tails si elles sont ouvertes
            if (window.detailWindows && window.detailWindows.length > 0) {
                window.sendDataToExplorationDetails();
            }
        }
        
        // Mise √† jour de l'affichage des dons sans mettre √† jour le story-milestone (qui est maintenant cach√©)
        function updateDonationDisplay() {
            document.getElementById('total-donations').textContent = window.totalDonations + ' unit√©s';
            
            // Calculer le pourcentage de progression jusqu'au prochain palier
            const currentMilestone = STORY_MILESTONES[window.currentMilestoneIndex];
            const nextMilestone = STORY_MILESTONES[window.currentMilestoneIndex + 1];
            
            if (nextMilestone) {
                const progress = Math.min(100, (window.totalDonations / nextMilestone.amount) * 100);
                document.getElementById('story-progress').style.width = progress + '%';
                document.getElementById('progress-percent').textContent = Math.floor(progress) + '%';
                document.getElementById('next-milestone-amount').textContent = nextMilestone.amount + ' unit√©s';
                
                // Au lieu d'afficher dans l'√©l√©ment visible, ajoutons-le uniquement au journal
                if (nextMilestone.description && nextMilestone.description !== document.getElementById('story-milestone').textContent) {
                    // Ajouter le jalon au journal seulement lors du changement
                    addToStoryHistory('milestone', `Prochain objectif: ${nextMilestone.description}`);
                }
                
                // Stocker la description, mais ne pas l'afficher
                document.getElementById('story-milestone').textContent = nextMilestone.description;
                
                // Mettre √† jour la variable de progression globale
                window.storyProgress = progress / 100;
            }
        }
        
        // Mettre √† jour l'affichage des paliers narratifs
        function updateMilestoneDisplay() {
            // Mettre √† jour le nombre de myst√®res r√©solus
            const solvedCount = STORY_ELEMENTS.mysteries.filter(mystery => mystery.solved).length;
            document.getElementById('solved-mysteries').textContent = `${solvedCount}/${STORY_ELEMENTS.mysteries.length}`;
            
            // Mettre √† jour l'affichage des dons et progression
            updateDonationDisplay();
            
            // Afficher le palier actuel
            const currentMilestone = STORY_MILESTONES[window.currentMilestoneIndex];
            if (currentMilestone) {
                document.getElementById('story-milestone').textContent = currentMilestone.description;
            }
        }
        
        // Ajouter un donateur au mur des contributeurs
        function addDonorToWall(username, amount) {
            const donorList = document.getElementById('donor-list');
            
            // D√©terminer le niveau du donateur
            let donorTier = DONOR_TIERS.find(tier => 
                amount >= tier.min && amount <= tier.max
            );
            
            if (!donorTier) {
                donorTier = DONOR_TIERS[0]; // Par d√©faut
            }
            
            // Cr√©er l'√©l√©ment
            const donorElement = document.createElement('div');
            donorElement.className = `donor ${donorTier.class}`;
            donorElement.textContent = `${username} (${donorTier.name}): ${amount} unit√©s`;
            
            // Ajouter au d√©but de la liste
            if (donorList.firstChild) {
                donorList.insertBefore(donorElement, donorList.firstChild);
                } else {
                donorList.appendChild(donorElement);
            }
            
            // Limiter √† 10 contributeurs affich√©s
            if (donorList.children.length > 10) {
                donorList.removeChild(donorList.lastChild);
            }
            
            // Animation
            donorElement.style.animation = 'pulse 2s';
        }
        
        // V√©rifier si un palier est atteint
        function checkMilestoneUnlock(username) {
            // V√©rifier si nous avons atteint le prochain palier
            const nextMilestone = STORY_MILESTONES[window.currentMilestoneIndex + 1];
            
            if (nextMilestone && window.totalDonations >= nextMilestone.amount) {
                unlockNextMilestone(username);
            }
        }
        
        // D√©bloquer le prochain palier narratif
        function unlockNextMilestone(username) {
            window.currentMilestoneIndex++;
            const milestone = STORY_MILESTONES[window.currentMilestoneIndex];
            
            if (milestone) {
                // Afficher un message
                showNarrativeMessage(`[${milestone.title}] ${milestone.description}`, 10000);
                
                // D√©clencher la fonction associ√©e
                if (milestone.unlocksFunction) {
                    milestone.unlocksFunction(username);
                }
                
                // Mettre √† jour l'affichage
                updateDonationDisplay();
                
                // Compte √† rebours pour l'√©v√©nement
                countdownEffect(3, () => {
                    triggerSpecialEvent();
                });
            }
        }
        
        // Fonction de compte √† rebours
        function countdownEffect(count = 3, callback) {
            const counterElement = document.getElementById('event-counter') || (() => {
                const el = document.createElement('div');
                el.id = 'event-counter';
                document.body.appendChild(el);
                return el;
            })();
            
            let currentCount = count;
            counterElement.textContent = currentCount;
            counterElement.classList.add('visible');
            
            // Utiliser requestAnimationFrame pour la gestion du temps
            const startTime = performance.now();
            const interval = 1000; // 1 seconde entre chaque compte
            
            function updateCounter(timestamp) {
                const elapsed = timestamp - startTime;
                const newCount = count - Math.floor(elapsed / interval);
                
                if (newCount !== currentCount && newCount >= 0) {
                    currentCount = newCount;
                    counterElement.textContent = currentCount;
                    
                    // Ajouter un effet visuel l√©ger
                    counterElement.style.transform = 'translate(-50%, -50%) scale(1.2)';
                    setTimeout(() => {
                        counterElement.style.transform = 'translate(-50%, -50%) scale(1)';
                    }, 100);
                }
                
                if (newCount >= 0) {
                    requestAnimationFrame(updateCounter);
                } else {
                    counterElement.classList.remove('visible');
                    if (callback) callback();
                }
            }
            
            requestAnimationFrame(updateCounter);
        }
        
        // R√©v√©ler un indice al√©atoire
        function revealRandomClue() {
            // Trouver les indices non d√©couverts
            const availableClues = STORY_ELEMENTS.clues.filter(
                clue => !window.discoveredClues.includes(clue.id)
            );
            
            if (availableClues.length > 0) {
                const randomClue = availableClues[Math.floor(Math.random() * availableClues.length)];
                revealClue(randomClue);
            }
        }
        
        // D√©clencher un √©v√©nement sp√©cial
        function triggerSpecialEvent() {
            // Choisir un √©v√©nement en fonction de la progression
            const eventType = Math.floor(Math.random() * 5);
            
            switch(eventType) {
                case 0: // Apparition d'entit√©
                    spawnSpecialEntity();
                    break;
                case 1: // Blackout
                    darkenEffect(3);
                    setTimeout(() => {
                        showNarrativeMessage("Quelque chose se d√©place dans l'obscurit√©...", 5000);
                    }, 1000);
                    break;
                case 2: // Distorsion de r√©alit√©
                    distortScreenEffect(2);
                    setTimeout(() => {
                        showNarrativeFragment(
                            STORY_ELEMENTS.narrativeFragments[
                                Math.floor(Math.random() * STORY_ELEMENTS.narrativeFragments.length)
                            ]
                        );
                    }, 1000);
                    break;
                case 3: // Porte qui s'ouvre spontan√©ment
                    // Trouver une porte visible
                    const visibleDoors = window.doors.filter(door => {
                        const doorPos = new THREE.Vector3();
                        door.getWorldPosition(doorPos);
                        const distance = doorPos.distanceTo(window.boat.position);
                        return distance < 15;
                    });
                    
                    if (visibleDoors.length > 0) {
                        const randomDoor = visibleDoors[Math.floor(Math.random() * visibleDoors.length)];
                        animateDoor(randomDoor);
                    }
                    break;
                case 4: // Vote communautaire
                    startVote();
                    break;
            }
        }
        
        // Faire appara√Ætre une entit√© sp√©ciale
        function spawnSpecialEntity() {
            // Position devant le bateau
            const position = new THREE.Vector3(
                window.boat.position.x + (Math.random() - 0.5) * 2,
                WATER_LEVEL + 0.5 + Math.random() * 1.5,
                window.boat.position.z + 10 + Math.random() * 5
            );
            
            // Type d'entit√© avanc√© bas√© sur la progression narrative
            let entityType;
            
            if (window.storyProgress < 0.2) {
                entityType = Math.floor(Math.random() * 3); // Entit√©s basiques au d√©but
            } else if (window.storyProgress < 0.5) {
                entityType = Math.floor(Math.random() * 5); // Plus de vari√©t√©
            } else {
                // Utiliser seulement les types 0-5 pour √©viter le type 6 (qui peut utiliser CapsuleGeometry)
                entityType = Math.floor(Math.random() * 6); 
                
                // Chance pour une entit√© boss avec progression √©lev√©e
                if (window.storyProgress > 0.8 && Math.random() < 0.3) {
                    return spawnBossEntity();
                }
            }
            
            // Variante bas√©e sur l'avancement de l'histoire
            const entityVariant = Math.min(6, Math.floor(window.storyProgress * 10));
            
            try {
                const entity = createMysteryElement(entityType, entityVariant);
                entity.position.copy(position);
                
                // Orientation vers le bateau
                entity.lookAt(window.boat.position);
                
                window.scene.add(entity);
                
                // Stocker dans la liste des √©l√©ments myst√©rieux
                window.mysteryElements[entity.uuid] = entity;
                
                // Afficher un message selon le type
                const messages = [
                    "Des yeux brillent dans l'obscurit√©...",
                    "Quelque chose s'agite sous la surface...",
                    "Une silhouette se tient immobile, observant...",
                    "Un objet √©trange flotte dans l'air...",
                    "Est-ce un visage qui vous regarde?",
                    "Une br√®che √©nerg√©tique s'ouvre devant vous...",
                    "Une cr√©ature √©merge des profondeurs..."
                ];
                
                showNarrativeMessage(messages[entityType], 5000);
                
                // Faire dispara√Ætre apr√®s un certain temps
                setTimeout(() => {
                    // Animation de disparition
                    let opacity = 1;
                    const fadeInterval = setInterval(() => {
                        opacity -= 0.05;
                        
                        entity.traverse(child => {
                            if (child.material && child.material.opacity !== undefined) {
                                child.material.transparent = true;
                                child.material.opacity = opacity;
                            }
                        });
                        
                        if (opacity <= 0) {
                            clearInterval(fadeInterval);
                            window.scene.remove(entity);
                            delete window.mysteryElements[entity.uuid];
                        }
                    }, 100);
                }, 10000 + Math.random() * 5000);
                
                return entity;
            } catch (error) {
                console.error("Erreur lors de la cr√©ation d'une entit√©:", error);
                // En cas d'erreur, essayons avec un type d'entit√© plus simple (type 0)
                return spawnSpecialEntity();
            }
        }
        
        // Faire appara√Ætre une entit√© boss
        function spawnBossEntity() {
            // Annoncer l'√©v√©nement
            countdownEffect(5, () => {
                // Assombrir la sc√®ne
                darkenEffect(10);
                
                // Cr√©er l'entit√© boss
                const boss = new THREE.Group();
                
                // Position devant le bateau, plus loin que les entit√©s normales
                boss.position.set(
                    window.boat.position.x,
                    WATER_LEVEL + 2,
                    window.boat.position.z + 20
                );
                
                // Corps principal de l'entit√©
                const bodyGeometry = new THREE.SphereGeometry(2, 16, 16);
                const bodyMaterial = new THREE.MeshPhongMaterial({
                    color: 0x220022,
                    emissive: 0x330033,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.8
                });
                
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                boss.add(body);
                
                // Aura lumineuse
                const auraLight = new THREE.PointLight(0xbb00ff, 3, 15);
                body.add(auraLight);
                
                // Tentacules
                const tentacles = [];
                for (let i = 0; i < 8; i++) {
                    const tentacle = new THREE.Group();
                    
                    const angle = (i / 8) * Math.PI * 2;
                    tentacle.position.set(
                        Math.cos(angle) * 1.5,
                        Math.sin(angle) * 1.5,
                        0
                    );
                    
                    // Segments de tentacule
                    const segments = [];
                    let prevSegment = null;
                    
                    for (let j = 0; j < 6; j++) {
                        const segGeometry = new THREE.CylinderGeometry(
                            0.2 - j * 0.03, 
                            0.17 - j * 0.03, 
                            0.5, 
                            8
                        );
                        
                        const segMaterial = new THREE.MeshPhongMaterial({
                            color: 0x440044,
                            emissive: 0x220022,
                            emissiveIntensity: 0.3
                        });
                        
                        const segment = new THREE.Mesh(segGeometry, segMaterial);
                        segment.rotation.x = Math.PI / 2;
                        
                        if (prevSegment) {
                            segment.position.z = 0.5;
                            prevSegment.add(segment);
                        } else {
                            tentacle.add(segment);
                        }
                        
                        prevSegment = segment;
                        segments.push(segment);
                    }
                    
                    boss.add(tentacle);
                    tentacles.push({
                        main: tentacle,
                        segments: segments,
                        angle: angle,
                        speed: 0.5 + Math.random() * 1
                    });
                }
                
                // Yeux
                for (let i = 0; i < 3; i++) {
                    const angle = (i / 3) * Math.PI * 2;
                    const radius = 1.2;
                    
                    const eyeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                    const eyeMaterial = new THREE.MeshBasicMaterial({
                        color: 0xff0000
                        // emissive et emissiveIntensity ne sont pas support√©s par MeshBasicMaterial
                    });
                    
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius,
                        1.8 // Plac√© √† l'avant
                    );
                    
                    body.add(eye);
                    
                    // Lumi√®re pour chaque ≈ìil
                    const eyeLight = new THREE.PointLight(0xff0000, 1, 3);
                    eyeLight.position.set(0, 0, 0.2);
                    eye.add(eyeLight);
                }
                
                // Animation
                boss.userData.update = (time) => {
                    // Pulsation du corps
                    const pulse = 1 + Math.sin(time * 2) * 0.1;
                    body.scale.set(pulse, pulse, pulse);
                    
                    // Animation des tentacules
                    tentacles.forEach((tentacle, i) => {
                        const mainAngle = tentacle.angle + time * 0.2;
                        tentacle.main.position.set(
                            Math.cos(mainAngle) * 1.5,
                            Math.sin(mainAngle) * 1.5,
                            0
                        );
                        
                        // Mouvement ondulant des segments
                        tentacle.segments.forEach((segment, j) => {
                            const segAngle = time * tentacle.speed + j * 0.5;
                            segment.rotation.y = Math.sin(segAngle) * 0.5;
                            segment.rotation.z = Math.cos(segAngle) * 0.5;
                        });
                    });
                    
                    // L'entit√© boss suit lentement le bateau
                    const targetX = window.boat.position.x;
                    const targetZ = window.boat.position.z + 15;
                    
                    boss.position.x += (targetX - boss.position.x) * 0.01;
                    boss.position.z += (targetZ - boss.position.z) * 0.01;
                    
                    // Variation d'intensit√© lumineuse
                    auraLight.intensity = 2 + Math.sin(time * 5) * 1;
                };
                
                // Ajouter √† la sc√®ne
                window.scene.add(boss);
                window.mysteryElements[boss.uuid] = boss;
                
                // Message dramatique
                showNarrativeMessage("Une pr√©sence ancienne a senti votre intrusion...", 8000);
                
                // Faire dispara√Ætre apr√®s un temps plus long
                setTimeout(() => {
                    // Animation de disparition spirale
                    let opacity = 1;
                    let scale = 1;
                    const fadeInterval = setInterval(() => {
                        opacity -= 0.02;
                        scale += 0.1;
                        
                        boss.scale.set(scale, scale, scale);
                        
                        boss.traverse(child => {
                            if (child.material && child.material.opacity !== undefined) {
                                child.material.transparent = true;
                                child.material.opacity = opacity;
                            }
                        });
                        
                        boss.rotation.z += 0.1;
                        
                        if (opacity <= 0) {
                            clearInterval(fadeInterval);
                            window.scene.remove(boss);
                            delete window.mysteryElements[boss.uuid];
                        }
                    }, 100);
                }, 30000);
                
                return boss;
            });
            
            showNarrativeMessage("Quelque chose d'imposant approche...", 5000);
        }
        
        // D√©marrer un vote communautaire
        function startVote() {
            // V√©rifier s'il y a d√©j√† un vote en cours
            if (window.activeVote) return;
            
            // Types de votes possibles
            const voteTypes = [
                {
                    question: "Quelle porte le voyageur devrait-il ouvrir ensuite?",
                    options: [
                        "Porte avec symbole spirale",
                        "Porte rouge clignotante",
                        "Porte avec marques de griffes"
                    ]
                },
                {
                    question: "Quelle direction explorer?",
                    options: [
                        "Vers les profondeurs",
                        "Vers le couloir √©troit",
                        "Vers la lumi√®re distante"
                    ]
                },
                {
                    question: "Comment interagir avec l'entit√©?",
                    options: [
                        "L'observer √† distance",
                        "Tenter de communiquer",
                        "Fuir imm√©diatement"
                    ]
                }
            ];
            
            // Choisir un type de vote al√©atoire
            const voteType = voteTypes[Math.floor(Math.random() * voteTypes.length)];
            
            // Initialiser le vote
            window.activeVote = {
                question: voteType.question,
                options: voteType.options.map(option => ({ text: option, votes: 0 })),
                timeRemaining: 180, // 3 minutes
                totalVotes: 0
            };
            
            // Mettre √† jour l'interface du vote
            const votePanel = document.getElementById('vote-panel');
            const voteQuestion = document.getElementById('vote-question');
            const voteTimer = document.getElementById('vote-timer');
            
            voteQuestion.textContent = voteType.question;
            
            // Mettre √† jour les options de vote
            const voteOptions = votePanel.querySelectorAll('.vote-option');
            voteOptions.forEach((option, index) => {
                const optionText = option.querySelector('span:first-child');
                const optionPercent = option.querySelector('span:last-child');
                const optionFill = option.querySelector('.vote-fill');
                
                if (index < voteType.options.length) {
                    optionText.textContent = voteType.options[index];
                    optionPercent.textContent = "0%";
                    optionFill.style.width = "0%";
                    option.setAttribute('data-option', index);
                    option.style.display = 'block';
                } else {
                    option.style.display = 'none';
                }
            });
            
            // Afficher le panneau
            votePanel.style.display = 'block';
            
            // Annoncer le vote
            showNarrativeMessage(`Vote communautaire: ${voteType.question}`, 8000);
            
            // D√©marrer le compte √† rebours
            const timerInterval = setInterval(() => {
                window.activeVote.timeRemaining--;
                
                const minutes = Math.floor(window.activeVote.timeRemaining / 60);
                const seconds = window.activeVote.timeRemaining % 60;
                voteTimer.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                if (window.activeVote.timeRemaining <= 0) {
                    clearInterval(timerInterval);
                    endVote();
                }
            }, 1000);
            
            // Ajouter quelques votes initiaux
            for (let i = 0; i < 30; i++) {
                setTimeout(() => {
                    const randomOption = Math.floor(Math.random() * voteType.options.length);
                    voteForOption(randomOption);
                }, Math.random() * 10000);
            }
        }
        
        // Voter pour une option
        function voteForOption(optionIndex) {
            if (!window.activeVote) return;
            
            // Ajouter le vote
            window.activeVote.options[optionIndex].votes++;
            window.activeVote.totalVotes++;
            
            // Mettre √† jour l'affichage
            updateVoteDisplay();
        }
        
        // Mettre √† jour l'affichage du vote
        function updateVoteDisplay() {
            if (!window.activeVote) return;
            
            const votePanel = document.getElementById('vote-panel');
            const voteOptions = votePanel.querySelectorAll('.vote-option');
            
            voteOptions.forEach((option, index) => {
                if (index >= window.activeVote.options.length) return;
                
                const optionData = window.activeVote.options[index];
                const percent = window.activeVote.totalVotes === 0 ? 
                    0 : Math.round((optionData.votes / window.activeVote.totalVotes) * 100);
                
                const optionPercent = option.querySelector('span:last-child');
                const optionFill = option.querySelector('.vote-fill');
                
                optionPercent.textContent = `${percent}%`;
                optionFill.style.width = `${percent}%`;
            });
        }
        
        // Terminer un vote
        function endVote() {
            if (!window.activeVote) return;
            
            // Trouver l'option gagnante
            let winningIndex = 0;
            let maxVotes = 0;
            
            window.activeVote.options.forEach((option, index) => {
                if (option.votes > maxVotes) {
                    maxVotes = option.votes;
                    winningIndex = index;
                }
            });
            
            const winningOption = window.activeVote.options[winningIndex];
            
            // Annoncer le r√©sultat
            showNarrativeMessage(`Le vote est termin√©! R√©sultat: "${winningOption.text}" (${Math.round((winningOption.votes / window.activeVote.totalVotes) * 100)}%)`, 8000);
            
            // Ex√©cuter l'action correspondante
            executeVoteResult(window.activeVote.question, winningOption.text);
            
            // Masquer le panneau de vote
            document.getElementById('vote-panel').style.display = 'none';
            
            // R√©initialiser le vote actif
            window.activeVote = null;
        }
        
        // Ex√©cuter le r√©sultat d'un vote
        function executeVoteResult(question, result) {
            // Actions en fonction du type de question
            if (question.includes("porte")) {
                // Recherche des portes correspondantes
                let matchingDoors = [];
                
                if (result.includes("spirale")) {
                    matchingDoors = window.doors.filter(door => 
                        door.userData.doorSymbol === "symbol" &&
                        door.userData.symbolType === 1
                    );
                } else if (result.includes("rouge")) {
                    matchingDoors = window.doors.filter(door => 
                        door.userData.doorSymbol === "blood"
                    );
                } else if (result.includes("griffes")) {
                    matchingDoors = window.doors.filter(door => 
                        door.userData.doorSymbol === "claw"
                    );
                }
                
                // Si on trouve une porte correspondante, l'ouvrir
                if (matchingDoors.length > 0) {
                    const doorToOpen = matchingDoors[Math.floor(Math.random() * matchingDoors.length)];
                    
                    // D√©placer le bateau vers la porte
                    moveBoatTowards(doorToOpen, () => {
                        animateDoor(doorToOpen);
                    });
                } else {
                    // Aucune porte trouv√©e, en cr√©er une
                    showNarrativeMessage("Une nouvelle porte appara√Æt...", 5000);
                    
                    setTimeout(() => {
                        spawnSpecialDoor(result);
                    }, 2000);
                }
            } else if (question.includes("direction")) {
                // Changer la direction d'exploration
                if (result.includes("profondeurs")) {
                    // Acc√©l√©rer vers l'avant
                    window.boatSpeed = 0.2;
                    setTimeout(() => {
                        window.boatSpeed = 0.05;
                    }, 10000);
                    
                    // Effet visuel d'acc√©l√©ration
                    distortScreenEffect(0.5);
                    
                } else if (result.includes("couloir")) {
                    // Se diriger vers un passage plus √©troit
                    createNarrowPassage();
                    
                } else if (result.includes("lumi√®re")) {
                    // Cr√©er une zone lumineuse distante
                    createDistantLight();
                }
            } else if (question.includes("entit√©")) {
                // Interaction avec une entit√©
                const entity = spawnSpecialEntity();
                
                if (result.includes("observer")) {
                    // L'entit√© reste √† distance et fait des mouvements lents
                    entity.userData.behavior = "observe";
                    showNarrativeMessage("L'entit√© semble curieuse, vous observant √† distance...", 5000);
                    
                } else if (result.includes("communiquer")) {
                    // L'entit√© s'approche et "parle"
                    entity.userData.behavior = "communicate";
                    
                    moveEntityTowards(entity, window.boat.position, 5, () => {
                        showNarrativeFragment(
                            STORY_ELEMENTS.narrativeFragments[
                                Math.floor(Math.random() * STORY_ELEMENTS.narrativeFragments.length)
                            ]
                        );
                        
                        // Effet de communication
                        pulseLightEffect(0xaaffff, 5);
                    });
                    
                } else if (result.includes("fuir")) {
                    // L'entit√© devient mena√ßante et poursuit
                    entity.userData.behavior = "chase";
                    
                    showNarrativeMessage("Vous tentez de fuir, mais l'entit√© vous poursuit rapidement!", 5000);
                    
                    // Animation de poursuite
                    const chaseInterval = setInterval(() => {
                        moveEntityTowards(entity, window.boat.position, 2, null);
                        
                        // Si l'entit√© est trop proche, effet de secousse
                        const distance = entity.position.distanceTo(window.boat.position);
                        if (distance < 3) {
                            cameraShakeEffect(0.5);
                            flashLightEffect(0xff0000);
                        }
                    }, 500);
                    
                    // Arr√™ter la poursuite apr√®s un moment
                    setTimeout(() => {
                        clearInterval(chaseInterval);
                    }, 15000);
                }
            }
        }
        
        // D√©placer le bateau vers une cible
        function moveBoatTowards(target, callback = null) {
            const targetPosition = new THREE.Vector3();
            target.getWorldPosition(targetPosition);
            
            // Calculer un point d'arr√™t √† une distance raisonnable
            const direction = new THREE.Vector3().subVectors(targetPosition, window.boat.position).normalize();
            const stopPosition = new THREE.Vector3().copy(targetPosition).sub(direction.multiplyScalar(3));
            
            const originalSpeed = window.boatSpeed;
            let moving = true;
            
            // Animation de d√©placement
            function moveStep() {
                if (!moving) return;
                
                // Calculer la direction vers la cible
                const currentDirection = new THREE.Vector3().subVectors(stopPosition, window.boat.position).normalize();
                
                // Mettre √† jour la position du bateau
                window.boat.position.x += currentDirection.x * 0.1;
                window.boat.position.z += currentDirection.z * 0.1;
                
                // Orienter le bateau vers la cible
                window.boat.rotation.y = Math.atan2(currentDirection.x, currentDirection.z);
                
                // V√©rifier si on est arriv√©
                const distance = window.boat.position.distanceTo(stopPosition);
                if (distance < 0.5) {
                    moving = false;
                    window.boatSpeed = originalSpeed;
                    
                    if (callback) setTimeout(callback, 500);
                } else {
                    requestAnimationFrame(moveStep);
                }
            }
            
            // D√©marrer l'animation
            moveStep();
        }
        
        // D√©placer une entit√© vers une position
        function moveEntityTowards(entity, targetPosition, speed = 3, callback = null) {
            // Calculer la direction
            const direction = new THREE.Vector3().subVectors(targetPosition, entity.position).normalize();
            
            // D√©placer l'entit√©
            entity.position.x += direction.x * (0.05 * speed);
            entity.position.z += direction.z * (0.05 * speed);
            
            // Orienter l'entit√© vers la cible
            entity.lookAt(targetPosition);
            
            // V√©rifier si on est arriv√©
            const distance = entity.position.distanceTo(targetPosition);
            if (distance < 1 && callback) {
                callback();
            }
        }
        
        // Cr√©er un passage √©troit
        function createNarrowPassage() {
            // Message narratif
            showNarrativeMessage("Le tunnel se r√©tr√©cit devant vous...", 5000);
            
            // Cr√©er un segment sp√©cial qui se r√©tr√©cit
            const segment = new THREE.Group();
            segment.position.z = window.boat.position.z + 30; // Plus loin devant
            
            // Tunnel conique qui se r√©tr√©cit
            const tunnelGeometry = new THREE.CylinderGeometry(
                TUNNEL_RADIUS, TUNNEL_RADIUS * 0.6, TUNNEL_LENGTH, 16, 8, true
            );
            const tunnelMaterial = new THREE.MeshPhongMaterial({
                color: 0x222222, 
                side: THREE.BackSide
            });
            const tunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
            tunnel.rotation.x = Math.PI / 2;
            segment.add(tunnel);
            
            // Sol/eau au centre
            const waterGeometry = new THREE.PlaneGeometry(
                TUNNEL_RADIUS * 1.2, TUNNEL_LENGTH
            );
            const waterMaterial = new THREE.MeshPhongMaterial({
                color: 0x004466,
                transparent: true,
                opacity: 0.7
            });
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = WATER_LEVEL;
            segment.add(water);
            
            // Lumi√®res plus sombres
            for (let z = 0; z < TUNNEL_LENGTH; z += 3) {
                const zPos = z - TUNNEL_LENGTH / 2;
                
                const light = new THREE.PointLight(0x443333, 0.3, 3);
                light.position.set(0, 0, zPos);
                segment.add(light);
            }
            
            window.scene.add(segment);
            
            // Ajouter des effets de passage
            setTimeout(() => {
                // Son d'√©coulement d'eau
                console.log("Son: √âcoulement d'eau acc√©l√©r√©");
                
                // D√©placement automatique
                window.boatSpeed = 0.1;
                setTimeout(() => {
                    window.boatSpeed = 0.05;
                    
                    // R√©v√©ler un indice apr√®s le passage
                    revealRandomClue();
                }, 8000);
            }, 2000);
        }
        
        // Cr√©er une lumi√®re distante
        function createDistantLight() {
            // Message narratif
            showNarrativeMessage("Une lueur appara√Æt au loin...", 5000);
            
            // Cr√©er un point lumineux au loin
            const lightPosition = new THREE.Vector3(
                window.boat.position.x + (Math.random() - 0.5) * 2,
                WATER_LEVEL + 1.5,
                window.boat.position.z + 50
            );
            
            // Lumi√®re distante
            const distantLight = new THREE.PointLight(0xffffaa, 2, 50);
            distantLight.position.copy(lightPosition);
            window.scene.add(distantLight);
            
            // Halo visuel
            const haloGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const haloMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffaa,
                transparent: true,
                opacity: 0.7
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.position.copy(lightPosition);
            window.scene.add(halo);
            
            // Pulse animation
            halo.userData.update = (time) => {
                const pulse = 1 + Math.sin(time * 3) * 0.3;
                halo.scale.set(pulse, pulse, pulse);
                distantLight.intensity = 1.5 + Math.sin(time * 3) * 0.5;
            };
            
            // Ajouter √† la liste des √©l√©ments myst√©rieux pour l'animation
            window.mysteryElements[halo.uuid] = halo;
            
            // D√©placer le bateau automatiquement vers la lumi√®re
            setTimeout(() => {
                // Acc√©l√©rer le bateau
                window.boatSpeed = 0.12;
                
                // Attendre que le bateau s'approche
                const checkInterval = setInterval(() => {
                    const distance = halo.position.distanceTo(window.boat.position);
                    
                    if (distance < 10) {
                        clearInterval(checkInterval);
                        window.boatSpeed = 0.05;
                        
                        // Effet de r√©v√©lation
                        flashLightEffect(0xffffaa);
                        distortScreenEffect(1);
                        
                        // Faire dispara√Ætre la lumi√®re
                        let scale = 1;
                        const fadeInterval = setInterval(() => {
                            scale += 0.2;
                            halo.scale.set(scale, scale, scale);
                            haloMaterial.opacity -= 0.05;
                            distantLight.intensity -= 0.1;
                            
                            if (haloMaterial.opacity <= 0) {
                                clearInterval(fadeInterval);
                                window.scene.remove(halo);
                                window.scene.remove(distantLight);
                                delete window.mysteryElements[halo.uuid];
                                
                                // R√©compense
                                revealRandomClue();
                                showNarrativeMessage("La lumi√®re r√©v√®le un secret avant de dispara√Ætre...", 5000);
                            }
                        }, 100);
                    }
                }, 500);
            }, 3000);
        }
        
        // Cr√©er une porte sp√©ciale bas√©e sur un r√©sultat de vote
        function spawnSpecialDoor(doorType) {
            // Position visible devant le bateau
            const doorPosition = new THREE.Vector3(
                window.boat.position.x + (Math.random() - 0.5) * 3,
                WATER_LEVEL + 1.5,
                window.boat.position.z + 8
            );
            
            // D√©terminer le type de porte
            let doorSymbol = "symbol";
            if (doorType.includes("spirale")) {
                doorSymbol = "symbol";
            } else if (doorType.includes("rouge")) {
                doorSymbol = "blood";
            } else if (doorType.includes("griffes")) {
                doorSymbol = "claw";
            }
            
            // Cr√©er la porte sp√©ciale
            const door = createDoor(true);
            door.position.copy(doorPosition);
            
            // Vertical orientation
            if (doorPosition.x < 0) {
                door.rotation.y = Math.PI/2; // Left side
            } else {
                door.rotation.y = -Math.PI/2; // Right side
            }
            door.rotation.z = 0; // Ensure door is vertical
            
            // Assigner le symbole sp√©cifique
            door.userData.doorSymbol = doorSymbol;
            
            // S'assurer qu'elle contient un indice
            door.userData.containsClue = true;
            
            // Ajouter un indice non d√©couvert
            const availableClues = STORY_ELEMENTS.clues.filter(
                clue => !window.discoveredClues.includes(clue.id)
            );
            
            if (availableClues.length > 0) {
                const randomClue = availableClues[Math.floor(Math.random() * availableClues.length)];
                door.userData.narrativeElement = {
                    type: "clue",
                    data: randomClue
                };
            }
            
            // Enregistrer la porte
            window.doors.push(door);
            window.scene.add(door);
            registerSpecialDoor(door);
            
            // Effet de mat√©rialisation
            door.scale.set(0.1, 0.1, 0.1);
            
            // Animation d'apparition
            let scale = 0.1;
            const appearInterval = setInterval(() => {
                scale += 0.05;
                door.scale.set(scale, scale, scale);
                
                if (scale >= 1) {
                    clearInterval(appearInterval);
                    
                    // Effets visuels
                    flashLightEffect(0xaaffaa);
                    
                    // Attirer l'attention
                    door.traverse(child => {
                        if (child.isMesh && child.material) {
                            const originalColor = child.material.color.clone();
                            
                            // Faire pulser la couleur
                            let pulseTime = 0;
                            const pulseInterval = setInterval(() => {
                                pulseTime += 0.1;
                                
                                // Couleur pulsante
                                const pulseColor = new THREE.Color().copy(originalColor);
                                pulseColor.r += Math.sin(pulseTime * 5) * 0.3;
                                pulseColor.g += Math.sin(pulseTime * 5) * 0.3;
                                pulseColor.b += Math.sin(pulseTime * 5) * 0.3;
                                
                                child.material.color.copy(pulseColor);
                                
                                if (pulseTime > 3) {
                                    clearInterval(pulseInterval);
                                    child.material.color.copy(originalColor);
                                }
                            }, 50);
                        }
                    });
                }
            }, 50);
        }
        
        // ==========================================
        // FONCTIONS POUR LES PALIERS NARRATIFS
        // ==========================================
        
        // D√©bloquer le prologue
        function unlockPrologue(username) {
            showNarrativeMessage("Vous entrez dans les tunnels, ignorant ce qui vous attend...", 8000);
            
            // Ajouter des effets visuels subtils
            pulseLightEffect(0xaaffff, 3);
            
            // Ajuster l'ambiance
            window.scene.fog.density = 0.02;
            
            // R√©v√©ler le premier indice
            setTimeout(revealRandomClue, 5000);
        }
        
        // D√©bloquer le secteur 2
        function unlockSector2(username) {
            showNarrativeMessage("Les formes dans l'eau commencent √† bouger avec intention...", 8000);
            
            // Effet visuel sur l'eau
            window.segments.forEach(segment => {
                if (segment.userData.water) {
                    // Changer la couleur de l'eau
                    segment.userData.water.material.color.set(0x005577);
                }
            });
            
            // Ajouter des ondulations √† l'eau
            window.waterAnimation = true;
            
            // D√©clencher un √©v√©nement sp√©cial
            setTimeout(spawnSpecialEntity, 3000);
        }
        
        // D√©bloquer le secteur 3
        function unlockSector3(username) {
            showNarrativeMessage("Des symboles √©tranges apparaissent sur les portes. Ils semblent former un motif...", 8000);
            
            // Ajouter des symboles √† toutes les portes
            window.doors.forEach(door => {
                if (!door.userData.doorSymbol && Math.random() < 0.3) {
                    door.userData.doorSymbol = "symbol";
                    door.userData.symbolType = Math.floor(Math.random() * 5);
                    addSymbolToDoor(door, door.children.find(child => child.name === "plate" || child instanceof THREE.Mesh));
                }
            });
            
            // Lancer un vote
            setTimeout(startVote, 10000);
        }
        
        // D√©bloquer le secteur 4
        function unlockSector4(username) {
            showNarrativeMessage("L'eau vibre √† intervalles r√©guliers, comme si quelque chose d'√©norme se d√©pla√ßait en dessous...", 8000);
            
            // Cr√©er un effet de tremblement p√©riodique
            window.pulseInterval = setInterval(() => {
                cameraShakeEffect(0.3);
                
                // Sons de vibration
                console.log("Son: Vibration profonde");
                
                // Effet sur l'eau
                window.segments.forEach(segment => {
                    if (segment.userData.water) {
                        segment.userData.water.position.y = WATER_LEVEL + 0.1;
                        
                        setTimeout(() => {
                            segment.userData.water.position.y = WATER_LEVEL;
                        }, 300);
                    }
                });
            }, 15000);
            
            // R√©v√©ler plusieurs indices
            for (let i = 0; i < 2; i++) {
                setTimeout(revealRandomClue, 5000 + i * 15000);
            }
        }
        
        // D√©bloquer la confrontation mineure
        function unlockMinorEntity(username) {
            showNarrativeMessage("Une pr√©sence observe chacun de vos mouvements... Elle se rapproche...", 8000);
            
            // Cr√©er l'entit√© observatrice
            const entityPosition = new THREE.Vector3(
                window.boat.position.x,
                WATER_LEVEL + 1,
                window.boat.position.z + 15
            );
            
            const observer = new THREE.Group();
            observer.position.copy(entityPosition);
            
            // Corps principal - silhouette sombre
            const bodyGeometry = new THREE.SphereGeometry(1, 16, 16);
            const bodyMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.7
            });
            
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.scale.set(1, 1.5, 1);
            observer.add(body);
            
            // Yeux brillants
            const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00
                // emissive et emissiveIntensity ne sont pas support√©s par MeshBasicMaterial
            });
            
            // Trois yeux dispos√©s en triangle
            const eyes = [];
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2;
                const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye.position.set(
                    Math.cos(angle) * 0.3,
                    0.5 + Math.sin(angle) * 0.3,
                    0.8
                );
                
                const eyeLight = new THREE.PointLight(0xffff00, 0.5, 2);
                eyeLight.position.set(0, 0, 0.1);
                eye.add(eyeLight);
                
                body.add(eye);
                eyes.push(eye);
            }
            
            // Animation
            observer.userData.update = (time) => {
                // Mouvement de flottement
                observer.position.y = WATER_LEVEL + 1 + Math.sin(time * 0.5) * 0.2;
                
                // Yeux clignotants
                eyes.forEach((eye, i) => {
                    eye.visible = Math.sin(time * 3 + i) > 0;
                });
                
                // L'observateur suit le bateau √† distance
                const targetPosition = new THREE.Vector3(
                    window.boat.position.x,
                    observer.position.y,
                    window.boat.position.z + 15 + Math.sin(time) * 3
                );
                
                observer.position.x += (targetPosition.x - observer.position.x) * 0.01;
                observer.position.z += (targetPosition.z - observer.position.z) * 0.01;
                
                // Orientation vers le bateau
                observer.lookAt(window.boat.position);
            };
            
            // Ajouter √† la sc√®ne
            window.scene.add(observer);
            window.mysteryElements[observer.uuid] = observer;
            
            // Message du donateur qui a d√©bloqu√© cette entit√©
            if (username) {
                showNarrativeMessage(`L'Observateur a √©t√© invoqu√© par ${username}...`, 5000);
            }
            
            // L'observateur reste pendant longtemps
            setTimeout(() => {
                // Disparition
                let opacity = 0.7;
                const fadeInterval = setInterval(() => {
                    opacity -= 0.02;
                    
                    observer.traverse(child => {
                        if (child.material && child.material.opacity !== undefined) {
                            child.material.opacity = opacity;
                        }
                    });
                    
                    if (opacity <= 0) {
                        clearInterval(fadeInterval);
                        window.scene.remove(observer);
                        delete window.mysteryElements[observer.uuid];
                    }
                }, 100);
            }, 120000); // 2 minutes
        }
        
        // D√©bloquer le secteur 5
        function unlockSector5(username) {
            showNarrativeMessage("La r√©alit√© semble se distordre. Des portes m√®nent √† des lieux impossibles...", 8000);
            
            // Effet de distorsion
            distortScreenEffect(3);
            
            // Modifier l'apparence du tunnel
            window.scene.fog.color.set(0x330033);
            window.scene.fog.density = 0.04;
            
            // Modifier la couleur des lumi√®res
            window.scene.traverse(obj => {
                if (obj instanceof THREE.PointLight && obj !== window.boat.userData.lanternLight) {
                    obj.color.set(0xaa55ff);
                }
            });
            
            // Cr√©er des portes sp√©ciales
            setTimeout(() => {
                // Porte qui m√®ne √† une distorsion spatiale
                spawnSpecialDoor("spirale");
            }, 5000);
        }
        
        // D√©bloquer le secteur 6
        function unlockSector6(username) {
            showNarrativeMessage("Les indices commencent √† former un sch√©ma coh√©rent. La v√©rit√© se rapproche...", 8000);
            
            // R√©v√©ler plusieurs indices rapproch√©s
            for (let i = 0; i < 3; i++) {
                setTimeout(revealRandomClue, 2000 + i * 5000);
            }
            
            // Visualisation du sch√©ma
            setTimeout(() => {
                // Cr√©er une visualisation flottante des indices connect√©s
                const patternPosition = new THREE.Vector3(
                    window.boat.position.x,
                    WATER_LEVEL + 1.5,
                    window.boat.position.z + 8
                );
                
                const pattern = new THREE.Group();
                pattern.position.copy(patternPosition);
                
                // Cadre
                const frameGeometry = new THREE.TorusGeometry(1.5, 0.05, 16, 32);
                const frameMaterial = new THREE.MeshBasicMaterial({
                    color: 0xaaaaff,
                    transparent: true,
                    opacity: 0.8
                });
                
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                pattern.add(frame);
                
                // Points repr√©sentant les indices
                const points = [];
                const lines = [];
                
                for (let i = 0; i < window.discoveredClues.length; i++) {
                    const angle = (i / window.discoveredClues.length) * Math.PI * 2;
                    const radius = 1.2;
                    
                    const pointGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                    const pointMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff
                    });
                    
                    const point = new THREE.Mesh(pointGeometry, pointMaterial);
                    point.position.set(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius,
                        0
                    );
                    
                    pattern.add(point);
                    points.push(point);
                    
                    // Ajouter des lignes entre certains points
                    if (i > 0) {
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                            points[i-1].position,
                            point.position
                        ]);
                        
                        const lineMaterial = new THREE.LineBasicMaterial({
                            color: 0xaaaaff,
                            transparent: true,
                            opacity: 0.5
                        });
                        
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        pattern.add(line);
                        lines.push(line);
                    }
                }
                
                // Animation du pattern
                pattern.userData.update = (time) => {
                    // Rotation lente
                    pattern.rotation.z = time * 0.2;
                    
                    // Pulsation des points
                    points.forEach((point, i) => {
                        point.scale.setScalar(0.8 + Math.sin(time * 3 + i) * 0.3);
                    });
                    
                    // Opacit√© des lignes
                    lines.forEach((line, i) => {
                        line.material.opacity = 0.3 + Math.sin(time * 2 + i) * 0.2;
                    });
                };
                
                // Ajouter √† la sc√®ne
                window.scene.add(pattern);
                window.mysteryElements[pattern.uuid] = pattern;
                
                // Faire dispara√Ætre apr√®s un moment
                setTimeout(() => {
                    // Animation de disparition
                    let opacity = 1;
                    let scale = 1;
                    
                    const fadeInterval = setInterval(() => {
                        opacity -= 0.02;
                        scale += 0.05;
                        
                        pattern.scale.set(scale, scale, scale);
                        
                        pattern.traverse(child => {
                            if (child.material && child.material.opacity !== undefined) {
                                child.material.opacity = opacity;
                            }
                        });
                        
                        if (opacity <= 0) {
                            clearInterval(fadeInterval);
                            window.scene.remove(pattern);
                            delete window.mysteryElements[pattern.uuid];
                        }
                    }, 50);
                }, 30000);
            }, 15000);
        }
        
        // D√©bloquer la confrontation majeure
        function unlockMajorEntity(username) {
            showNarrativeMessage("Une pr√©sence ancienne bloque votre chemin. Vous devez l'affronter pour continuer...", 8000);
            
            // Faire appara√Ætre l'entit√© majeure
            setTimeout(() => {
                spawnBossEntity();
            }, 5000);
            
            // Message du donateur qui a d√©bloqu√© cette entit√©
            if (username) {
                showNarrativeMessage(`Le Gardien a √©t√© provoqu√© par ${username}...`, 5000);
            }
        }
        
        // D√©bloquer le secteur 7
        function unlockSector7(username) {
            showNarrativeMessage("Les derniers fragments du myst√®re se d√©voilent. La v√©rit√© est presque √† port√©e...", 8000);
            
            // Effet visuel important
            flashLightEffect(0xffffff);
            distortScreenEffect(2);
            
            // R√©v√©ler tous les indices restants
            STORY_ELEMENTS.clues.forEach(clue => {
                if (!window.discoveredClues.includes(clue.id)) {
                    setTimeout(() => {
                        revealClue(clue);
                    }, Math.random() * 30000); // √âtal√© sur 30 secondes
                }
            });
            
            // Changement d'ambiance majeur
            window.scene.fog.color.set(0x220022);
            window.scene.fog.density = 0.03;
            
            window.scene.background = new THREE.Color(0x110011);
            
            // Modifier la couleur de l'eau
            window.segments.forEach(segment => {
                if (segment.userData.water) {
                    segment.userData.water.material.color.set(0x220044);
                }
            });
        }
        
        // D√©bloquer le finale
        function unlockFinale(username) {
            showNarrativeMessage("La v√©rit√© sur Les Profondeurs est sur le point d'√™tre r√©v√©l√©e...", 8000);
            
            // Compte √† rebours dramatique
            countdownEffect(10, () => {
                // Effet final
                darkenEffect(3);
                
                setTimeout(() => {
                    // Lumi√®re aveuglante
                    const finalLight = new THREE.PointLight(0xffffff, 10, 50);
                    finalLight.position.set(
                        window.boat.position.x,
                        window.boat.position.y + 3,
                        window.boat.position.z + 20
                    );
                    window.scene.add(finalLight);
                    
                    // Message final
                    const finalMessage = `
                        Les Profondeurs n'ont jamais √©t√© un lieu physique, mais une projection mentale collective.
                        
                        Chaque porte ouverte √©tait une fen√™tre vers une conscience diff√©rente.
                        
                        Le sixi√®me cycle s'ach√®ve. Le prochain cycle commence...
                        
                        √Ä suivre dans la Saison 2: "Les R√©sonances"
                    `;
                    
                    showNarrativeMessage(finalMessage, 20000);
                    
                    // Faire dispara√Ætre tout sauf le bateau
                    window.doors.forEach(door => {
                        window.scene.remove(door);
                    });
                    
                    Object.values(window.mysteryElements).forEach(element => {
                        window.scene.remove(element);
                    });
                    
                    // Animation finale
                    window.boatSpeed = 0.2;
                    
                    setTimeout(() => {
                        // √âcran blanc
                        const whiteScreen = document.createElement('div');
                        whiteScreen.style.position = 'fixed';
                        whiteScreen.style.top = '0';
                        whiteScreen.style.left = '0';
                        whiteScreen.style.width = '100%';
                        whiteScreen.style.height = '100%';
                        whiteScreen.style.backgroundColor = 'white';
                        whiteScreen.style.opacity = '0';
                        whiteScreen.style.transition = 'opacity 5s';
                        whiteScreen.style.zIndex = '2000';
                        document.body.appendChild(whiteScreen);
                        
                        setTimeout(() => {
                            whiteScreen.style.opacity = '1';
                            
                            // Cr√©dit de fin
                            setTimeout(() => {
                                whiteScreen.innerHTML = `
                                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: black; font-family: Arial, sans-serif;">
                                        <h1 style="font-size: 36px; margin-bottom: 50px;">Fin de la Saison 1</h1>
                                        <p style="font-size: 24px; margin-bottom: 20px;">Merci √† tous les Explorateurs</p>
                                        <p style="font-size: 18px; margin-bottom: 10px;">Myst√®res r√©solus: ${window.solvedMysteries}/${STORY_ELEMENTS.mysteries.length}</p>
                                        <p style="font-size: 18px; margin-bottom: 10px;">Portes ouvertes: ${window.activatedDoors}</p>
                                        <p style="font-size: 18px; margin-bottom: 50px;">Total des dons: ${window.totalDonations} unit√©s</p>
                                        <p style="font-size: 24px;">Rendez-vous dans la Saison 2...</p>
                                    </div>
                                `;
                            }, 5000);
                        }, 100);
                    }, 10000);
                }, 3000);
            });
        }
        
        // ==========================================
        // BOUCLE D'ANIMATION
        // ==========================================
        
        // Mettre √† jour les √©l√©ments myst√©rieux dans l'animation principale
        function updateMysteryElements(time) {
            // Limiter la mise √† jour aux √©l√©ments visibles ou proches du bateau
            const maxDistance = TUNNEL_LENGTH / 2;  // Ne mettre √† jour que les √©l√©ments √† port√©e visuelle
            
            // Parcourir tous les √©l√©ments myst√©rieux pour les animer
            Object.values(window.mysteryElements).forEach(element => {
                // V√©rifier si l'√©l√©ment est proche du bateau
                if (element.position && window.boat.position) {
                    const dx = element.position.x - window.boat.position.x;
                    const dz = element.position.z - window.boat.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    // Ne mettre √† jour que les √©l√©ments √† port√©e
                    if (distance < maxDistance && element.userData.update) {
                        element.userData.update(time);
                    }
                } else if (element.userData.update) {
                    // Pour les √©l√©ments sans position (ex: effets globaux), mettre √† jour normalement
                    element.userData.update(time);
                }
            });
            
            // Animation de l'eau - limiter aux segments visibles
            if (window.waterAnimation) {
                const boatZ = window.boat.position.z;
                window.segments.forEach(segment => {
                    // Ne mettre √† jour que les segments proches du bateau
                    if (Math.abs(segment.userData.zPosition - boatZ) < maxDistance && segment.userData.water) {
                        segment.userData.water.material.color.lerp(
                            segment.userData.waterBaseColor, 
                            0.05
                        );
                        
                        // Ondulation l√©g√®re
                        segment.userData.water.position.y = 
                            WATER_LEVEL + Math.sin(time * 2 + segment.position.z * 0.1) * 0.05;
                    }
                });
            }
            
            // Animation des lumi√®res murales - limiter aux segments visibles
            window.segments.forEach(segment => {
                // Ne mettre √† jour que les segments proches du bateau
                if (Math.abs(segment.userData.zPosition - window.boat.position.z) < maxDistance) {
                    segment.traverse(obj => {
                        if (obj.userData && obj.userData.flicker && obj.userData.light) {
                            const flickerAmount = Math.sin(time * obj.userData.flickerSpeed) * 0.3 + 0.7;
                            obj.userData.light.intensity = obj.userData.originalIntensity * flickerAmount;
                            
                            // Animation de couleur progressive (moins fr√©quente)
                            if (obj.userData.originalColor && window.frameCount % 6 === 0) {
                                const hue = (time * 0.05) % 1;
                                const newColor = new THREE.Color().setHSL(
                                    hue, 
                                    0.7, 
                                    obj.userData.originalColor.getHSL({}).l
                                );
                                
                                obj.userData.light.color.lerp(newColor, 0.01);
                                
                                if (obj.userData.bulb) {
                                    obj.userData.bulb.material.color.copy(obj.userData.light.color);
                                }
                            }
                        }
                    });
                }
            });
            
            // Animation narrative du bateau
            if (window.boat.userData.lanternLight) {
                const lanternFlicker = 0.8 + Math.sin(time * 5) * 0.2;
                window.boat.userData.lanternLight.intensity = window.boat.userData.lanternOriginalIntensity * lanternFlicker;
            }
        }
        
        // Fonction principale d'animation avec optimisation des performances
        function animate() {
            // Pour mesurer et limiter les performances
            if (!window.frameCounter) window.frameCounter = 0;
            window.frameCounter++;
            
            const currentTime = performance.now();
            if (!window.lastAnimationTime) window.lastAnimationTime = currentTime;
            const deltaTime = (currentTime - window.lastAnimationTime) / 1000; // en secondes
            window.lastAnimationTime = currentTime;
            
            // Limiter le deltaTime max pour √©viter les sauts extr√™mes
            const cappedDeltaTime = Math.min(deltaTime, 0.1);
            
            if (window.boat && window.camera && !window.isPaused) {
                // D√©finir boatPosition pour r√©f√©rencer la position du bateau
                const boatPosition = window.boat.position;
                
                // Toujours avancer le bateau √† une vitesse constante dans l'axe Z
                const boatSpeed = 0.05;
                boatPosition.z += boatSpeed;
                
                // Si on n'a pas de position cible, cr√©er une par d√©faut
                if (!window.boatTargetPosition) {
                    window.boatTargetPosition = {
                        x: boatPosition.x,
                        z: boatPosition.z + 10
                    };
                }
                
                // Si on n'a pas de position pr√©c√©dente, initialiser
                if (!window.previousBoatPosition) {
                    window.previousBoatPosition = {
                        x: boatPosition.x, 
                        z: boatPosition.z - boatSpeed // Position juste avant la position actuelle
                    };
                }
                
                // Mise √† jour moins fr√©quente du pitch/roll du bateau (√©conomise des calculs)
                if (window.frameCounter % 3 === 0) {
                    // Rotation du bateau en fonction de la vitesse
                    const dx = boatPosition.x - window.previousBoatPosition.x;
                    const dz = boatPosition.z - window.previousBoatPosition.z;
                    
                    if (Math.abs(dx) > 0.001 || Math.abs(dz) > 0.001) {
                        const targetRotation = Math.atan2(dx, dz);
                        // Interpolation plus douce pour la rotation
                        window.boat.rotation.y += (targetRotation - window.boat.rotation.y) * Math.min(2 * cappedDeltaTime, 0.1);
                    }
                    
                    // Simuler le mouvement de la mer
                    if (window.canRock) {
                        window.boat.rotation.x = Math.sin(currentTime / 1000) * 0.03;
                        window.boat.rotation.z = Math.sin(currentTime / 1200) * 0.02;
                    }
                    
                    // Mettre √† jour la position pr√©c√©dente
                    window.previousBoatPosition = { x: boatPosition.x, z: boatPosition.z };
                }
                
                // La cam√©ra suit toujours le bateau √† chaque frame pour une exp√©rience fluide
                updateCameraPosition();
                
                // Mise √† jour des myst√®res moins fr√©quente (√©conomise beaucoup de calculs)
                if (window.frameCounter % 5 === 0) {
                    updateMysteryElements(currentTime / 1000); 
                }
                
                // V√©rification de tunnel chaque seconde
                if (window.frameCounter % 60 === 0) {
                    checkTunnel();
                }
                
                // Limiter la mise √† jour du panneau de votes si pr√©sent
                if (window.votePanel && window.frameCounter % 30 === 0) {
                    updateVotePanel();
                }
            }
            
            // Rendre la sc√®ne
            if (window.renderer && window.scene && window.camera) {
                window.renderer.render(window.scene, window.camera);
            }
            
            // Appeler la prochaine frame
            requestAnimationFrame(animate);
        }
        
        // Ajout de la fonction manquante updateCameraPosition
        function updateCameraPosition() {
            if (!window.camera || !window.boat) return;
            
            // Positionner la cam√©ra derri√®re le bateau
            window.camera.position.x = window.boat.position.x;
            window.camera.position.y = window.boat.position.y + 1.5;
            window.camera.position.z = window.boat.position.z - 5;
            
            // Orienter la cam√©ra vers le bateau
            window.camera.lookAt(window.boat.position);
        }
        
        // ==========================================
        // INITIALISATION DE L'APPLICATION
        // ==========================================
        
        // V√©rifier si Three.js est disponible et initialiser l'application
        window.onload = function() {
            if (typeof THREE === 'undefined') {
                document.getElementById('loading').innerHTML = 
                    "<h1>Erreur</h1><p>Impossible de charger Three.js. " +
                    "V√©rifiez votre connexion internet ou essayez un autre navigateur.</p>";
                return;
            }
            
            // Simuler le chargement
            simulateLoading();
            
            // Initialiser l'application apr√®s un d√©lai pour l'√©cran de chargement
            setTimeout(init, 3000);
        };
        
        // ==========================================
        // LEADERBOARD & HISTORIQUE
        // ==========================================
        
        // Initialiser les structures de donn√©es
        window.leaderboard = [];
        window.storyHistory = [];
        
        // Mettre √† jour le leaderboard
        function updateLeaderboard(username, amount) {
            // Assurez-vous que le tableau des contributeurs existe
            if (!window.leaderboard) {
                window.leaderboard = [];
            }
            
            // V√©rifier si l'utilisateur existe d√©j√† dans le classement
            let userExists = false;
            for (let i = 0; i < window.leaderboard.length; i++) {
                if (window.leaderboard[i].username === username) {
                    // Mettre √† jour le montant
                    window.leaderboard[i].amount += amount;
                    window.leaderboard[i].lastDonation = Date.now(); // Ajouter timestamp pour tri r√©cent
                    userExists = true;
                    break;
                }
            }
            
            // Si l'utilisateur n'existe pas, l'ajouter
            if (!userExists) {
                window.leaderboard.push({
                    username: username,
                    amount: amount,
                    lastDonation: Date.now() // Timestamp pour tri r√©cent
                });
            }
            
            // Trier le classement par montant d√©croissant
            window.leaderboard.sort((a, b) => b.amount - a.amount);
            
            // Conserver uniquement les 100 premiers pour le Top 100
            if (window.leaderboard.length > 100) {
                window.leaderboard = window.leaderboard.slice(0, 100);
            }
            
            // Afficher le classement
            renderLeaderboard();
            renderTop100();
            
            // S'assurer que les tableaux sont visibles
            const leaderboardPanel = document.getElementById('leaderboard-panel');
            if (leaderboardPanel.style.display === 'none' || !leaderboardPanel.style.display) {
                leaderboardPanel.style.display = 'block';
            }
            
            // Ne pas afficher le top100 qui fait double emploi
            const top100Panel = document.getElementById('top100-panel');
            if (top100Panel) {
                top100Panel.style.display = 'none';
            }
            
            // Mettre √† jour les fen√™tres de d√©tails si elles sont ouvertes
            if (window.detailWindows && window.detailWindows.length > 0) {
                window.sendDataToExplorationDetails();
            }
        }
        
        // Afficher le leaderboard
        function renderLeaderboard() {
            const leaderboardList = document.getElementById('leaderboard-list');
            if (!leaderboardList) return;
            
            leaderboardList.innerHTML = '';
            
            if (!window.leaderboard || window.leaderboard.length === 0) {
                leaderboardList.innerHTML = '<div class="leaderboard-item">Aucun donateur</div>';
            } else {
                // Wrap content in autoscroll container
                const scrollContainer = document.createElement('div');
                scrollContainer.className = 'autoscroll-container';
                
                const scrollContent = document.createElement('div');
                scrollContent.className = 'autoscroll-content';
                
                // Calculate animation duration based on content length
                const durationInSeconds = Math.max(20, Math.min(60, window.leaderboard.length * 4));
                scrollContent.style.animationDuration = durationInSeconds + 's';
                
                window.leaderboard.forEach((entry, index) => {
                    const item = document.createElement('div');
                    item.className = 'leaderboard-item';
                    item.style.position = 'relative';  // Pour permettre le positionnement absolu du num√©ro
                    
                    const rank = document.createElement('div');
                    rank.className = 'leaderboard-rank';
                    rank.textContent = `#${index + 1}`;
                    
                    const name = document.createElement('div');
                    name.className = 'leaderboard-name';
                    name.textContent = entry.username;
                    
                    const score = document.createElement('div');
                    score.className = 'leaderboard-score';
                    score.textContent = `${entry.amount} unit√©s`;
                    
                    // Num√©ro d'entr√©e global (diff√©rent du rank qui est bas√© sur le score)
                    const entryNumber = document.createElement('div');
                    entryNumber.style.position = 'absolute';
                    entryNumber.style.right = '3px';
                    entryNumber.style.top = '0px';
                    entryNumber.style.fontSize = '7px';
                    entryNumber.style.color = '#777';
                    entryNumber.textContent = `E${index + 1}`;
                    
                    item.appendChild(rank);
                    item.appendChild(name);
                    item.appendChild(score);
                    item.appendChild(entryNumber);
                    
                    scrollContent.appendChild(item);
                });
                
                scrollContainer.appendChild(scrollContent);
                leaderboardList.appendChild(scrollContainer);
            }
        }
        
        // Apr√®s la fonction renderLeaderboard, ajouter la fonction renderTop100
        function renderTop100() {
            const top100List = document.getElementById('top100-list');
            if (!top100List) return;
            
            top100List.innerHTML = '';
            
            if (!window.leaderboard || window.leaderboard.length === 0) {
                top100List.innerHTML = '<div class="top100-item">Aucun donateur</div>';
            } else {
                // Wrap content in autoscroll container
                const scrollContainer = document.createElement('div');
                scrollContainer.className = 'autoscroll-container';
                
                const scrollContent = document.createElement('div');
                scrollContent.className = 'autoscroll-content';
                
                // Calculate animation duration based on content length
                const durationInSeconds = Math.max(30, Math.min(120, window.leaderboard.length * 2));
                scrollContent.style.animationDuration = durationInSeconds + 's';
                
                window.leaderboard.forEach((entry, index) => {
                    if (index < 100) { // Limiter √† 100 entr√©es
                        const item = document.createElement('div');
                        item.className = 'top100-item';
                        
                        const rank = document.createElement('div');
                        rank.className = 'top100-rank';
                        rank.textContent = `#${index + 1}`;
                        
                        const name = document.createElement('div');
                        name.className = 'top100-name';
                        name.textContent = entry.username;
                        
                        const score = document.createElement('div');
                        score.className = 'top100-score';
                        score.textContent = `${entry.amount} unit√©s`;
                        
                        // Num√©ro d'entr√©e global
                        const entryNumber = document.createElement('div');
                        entryNumber.style.position = 'absolute';
                        entryNumber.style.right = '3px';
                        entryNumber.style.top = '0px';
                        entryNumber.style.fontSize = '7px';
                        entryNumber.style.color = '#777';
                        entryNumber.textContent = `E${index + 1}`;
                        
                        item.appendChild(rank);
                        item.appendChild(name);
                        item.appendChild(score);
                        
                        scrollContent.appendChild(item);
                    }
                });
                
                scrollContainer.appendChild(scrollContent);
                top100List.appendChild(scrollContainer);
            }
        }
        
        // Ajouter une entr√©e √† l'historique
        function addToStoryHistory(type, content) {
            if (!window.storyHistory) {
                window.storyHistory = [];
            }
            
            // V√©rification stricte des doublons - √©viter de traiter des messages identiques
            const isDuplicate = window.storyHistory.some(entry => 
                entry.content === content && 
                (Date.now() - entry.rawTimestamp) < 30000 // 30 secondes pour √™tre s√ªr
            );
            
            if (isDuplicate) return;
            
            const now = new Date();
            const entry = {
                type: type,
                content: content,
                timestamp: now.toLocaleTimeString(),
                rawTimestamp: Date.now()
            };
            
            window.storyHistory.unshift(entry);
            
            // Limiter la taille pour √©viter trop de DOM et de m√©moire
            if (window.storyHistory.length > 20) { // R√©duit de 30 √† 20
                window.storyHistory = window.storyHistory.slice(0, 20);
            }
            
            // Optimisation: ne pas rendre le contenu √† chaque fois, mais limiter la fr√©quence
            if (!window.historyRenderTimeout) {
                window.historyRenderTimeout = setTimeout(() => {
                    renderStoryHistory();
                    window.historyRenderTimeout = null;
                    
                    // Mettre √† jour les fen√™tres de d√©tails si elles sont ouvertes
                    if (window.detailWindows && window.detailWindows.length > 0) {
                        window.sendDataToExplorationDetails();
                    }
                }, 500); // Regrouper les mises √† jour en un seul rendu toutes les 500ms
            }
            
            // S'assurer que le panneau est visible
            const historyPanel = document.getElementById('story-history-panel');
            if (historyPanel.style.display === 'none' || !historyPanel.style.display) {
                historyPanel.style.display = 'block';
            }
        }
        
        // Afficher l'historique
        function renderStoryHistory() {
            const historyList = document.getElementById('story-history-list');
            if (!historyList) return;
            
            historyList.innerHTML = '';
            
            if (!window.storyHistory || window.storyHistory.length === 0) {
                historyList.innerHTML = '<div class="history-item">Aucun √©v√©nement enregistr√©</div>';
            } else {
                // Wrap content in autoscroll container
                const scrollContainer = document.createElement('div');
                scrollContainer.className = 'autoscroll-container';
                
                const scrollContent = document.createElement('div');
                scrollContent.className = 'autoscroll-content';
                
                // Calculate animation duration based on content length
                const durationInSeconds = Math.max(20, Math.min(60, window.storyHistory.length * 4));
                scrollContent.style.animationDuration = durationInSeconds + 's';
                
                // En-t√™tes pour les types d'entr√©es
                const typeLabels = {
                    'milestone': 'üìú Progression',
                    'discovery': 'üîç D√©couverte',
                    'event': '‚ö° √âv√©nement'
                };
                
                window.storyHistory.forEach((entry, index) => {
                    const item = document.createElement('div');
                    item.className = `history-item history-item-${entry.type}`;
                    
                    // Ajouter un num√©ro d'entr√©e
                    const entryNumber = document.createElement('div');
                    entryNumber.className = 'history-number';
                    entryNumber.textContent = `#${index + 1}`;
                    entryNumber.style.position = 'absolute';
                    entryNumber.style.right = '5px';
                    entryNumber.style.top = '3px';
                    entryNumber.style.fontSize = '8px';
                    entryNumber.style.color = '#aaa';
                    entryNumber.style.fontWeight = 'bold';
                    
                    const timestamp = document.createElement('div');
                    timestamp.className = 'history-timestamp';
                    timestamp.textContent = entry.timestamp;
                    
                    const typeLabel = document.createElement('div');
                    typeLabel.style.fontWeight = 'bold';
                    typeLabel.style.fontSize = '10px';
                    typeLabel.style.marginBottom = '2px';
                    typeLabel.textContent = typeLabels[entry.type] || 'Message';
                    
                    const content = document.createElement('div');
                    content.textContent = entry.content;
                    
                    item.appendChild(entryNumber);
                    item.appendChild(timestamp);
                    item.appendChild(typeLabel);
                    item.appendChild(content);
                    
                    scrollContent.appendChild(item);
                });
                
                scrollContainer.appendChild(scrollContent);
                historyList.appendChild(scrollContainer);
            }
        }
        
        // Modifier les fonctions existantes pour enregistrer dans l'historique
        
        // Surcharger la fonction originale pour ajouter l'entr√©e au tableau
        const originalUnlockNextMilestone = unlockNextMilestone;
        unlockNextMilestone = function(username) {
            originalUnlockNextMilestone(username);
            
            const milestone = STORY_MILESTONES[window.currentMilestoneIndex];
            addToStoryHistory('milestone', `[${milestone.title}] ${milestone.description}`);
        };
        
        // Surcharger la fonction de r√©v√©lation d'indice
        const originalRevealClue = revealClue;
        revealClue = function(clue) {
            originalRevealClue(clue);
            addToStoryHistory('discovery', `Indice d√©couvert: ${clue.text}`);
        };
        
        // Surcharger la fonction d'√©v√©nements sp√©ciaux
        const originalTriggerSpecialEvent = triggerSpecialEvent;
        triggerSpecialEvent = function() {
            const eventType = Math.floor(Math.random() * 5);
            const eventNames = [
                "Apparition myst√©rieuse", 
                "Blackout soudain", 
                "Distorsion de r√©alit√©",
                "Porte qui s'ouvre",
                "Vote communautaire"
            ];
            
            addToStoryHistory('event', `√âv√©nement: ${eventNames[eventType]}`);
            return originalTriggerSpecialEvent();
        };
        
        // Modifier la fonction simulateDonation pour mettre √† jour le leaderboard
        const originalSimulateDonation = simulateDonation;
        simulateDonation = function(username, amount) {
            originalSimulateDonation(username, amount);
            updateLeaderboard(username, amount);
        };
        
        // Fonction pour v√©rifier les dons externes (via localStorage)
        function checkExternalDonations() {
            const latestDonation = localStorage.getItem('latestDonation');
            if (latestDonation) {
                try {
                    const donation = JSON.parse(latestDonation);
                    // V√©rifier si c'est une nouvelle donation (en utilisant le timestamp)
                    const lastProcessedDonation = localStorage.getItem('lastProcessedDonation') || '0';
                    
                    if (donation.timestamp > parseInt(lastProcessedDonation)) {
                        // Traiter la donation
                        simulateDonation(donation.username, donation.amount);
                        // Marquer comme trait√©e
                        localStorage.setItem('lastProcessedDonation', donation.timestamp.toString());
                    }
                } catch (e) {
                    console.error("Erreur lors du traitement d'une donation externe:", e);
                }
            }
        }
        
        // √âcouter les messages du simulateur de dons externe
        window.addEventListener('message', function(event) {
            // V√©rification de s√©curit√© (si n√©cessaire, v√©rifiez l'origine)
            if (event.data && event.data.type === 'donation') {
                const donation = event.data.data;
                simulateDonation(donation.username, donation.amount);
            }
        });
        
        // V√©rifier p√©riodiquement les dons externes
        setInterval(checkExternalDonations, 2000);
        
        // Ajouter le gestionnaire pour ouvrir le simulateur de dons
        const openDonationSimulatorBtn = document.getElementById('open-donation-simulator');
        if (openDonationSimulatorBtn) {
            openDonationSimulatorBtn.addEventListener('click', function() {
                // Suppression de l'ouverture de la nouvelle fen√™tre
                // window.open('donation_simulator.html', 'DonationSimulator', 'width=550,height=600');
                
                // V√©rifier si un panneau existe d√©j√† et le supprimer
                const existingPanel = document.getElementById('inline-donation-panel');
                if (existingPanel) {
                    existingPanel.remove();
                    return;
                }
                
                // Cr√©er un panneau flottant
                const panel = document.createElement('div');
                panel.id = 'inline-donation-panel';
                panel.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    width: 300px;
                    background: rgba(0, 0, 0, 0.9);
                    border: 1px solid #ff3366;
                    z-index: 1000;
                    padding: 15px;
                    color: white;
                    border-radius: 5px;
                    box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
                `;
                
                // Ajouter le contenu du simulateur
                panel.innerHTML = `
                    <h3 style="text-align: center; margin-top: 0;">Simulateur de Dons</h3>
                    <button id="close-simulator" style="position: absolute; top: 5px; right: 5px; background: none; border: none; color: #fff; cursor: pointer; font-size: 16px;">√ó</button>
                    <div style="margin-bottom: 15px;">
                        <label>Nom d'utilisateur:</label>
                        <input type="text" id="sim-username" value="Utilisateur${Math.floor(Math.random() * 1000)}" style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label>Montant:</label>
                        <input type="number" id="sim-amount" value="5" min="1" max="1000" style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label>Message (optionnel):</label>
                        <input type="text" id="sim-message" placeholder="Message avec votre don..." style="width: 100%; margin-top: 5px; padding: 5px; background: #111; color: #fff; border: 1px solid #333;">
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <button id="donate-2" style="flex: 1; margin-right: 5px; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+2‚Ç¨</button>
                        <button id="donate-5" style="flex: 1; margin-right: 5px; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+5‚Ç¨</button>
                        <button id="donate-10" style="flex: 1; background: #444; border: none; color: white; padding: 8px; cursor: pointer;">+10‚Ç¨</button>
                    </div>
                    <button id="send-donation" style="width: 100%; margin-top: 15px; background: #ff3366; border: none; color: white; padding: 10px; cursor: pointer;">Simuler le Don</button>
                `;
                
                // Ajouter le panneau au document
                document.body.appendChild(panel);
                
                // G√©rer la fermeture du panneau
                document.getElementById('close-simulator').addEventListener('click', () => {
                    panel.remove();
                });
                
                // G√©rer les boutons de montant pr√©d√©finis
                document.getElementById('donate-2').addEventListener('click', () => {
                    document.getElementById('sim-amount').value = "2";
                });
                
                document.getElementById('donate-5').addEventListener('click', () => {
                    document.getElementById('sim-amount').value = "5";
                });
                
                document.getElementById('donate-10').addEventListener('click', () => {
                    document.getElementById('sim-amount').value = "10";
                });
                
                // G√©rer l'envoi du don
                document.getElementById('send-donation').addEventListener('click', async () => {
                    const username = document.getElementById('sim-username').value || `Utilisateur${Math.floor(Math.random() * 1000)}`;
                    const amount = parseFloat(document.getElementById('sim-amount').value) || 5;
                    const message = document.getElementById('sim-message').value || '';
                    
                    if (amount <= 0) {
                        alert('Veuillez entrer un montant positif.');
                        return;
                    }
                    
                    try {
                        // Simuler le don via l'API
                        const response = await fetch('/api/simulate/donation', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ username, amount, message })
                        });
                        
                        const data = await response.json();
                        
                        if (data.success) {
                            // Fermer le panneau apr√®s un don r√©ussi
                            panel.remove();
                            // Traiter le don localement si n√©cessaire
                            simulateDonation(username, amount);
                        } else {
                            console.error('Erreur lors de la simulation du don:', data.message);
                            alert('Erreur lors de la simulation du don: ' + data.message);
                        }
                    } catch (error) {
                        console.error('Erreur lors de la simulation du don:', error);
                        alert('Erreur lors de la simulation du don.');
                    }
                });
            });
        }
        
        // Ajout de la fonction manquante updateCameraPosition
        function updateCameraPosition() {
            if (!window.camera || !window.boat) return;
            
            // Positionner la cam√©ra derri√®re le bateau
            window.camera.position.x = window.boat.position.x;
            window.camera.position.y = window.boat.position.y + 1.5;
            window.camera.position.z = window.boat.position.z - 5;
            
            // Orienter la cam√©ra vers le bateau
            window.camera.lookAt(window.boat.position);
        }
        
        // Fonction pour mettre √† jour les √©l√©ments myst√©rieux (optimis√©e)
        function updateMysteryElements() {
            if (!window.mysteryElements || !window.boat) return;
            
            // D√©finir une distance maximale pour les mises √† jour (optimisation importante)
            const maxDistance = 250; // Unit√©s 3D
            const maxDistanceSquared = maxDistance * maxDistance;
            
            for (let i = 0; i < window.mysteryElements.length; i++) {
                const element = window.mysteryElements[i];
                if (!element || !element.mesh) continue;
                
                // Calculer la distance au carr√© (√©vite le calcul co√ªteux de racine carr√©e)
                const dx = element.mesh.position.x - window.boat.position.x;
                const dz = element.mesh.position.z - window.boat.position.z;
                const distanceSquared = dx * dx + dz * dz;
                
                // Ne mettre √† jour que les √©l√©ments proches du bateau
                if (distanceSquared > maxDistanceSquared) {
                    // Si l'√©l√©ment a une propri√©t√© visible, le cacher s'il est trop loin
                    if (element.mesh.visible) {
                        element.mesh.visible = false;
                    }
                    continue;
                } else if (!element.mesh.visible) {
                    // Rendre visible si on s'en rapproche
                    element.mesh.visible = true;
                }
                
                // Animation de l'eau (moins fr√©quente)
                if (element.type === 'water' && window.frameCounter % 10 === 0) {
                    const time = performance.now() / 1000;
                    element.mesh.position.y = Math.sin(time + i) * 0.2 - 0.5;
                }
                
                // Animation de certains objets
                if (element.type === 'apparition') {
                    // Animation plus simple
                    const time = performance.now() / 1000;
                    element.mesh.rotation.y += 0.01;
                    element.mesh.position.y = Math.sin(time) * 0.5 + element.initialY;
                } else if (element.type === 'wallLight' && window.frameCounter % 15 === 0) {
                    // Animation moins fr√©quente pour les lumi√®res
                    const intensity = 0.5 + Math.sin(performance.now() / 500) * 0.5;
                    if (element.light) {
                        element.light.intensity = intensity;
                    }
                }
            }
            
            // Animation des segments de tunnel (moins fr√©quente et seulement pour les segments proches)
            if (window.tunnelSegments) {
                for (let i = 0; i < window.tunnelSegments.length; i++) {
                    const segment = window.tunnelSegments[i];
                    if (!segment.mesh) continue;
                    
                    // Calculer la distance
                    const dx = segment.mesh.position.x - window.boat.position.x;
                    const dz = segment.mesh.position.z - window.boat.position.z;
                    const distanceSquared = dx * dx + dz * dz;
                    
                    // Ne traiter que les segments proches
                    if (distanceSquared > maxDistanceSquared) continue;
                    
                    // Animation r√©duite et moins fr√©quente
                    if (window.frameCounter % 20 === 0 && segment.lights) {
                        for (let j = 0; j < segment.lights.length; j++) {
                            const light = segment.lights[j];
                            if (light) {
                                // Animation simplifi√©e
                                const intensity = 0.7 + Math.sin(performance.now() / 1000 + j * 0.5) * 0.3;
                                light.intensity = intensity;
                            }
                        }
                    }
                }
            }
        }

        // Fonction pour v√©rifier et mettre √† jour le tunnel
        function checkTunnel() {
            if (!window.boat || !window.segments || window.segments.length === 0) return;
            
            // Position actuelle du bateau
            const boatZ = window.boat.position.z;
            
            // Dernier segment existant
            const lastSegment = window.segments[window.segments.length - 1];
            
            // Premier segment existant
            const firstSegment = window.segments[0];
            
            // V√©rifier si on doit ajouter un nouveau segment (si le bateau s'approche de la fin du tunnel)
            if (boatZ > lastSegment.userData.zPosition - TUNNEL_LENGTH) {
                // Cr√©er un nouveau segment √† la fin
                const newSegmentZ = lastSegment.userData.zPosition + TUNNEL_LENGTH;
                createSegment(newSegmentZ);
                
                // Supprimer le premier segment si on a plus de 5 segments (pour √©conomiser les ressources)
                if (window.segments.length > 5) {
                    const oldSegment = window.segments.shift(); // Retirer le premier segment
                    window.scene.remove(oldSegment);
                    
                    // Supprimer les portes associ√©es √† ce segment
                    window.doors = window.doors.filter(door => !oldSegment.children.includes(door));
                }
            }
        }
        
        // Ajouter une fonction pour cr√©er et mettre √† jour le panneau d'objectifs
        function createObjectivesPanel() {
            // Cr√©er le panneau s'il n'existe pas d√©j√†
            if (!document.getElementById('objectives-panel')) {
                const panel = document.createElement('div');
                panel.id = 'objectives-panel';
                document.body.appendChild(panel);
            }
            
            updateObjectivesPanel();
        }
        
        function updateObjectivesPanel() {
            const panel = document.getElementById('objectives-panel');
            if (!panel) return;
            
            panel.innerHTML = '';
            
            // Ajouter l'objectif principal (jalon actuel)
            if (window.currentMilestoneIndex < STORY_MILESTONES.length) {
                const currentMilestone = STORY_MILESTONES[window.currentMilestoneIndex];
                
                const objective = document.createElement('div');
                objective.className = 'objective';
                
                const icon = document.createElement('span');
                icon.className = 'objective-icon';
                icon.textContent = 'üéØ';
                
                const text = document.createElement('span');
                text.className = 'objective-text';
                text.textContent = currentMilestone.title;
                
                objective.appendChild(icon);
                objective.appendChild(text);
                panel.appendChild(objective);
            }
            
            // Ajouter des objectifs secondaires si n√©cessaire
            if (window.activeSecondaryObjectives && window.activeSecondaryObjectives.length > 0) {
                window.activeSecondaryObjectives.forEach(obj => {
                    const objective = document.createElement('div');
                    objective.className = 'objective';
                    
                    const icon = document.createElement('span');
                    icon.className = 'objective-icon';
                    icon.textContent = obj.completed ? '‚úÖ' : '‚≠ê';
                    
                    const text = document.createElement('span');
                    text.className = 'objective-text';
                    text.textContent = obj.text;
                    
                    objective.appendChild(icon);
                    objective.appendChild(text);
                    panel.appendChild(objective);
                });
            }
        }
        
        // Surcharger la fonction unlockNextMilestone pour mettre √† jour √©galement les objectifs
        const originalUnlockNextMilestone2 = unlockNextMilestone;
        unlockNextMilestone = function(username) {
            originalUnlockNextMilestone2(username);
            updateObjectivesPanel();
            
            // Mettre √† jour les fen√™tres de d√©tails si elles sont ouvertes
            if (window.detailWindows && window.detailWindows.length > 0) {
                window.sendDataToExplorationDetails();
            }
        };
        
        // Ajouter une fonction pour envoyer les donn√©es √† la page des d√©tails d'exploration
        window.sendDataToExplorationDetails = function() {
            // Nettoyer les fen√™tres ferm√©es
            window.detailWindows = window.detailWindows.filter(w => !w.closed);
            
            // Parcourir les fen√™tres encore ouvertes
            window.detailWindows.forEach(detailWindow => {
                try {
                    // V√©rifier si la fen√™tre est accessible et si la fonction est disponible
                    if (detailWindow && !detailWindow.closed && typeof detailWindow.updateExplorationData === 'function') {
                        const data = {
                            leaderboard: window.leaderboard || [],
                            storyHistory: window.storyHistory || [],
                            discoveredClues: window.discoveredClues || [],
                            totalDonations: window.totalDonations || 0,
                            storyProgress: window.storyProgress || 0,
                            STORY_ELEMENTS: window.STORY_ELEMENTS || { clues: [], mysteries: [] }
                        };
                        detailWindow.updateExplorationData(data);
                        console.log("Donn√©es envoy√©es √† la page de d√©tails");
                    }
                } catch (e) {
                    console.error("Erreur lors de l'envoi des donn√©es √† la fen√™tre:", e);
                }
            });
        };
        
        // V√©rifier p√©riodiquement les fen√™tres de d√©tails
        setInterval(() => {
            if (window.detailWindows && window.detailWindows.length > 0) {
                window.sendDataToExplorationDetails();
            }
        }, 5000); // Toutes les 5 secondes
        
        // D√©finir une liste d'entit√©s narratives qui peuvent appara√Ætre avec le temps
        const NARRATIVE_ENTITIES = [
            { 
                id: "ancient_guardian", 
                name: "Gardien Ancien", 
                description: "Une silhouette luminescente qui semble observer les explorateurs depuis les profondeurs.",
                minChapter: 2,
                rarity: 0.2,
                onAppear: function() {
                    addToStoryHistory('event', "Un Gardien Ancien est apparu au loin, observant silencieusement.");
                    playAmbientSound('whisper', 0.5);
                }
            },
            { 
                id: "echo_wisp", 
                name: "√âcho Lumineux", 
                description: "Une orbe de lumi√®re qui r√©p√®te les derniers mots prononc√©s dans le tunnel.",
                minChapter: 1,
                rarity: 0.4,
                onAppear: function() {
                    addToStoryHistory('discovery', "Un √âcho Lumineux flotte dans les airs, r√©p√©tant des fragments de conversation.");
                    createFloatingLight();
                }
            },
            { 
                id: "memory_crystal", 
                name: "Cristal de M√©moire", 
                description: "Un cristal qui contient des fragments de souvenirs d'une civilisation oubli√©e.",
                minChapter: 3,
                rarity: 0.3,
                onAppear: function() {
                    addToStoryHistory('discovery', "Un Cristal de M√©moire a √©t√© d√©couvert, pulsant doucement avec la lumi√®re.");
                    revealRandomClue();
                }
            },
            { 
                id: "shadow_lurker", 
                name: "R√¥deur des Ombres", 
                description: "Une forme sombre qui se d√©place furtivement dans les recoins les plus obscurs.",
                minChapter: 4,
                rarity: 0.15,
                onAppear: function() {
                    addToStoryHistory('event', "Un R√¥deur des Ombres a √©t√© aper√ßu bri√®vement avant de dispara√Ætre dans l'obscurit√©.");
                    flickerLights(0.7);
                }
            },
            { 
                id: "whispering_statue", 
                name: "Statue Murmurante", 
                description: "Une statue ancienne qui murmure des indices au passage des voyageurs.",
                minChapter: 2,
                rarity: 0.25,
                onAppear: function() {
                    addToStoryHistory('discovery', "Une Statue Murmurante a √©t√© d√©couverte, r√©v√©lant des indices dans ses chuchotements.");
                    spawnSpecialEntity(2); // Utiliser un type sp√©cifique pour la statue
                }
            },
            { 
                id: "portal_echo", 
                name: "√âcho de Portail", 
                description: "Une d√©chirure temporelle qui montre des aper√ßus d'autres r√©alit√©s.",
                minChapter: 5,
                rarity: 0.1,
                onAppear: function() {
                    addToStoryHistory('event', "Un √âcho de Portail s'est ouvert bri√®vement, r√©v√©lant une vision troublante d'un autre monde.");
                    triggerSpecialEvent();
                }
            },
            { 
                id: "sentient_water", 
                name: "Eau Consciente", 
                description: "Une portion d'eau qui semble avoir d√©velopp√© une forme de conscience.",
                minChapter: 3,
                rarity: 0.2,
                onAppear: function() {
                    addToStoryHistory('discovery', "L'Eau Consciente s'√©l√®ve en formes impossibles, comme anim√©e par une volont√© propre.");
                    createWaterRipple(0.8);
                }
            }
        ];
        
        // Syst√®me de chance bas√© sur le temps pour faire appara√Ætre des entit√©s narratives
        function setupNarrativeEntitySystem() {
            // Intervalle pour v√©rifier l'apparition d'entit√©s (toutes les 3-5 minutes)
            const checkInterval = 180000 + Math.random() * 120000;
            
            // D√©finir l'intervalle
            setInterval(() => {
                // Ne d√©clencher que si le jeu est actif (pas en pause)
                if (window.isPaused) return;
                
                // Chance bas√©e sur l'activit√© r√©cente (dons, commentaires)
                let chanceMultiplier = 1.0;
                const recentActivity = window.recentActivityCount || 0;
                
                // Augmenter les chances si l'activit√© est √©lev√©e
                if (recentActivity > 10) {
                    chanceMultiplier = 1.5;
                } else if (recentActivity > 20) {
                    chanceMultiplier = 2.0;
                }
                
                // Calculer la chance de base (10-20%)
                const baseChance = 0.1 + (Math.random() * 0.1);
                const finalChance = baseChance * chanceMultiplier;
                
                // Tenter l'apparition
                if (Math.random() < finalChance) {
                    spawnRandomNarrativeEntity();
                }
            }, checkInterval);
            
            // Initialiser le compteur d'activit√© r√©cente
            window.recentActivityCount = 0;
            
            // R√©initialiser le compteur toutes les 15 minutes
            setInterval(() => {
                window.recentActivityCount = 0;
            }, 900000);
            
            // Fonction pour incr√©menter l'activit√©
            window.incrementRecentActivity = function() {
                window.recentActivityCount = (window.recentActivityCount || 0) + 1;
            };
            
            console.log("Syst√®me d'entit√©s narratives initialis√©");
        }
        
        // Faire appara√Ætre une entit√© narrative al√©atoire appropri√©e au chapitre actuel
        function spawnRandomNarrativeEntity() {
            // D√©terminer le chapitre actuel
            const currentChapter = window.currentChapter || 1;
            
            // Filtrer les entit√©s disponibles pour ce chapitre
            const availableEntities = NARRATIVE_ENTITIES.filter(entity => 
                entity.minChapter <= currentChapter
            );
            
            if (availableEntities.length === 0) return;
            
            // S√©lection pond√©r√©e par raret√©
            // Les entit√©s plus rares ont moins de chances d'appara√Ætre
            availableEntities.sort(() => Math.random() - 0.5); // M√©langer d'abord
            
            let totalWeight = 0;
            const weightedEntities = availableEntities.map(entity => {
                // Inverser la raret√© pour en faire un poids (plus rare = moins de poids)
                const weight = 1 - entity.rarity;
                totalWeight += weight;
                return {
                    entity,
                    weight
                };
            });
            
            // S√©lectionner une entit√© selon le poids
            let random = Math.random() * totalWeight;
            let selectedEntity = null;
            
            for (const item of weightedEntities) {
                random -= item.weight;
                if (random <= 0) {
                    selectedEntity = item.entity;
                    break;
                }
            }
            
            // Si aucune entit√© n'a √©t√© s√©lectionn√©e (ne devrait pas arriver), prendre la premi√®re
            if (!selectedEntity && weightedEntities.length > 0) {
                selectedEntity = weightedEntities[0].entity;
            }
            
            // Faire appara√Ætre l'entit√©
            if (selectedEntity) {
                console.log(`Entit√© narrative apparue: ${selectedEntity.name}`);
                
                // D√©clencher l'effet d'apparition
                selectedEntity.onAppear();
                
                // Ajouter √† l'historique global
                if (!window.encounteredEntities) {
                    window.encounteredEntities = [];
                }
                
                // V√©rifier si cette entit√© a d√©j√† √©t√© rencontr√©e
                const alreadyEncountered = window.encounteredEntities.some(e => e.id === selectedEntity.id);
                
                if (!alreadyEncountered) {
                    // Premi√®re apparition - ajouter aux entit√©s rencontr√©es
                    window.encounteredEntities.push({
                        id: selectedEntity.id,
                        firstEncountered: new Date().toISOString(),
                        encounterCount: 1
                    });
                    
                    // Afficher une notification pour la premi√®re rencontre
                    showEntityDiscoveryNotification(selectedEntity);
                } else {
                    // Incr√©menter le compteur pour cette entit√©
                    const entity = window.encounteredEntities.find(e => e.id === selectedEntity.id);
                    entity.encounterCount++;
                    entity.lastEncountered = new Date().toISOString();
                }
            }
        }
        
        // Afficher une notification pour la d√©couverte d'une nouvelle entit√©
        function showEntityDiscoveryNotification(entity) {
            // Cr√©er une notification similaire √† celle des indices
            const notification = document.createElement('div');
            notification.id = 'entity-notification';
            notification.style.cssText = `
                position: fixed;
                top: 20%;
                left: 50%;
                transform: translateX(-50%);
                background-color: rgba(0, 0, 0, 0.8);
                color: #fff;
                padding: 15px 20px;
                border-radius: 8px;
                z-index: 1000;
                text-align: center;
                box-shadow: 0 0 20px rgba(255, 204, 0, 0.5);
                opacity: 0;
                transition: opacity 1s;
                max-width: 80%;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 18px; color: #ffcc00; margin-bottom: 8px;">
                    Nouvelle entit√© d√©couverte: ${entity.name}
                </div>
                <div style="color: #ccc; font-size: 14px;">
                    ${entity.description}
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Animer l'apparition
            setTimeout(() => {
                notification.style.opacity = '1';
            }, 100);
            
            // Disparition apr√®s 6 secondes
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => {
                    notification.remove();
                }, 1000);
            }, 6000);
        }
        
        // Cr√©er une lumi√®re flottante (pour l'entit√© √âcho Lumineux)
        function createFloatingLight() {
            // Cr√©er un groupe pour la lumi√®re
            const lightGroup = new THREE.Group();
            
            // Position al√©atoire dans le tunnel, mais visible depuis le bateau
            const boat = window.boat;
            if (!boat) return;
            
            // D√©finir une position al√©atoire devant le bateau
            const randomAngle = Math.random() * Math.PI * 2;
            const randomRadius = 2 + Math.random() * 3;
            const randomHeight = -1 + Math.random() * 2;
            
            const x = boat.position.x + Math.cos(randomAngle) * randomRadius;
            const y = randomHeight;
            const z = boat.position.z + Math.sin(randomAngle) * randomRadius + 5; // Toujours un peu devant
            
            // Positionner le groupe
            lightGroup.position.set(x, y, z);
            
            // Cr√©er une sph√®re lumineuse
            const sphereGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const sphereMaterial = new THREE.MeshBasicMaterial({
                color: 0x77ccff,
                transparent: true,
                opacity: 0.7
            });
            
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            lightGroup.add(sphere);
            
            // Ajouter une lumi√®re ponctuelle
            const light = new THREE.PointLight(0x77ccff, 2, 5);
            light.position.set(0, 0, 0);
            lightGroup.add(light);
            
            // Ajouter au groupe des entit√©s sp√©ciales
            window.scene.add(lightGroup);
            
            // Stocker une r√©f√©rence
            if (!window.specialEntities) {
                window.specialEntities = [];
            }
            window.specialEntities.push(lightGroup);
            
            // Animation de flottement
            const startTime = Date.now();
            const duration = 10000 + Math.random() * 5000; // 10-15 secondes
            
            function animateFloatingLight() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;
                
                if (progress >= 1) {
                    // Supprimer la lumi√®re apr√®s la dur√©e
                    window.scene.remove(lightGroup);
                    window.specialEntities = window.specialEntities.filter(e => e !== lightGroup);
                    return;
                }
                
                // Animation de flottement
                const floatY = Math.sin(elapsed * 0.003) * 0.2;
                const floatX = Math.sin(elapsed * 0.002) * 0.1;
                const floatZ = Math.cos(elapsed * 0.002) * 0.1;
                
                lightGroup.position.y = y + floatY;
                lightGroup.position.x = x + floatX;
                lightGroup.position.z = z + floatZ;
                
                // Faire pulser la lumi√®re
                const pulseScale = 0.8 + Math.sin(elapsed * 0.006) * 0.2;
                sphere.scale.set(pulseScale, pulseScale, pulseScale);
                
                // Faire varier l'intensit√© de la lumi√®re
                light.intensity = 1.5 + Math.sin(elapsed * 0.006) * 0.5;
                
                // Continuer l'animation
                requestAnimationFrame(animateFloatingLight);
            }
            
            // D√©marrer l'animation
            animateFloatingLight();
        }
        
        // Initialiser le syst√®me d'entit√©s narratives au chargement
        function initGameSystems() {
            // Initialiser les syst√®mes existants
            
            // Ajouter le syst√®me d'entit√©s narratives
            setupNarrativeEntitySystem();
            
            console.log('Tous les syst√®mes de jeu ont √©t√© initialis√©s');
        }
        
        // Ajouter √† la fonction init
        const originalInit = init;
        init = function() {
            // Appeler la fonction init originale
            originalInit();
            
            // Initialiser nos syst√®mes de jeu √©tendus
            initGameSystems();
        };
        
        // Configuration du syst√®me de vote
    </script>

    <div id="leaderboard-panel">
        <h3>Classement des Explorateurs</h3>
        <div id="leaderboard-list">
            <!-- Le classement sera ajout√© ici dynamiquement -->
                        </div>
                        </div>
                        
    <div id="story-history-panel">
        <h3>Journal des Messages</h3>
        <div id="story-history-list">
            <!-- L'historique sera ajout√© ici dynamiquement -->
                        </div>
                        </div>
                        
    <!-- Espace r√©serv√© pour la future impl√©mentation de la cam√©ra -->
    <div class="camera-space"></div>
</html>
    <!-- Socket.IO client library -->
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <!-- Script de correctifs --> 
    <script src="fixes.js"></script> 
    <!-- Script de correctifs --> 
    <script src="fixes.js"></script> 

        <script>
        // Code d'injection automatique pour corriger les probl√®mes
        console.log('üîß Injection de corrections automatiques...');
        
        // Correction des thresholds
        window.THRESHOLDS_FIX = {
            tiers: [
                { name: "Tier 1", threshold: 20, activated: false },
                { name: "Tier 2", threshold: 50, activated: false },
                { name: "Tier 3", threshold: 100, activated: false }
            ],
            currentTier: 0,
            requiredAmount: 20
        };
        
        // Red√©finir la fonction de v√©rification des thresholds
        function checkThresholds(amount) {
            // Utiliser nos thresholds de secours si n√©cessaire
            const thresholds = window.sharedData?.thresholds || window.THRESHOLDS_FIX;
            console.log('üîç V√©rification des seuils avec montant:', amount);
            
            if (thresholds) {
                // V√©rifier si un palier est atteint
                for (let i = 0; i < thresholds.tiers.length; i++) {
                    const tier = thresholds.tiers[i];
                    if (!tier.activated && amount >= tier.threshold) {
                        console.log('üéâ Palier atteint:', tier.name);
                        tier.activated = true;
                        thresholds.currentTier = i;
                        return true;
                    }
                }
            } else {
                console.warn('‚ö†Ô∏è Aucun threshold disponible');
            }
            return false;
        }
        
        // Red√©finir la fonction de simulation de don pour utiliser notre checkThresholds
        window.originalSimulateDonation = window.simulateDonation;
        window.simulateDonation = function(event) {
            try {
                const amount = parseInt(document.getElementById('donation-amount').value) || 20;
                const username = document.getElementById('donation-username').value || 'Anonyme';
                
                console.log('üí∞ Simulation de don:', amount, 'de', username);
                
                // Utiliser notre version de checkThresholds
                checkThresholds(amount);
                
                // Mettre √† jour les donn√©es partag√©es
                if (window.sharedData) {
                    if (!window.sharedData.thresholds) {
                        window.sharedData.thresholds = window.THRESHOLDS_FIX;
                    }
                } else {
                    window.sharedData = { thresholds: window.THRESHOLDS_FIX };
                }
                
                // Envoyer l'√©v√©nement via le serveur central
                if (window.centralSocket && window.centralSocket.connected) {
                    window.centralSocket.emit('simulateDonation', {
                        username: username,
                        amount: amount,
                        message: ''
                    });
                }
                
                // Mettre √† jour la jauge manuellement
                if (window.updateAuthGauge) {
                    window.updateAuthGauge(amount);
                }
                
                // Ajouter √† l'historique
                if (window.addEventToHistory) {
                    window.addEventToHistory({
                        type: 'donation',
                        username: username,
                        amount: amount,
                        message: ''
                    });
                }
                
                console.log('‚úÖ Don simul√© avec succ√®s');
            } catch (error) {
                console.error('‚ùå Erreur lors de la simulation de don:', error);
            }
        };
        
        // Corriger la connexion socket
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üîå Configuration des connexions socket alternatives...');
            
            // Connexion au serveur central
            try {
                window.centralSocket = io('http://localhost:3333');
                
                window.centralSocket.on('connect', function() {
                    console.log('‚úÖ Connect√© au serveur central sur le port 3333');
                    
                    // S'enregistrer comme client Sethos
                    window.centralSocket.emit('register_client', { type: 'sethos' });
                    
                    // Recevoir les mises √† jour du syst√®me
                    window.centralSocket.on('system_state', function(data) {
                        console.log('üìä √âtat du syst√®me re√ßu:', data);
                        
                        // Mettre √† jour les donn√©es partag√©es
                        window.sharedData = data;
                        
                        // Mettre √† jour la progression si disponible
                        if (data.auth && data.auth.progress && window.updateAuthGauge) {
                            window.updateAuthGauge(0, null, data.auth.progress);
                        }
                        
                        // Mettre √† jour les thresholds
                        if (data.thresholds) {
                            window.THRESHOLDS_FIX = data.thresholds;
                        }
                    });
                    
                    // Recevoir les √©v√©nements (donations, etc.)
                    window.centralSocket.on('event', function(data) {
                        console.log('üì© √âv√©nement re√ßu:', data);
                        
                        if (data.type === 'donation') {
                            // Mettre √† jour la jauge d'authentification
                            if (window.updateAuthGauge) {
                                window.updateAuthGauge(data.amount, data.username);
                            }
                            
                            // Mettre √† jour la liste des √©v√©nements
                            addEventToHistory(data);
                        }
                    });
                    
                    // Recevoir les √©v√©nements d'histoire
                    window.centralSocket.on('story_update', function(eventData) {
                        console.log('üìñ √âv√©nement d\'histoire re√ßu:', eventData);
                        
                        // Traiter l'√©v√©nement d'histoire
                        if (window.triggerEvent) {
                            window.triggerEvent(eventData);
                        } else {
                            console.warn('‚ö†Ô∏è La fonction triggerEvent n\'est pas disponible');
                        }
                        
                        // Ajouter √† l'historique
                        addEventToHistory({
                            type: 'story_event',
                            username: 'Syst√®me',
                            message: `√âv√©nement: ${eventData.type || eventData.name || 'inconnu'}`
                        });
                    });
                });
            } catch (e) {
                console.error('‚ùå Erreur lors de la connexion au serveur central:', e);
            }
            
            // Fonction pour ajouter un √©v√©nement √† l'historique
            window.addEventToHistory = function(event) {
                const historyList = document.getElementById('story-history-list');
                if (!historyList) return;
                
                const eventItem = document.createElement('div');
                eventItem.className = 'history-item';
                
                if (event.type === 'donation') {
                    eventItem.innerHTML = `<strong>${event.username}</strong>: ${event.amount}‚Ç¨ - ${event.message || ''}`;
                } else {
                    eventItem.innerHTML = `<strong>${event.username || 'Syst√®me'}</strong>: ${event.type}`;
                }
                
                historyList.appendChild(eventItem);
                historyList.scrollTop = historyList.scrollHeight;
            };
            
            // Fonction pour traiter les √©v√©nements re√ßus
            window.triggerEvent = function(eventData) {
                console.log('üé¨ Traitement de l\'√©v√©nement:', eventData);
                
                try {
                    // Afficher l'√©v√©nement dans le journal d'exploration
                    const eventName = eventData.name || eventData.type || '√âv√©nement inconnu';
                    
                    // Si c'est une s√©quence, traiter chaque action
                    if (eventData.type === 'sequence' && eventData.sequence && Array.isArray(eventData.sequence)) {
                        console.log(`üîÑ Ex√©cution d'une s√©quence de ${eventData.sequence.length} actions`);
                        
                        // Traiter chaque action de la s√©quence avec un d√©lai
                        eventData.sequence.forEach((action, index) => {
                            setTimeout(() => {
                                console.log(`üîÑ Action s√©quence #${index+1}:`, action);
                                processAction(action);
                            }, index * 1000); // D√©lai de 1 seconde entre chaque action
                        });
                    } else {
                        // Traiter l'√©v√©nement directement s'il n'est pas une s√©quence
                        processAction(eventData);
                    }
                    
                    // Mise √† jour du statut narratif si applicable
                    updateNarrativeStatus(eventData);
                    
                } catch (error) {
                    console.error('‚ùå Erreur lors du traitement de l\'√©v√©nement:', error);
                }
            };
            
            // Fonction interne pour traiter une action individuelle
            function processAction(action) {
                // Traiter diff√©rents types d'actions
                switch (action.type) {
                    case 'message':
                        // Afficher un message √† l'√©cran
                        displayMessage(
                            action.parameters?.text || "Message syst√®me", 
                            action.duration || 5,
                            action.parameters?.color || "#FFFFFF"
                        );
                        break;
                        
                    case 'sound':
                        // Jouer un son
                        playSound(
                            action.parameters?.soundName, 
                            action.parameters?.volume || 0.5, 
                            action.parameters?.loop || false
                        );
                        break;
                        
                    case 'light':
                        // Effet de lumi√®re
                        if (action.parameters?.color) {
                            applyLightEffect(
                                action.parameters.color, 
                                action.parameters?.pattern || 'solid', 
                                action.duration || 3
                            );
                        }
                        break;
                        
                    case 'image':
                        // Afficher une image
                        if (action.parameters?.file) {
                            displayImage(
                                action.parameters.file, 
                                action.parameters?.position || 'center', 
                                action.duration || 10
                            );
                        }
                        break;
                        
                    case 'boat':
                        // Contr√¥ler le bateau
                        if (action.parameters?.action) {
                            controlBoat(
                                action.parameters.action, 
                                action.parameters?.speed || 'normal'
                            );
                        }
                        break;
                        
                    case 'door':
                        // Contr√¥ler une porte
                        if (action.parameters?.doorId && action.parameters?.action) {
                            controlDoor(
                                action.parameters.doorId, 
                                action.parameters.action
                            );
                        }
                        break;
                        
                    default:
                        console.log(`‚ö†Ô∏è Type d'action non g√©r√©: ${action.type}`);
                }
            }
            
            // Fonctions auxiliaires pour les √©v√©nements
            function displayMessage(text, duration, color) {
                const narrativeDisplay = document.getElementById('narrative-display');
                if (!narrativeDisplay) return;
                
                narrativeDisplay.textContent = text;
                narrativeDisplay.style.color = color || '#FFFFFF';
                narrativeDisplay.style.opacity = '1';
                
                // Masquer apr√®s une dur√©e sp√©cifi√©e
                setTimeout(() => {
                    narrativeDisplay.style.opacity = '0';
                }, duration * 1000);
                
                console.log(`üí¨ Message affich√©: "${text}" (${duration}s)`);
            }
            
            function playSound(soundName, volume, loop) {
                console.log(`üîä Son jou√©: ${soundName}, Volume: ${volume}, Loop: ${loop}`);
                // Impl√©menter la lecture du son ici
            }
            
            function applyLightEffect(color, pattern, duration) {
                console.log(`üí° Effet de lumi√®re: ${color}, Mod√®le: ${pattern}, Dur√©e: ${duration}s`);
                // Impl√©menter l'effet lumineux ici
            }
            
            function displayImage(file, position, duration) {
                console.log(`üñºÔ∏è Image affich√©e: ${file}, Position: ${position}, Dur√©e: ${duration}s`);
                // Impl√©menter l'affichage d'image ici
            }
            
            function controlBoat(action, speed) {
                console.log(`‚õµ Contr√¥le du bateau: ${action}, Vitesse: ${speed}`);
                // Impl√©menter le contr√¥le du bateau ici
            }
            
            function controlDoor(doorId, action) {
                console.log(`üö™ Contr√¥le de la porte ${doorId}: ${action}`);
                // Impl√©menter le contr√¥le de la porte ici
            }
            
            function updateNarrativeStatus(eventData) {
                // Mise √† jour du statut narratif en fonction de l'√©v√©nement
                const milestone = document.getElementById('story-milestone');
                if (milestone && eventData.name) {
                    milestone.textContent = eventData.name;
                    milestone.style.display = 'block';
                    
                    // Masquer apr√®s 5 secondes
                    setTimeout(() => {
                        milestone.style.display = 'none';
                    }, 5000);
                }
            }
            
            // R√©initialiser le socket TikTok toutes les 5 secondes s'il n'est pas connect√©
            window.tikTokReconnectInterval = setInterval(function() {
                if (!window.tiktokSocket || !window.tiktokSocket.connected) {
                    console.log('üîÑ Tentative de reconnexion au serveur TikTok...');
                    try {
                        window.tiktokSocket = io('http://localhost:8092');
                        
                        window.tiktokSocket.on('connect', function() {
                            console.log('‚úÖ Connect√© au serveur TikTok');
                        });
                        
                        window.tiktokSocket.on('tiktokEvent', function(data) {
                            console.log('üì® √âv√©nement TikTok re√ßu:', data);
                            if (data.type === 'donation') {
                                // Simuler un don re√ßu
                                if (window.updateAuthGauge) {
                                    window.updateAuthGauge(data.amount || 10, data.username);
                                }
                            }
                        });
                    } catch (e) {
                        console.error('‚ùå Erreur lors de la reconnexion TikTok:', e);
                    }
                }
            }, 5000);
        });
        </script>
        
</body> 

